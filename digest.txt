Directory structure:
‚îî‚îÄ‚îÄ osu-challenge-tracker/
    ‚îú‚îÄ‚îÄ README.md
    ‚îú‚îÄ‚îÄ docker-compose.yml
    ‚îú‚îÄ‚îÄ setup.sh
    ‚îú‚îÄ‚îÄ .env.local.example
    ‚îú‚îÄ‚îÄ frontend/
    ‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
    ‚îÇ   ‚îú‚îÄ‚îÄ middleware.js
    ‚îÇ   ‚îú‚îÄ‚îÄ next.config.js
    ‚îÇ   ‚îú‚îÄ‚îÄ package.json
    ‚îÇ   ‚îú‚îÄ‚îÄ postcss.config.js
    ‚îÇ   ‚îú‚îÄ‚îÄ tailwind.config.js
    ‚îÇ   ‚îú‚îÄ‚îÄ vercel.json
    ‚îÇ   ‚îú‚îÄ‚îÄ components/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AuthDebug.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ChallengeCard.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ChristmasSnowfall.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ChristmasTree.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CombinedLeaderboard.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DonationForm.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ErrorBoundary.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ExpandedPartnerModal.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ExpandedTeamModal.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Layout.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Loading.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MedalsDisplay.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ModSelector.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MonitoringDashboard.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PartnerCard.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RulesetManager.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ScoreTable.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SeasonLeaderboard.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SeasonSelector.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SubscriptionManager.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TeamCard.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UserStats.js
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ settings/
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ AppearanceTab.js
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ ColorPicker.js
    ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ DonorPerksTab.js
    ‚îÇ   ‚îú‚îÄ‚îÄ hooks/
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useAPI.js
    ‚îÇ   ‚îú‚îÄ‚îÄ lib/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api-tracker.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api-utils.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth-middleware.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AuthContext.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cache-invalidation.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date-utils.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ memory-cache.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ osu-api.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ osu-mods-reference.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ruleset-name-generator.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ seasons.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ secure-auth.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ security.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SettingsContext.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stripe.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ supabase-admin.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ supabase.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sync-config.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ text-formatting.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ token-encryption.js
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ update-tracker.js
    ‚îÇ   ‚îú‚îÄ‚îÄ pages/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _app.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _document.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ admin.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ bulk-update.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ challenges.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ donate.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ leaderboard.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ monitoring-admin.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ partners.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ settings.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ thank-you.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ admin/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ challenges.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ schedules.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ create-payment-intent.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ debug-api-tracking.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ debug-room.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ health.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stats.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ team.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test-tracking.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ update-challenge.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ verify-payment.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ admin/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api-calls.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ bulk-update-challenges.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ challenges.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ partners.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduled-challenges.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ schedules.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ track-call.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user-token.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ vercel-usage.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ verify-schedule-permission.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ rulesets/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ [challengeId].js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ validate.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ callback.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logout.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ status.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ card/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ challenges/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [roomId].js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cron/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ process-scheduled-challenges.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ status.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ update-challenges.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ emergency/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ invalidate-sessions.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ partners/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [id].js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ seasons/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ current.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ leaderboard.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ settings/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ subscriptions/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cancel.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ profile/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ [userId].js
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook/
    ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ stripe.js
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ challenges/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [roomId].js
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ profile/
    ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ [userId].js
    ‚îÇ   ‚îú‚îÄ‚îÄ public/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ site.webmanifest
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ fonts/
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Inter-Bold.ttf
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ Inter-ExtraBold.ttf
    ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ Inter.ttf
    ‚îÇ   ‚îú‚îÄ‚îÄ styles/
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ globals.css
    ‚îÇ   ‚îî‚îÄ‚îÄ supabase/
    ‚îÇ       ‚îî‚îÄ‚îÄ config.toml
    ‚îî‚îÄ‚îÄ .github/
        ‚îî‚îÄ‚îÄ workflows/
            ‚îî‚îÄ‚îÄ deploy.yml

================================================
FILE: README.md
================================================
# üéÆ osu!Challengers Nexus

![Next.js](https://img.shields.io/badge/Next.js-14-black?style=flat&logo=next.js)
![Supabase](https://img.shields.io/badge/Supabase-PostgreSQL-green?style=flat&logo=supabase)
![Stripe](https://img.shields.io/badge/Stripe-Payments-635bff?style=flat&logo=stripe)
![Tailwind CSS](https://img.shields.io/badge/Tailwind-CSS-38bdf8?style=flat&logo=tailwindcss)
![License](https://img.shields.io/badge/License-MIT-blue?style=flat)

A comprehensive web platform designed to track, manage, and gamify multiplayer challenges within the osu! community. Features live tracking, seasonal leaderboards with weighted scoring, custom ruleset validation.

---

## üèóÔ∏è Tech Stack

| Layer | Technology |
|-------|-----------|
| **Framework** | Next.js 14 (Pages Router), React 18 |
| **Styling** | Tailwind CSS with custom glassmorphism design |
| **Database** | Supabase (PostgreSQL) |
| **Authentication** | Supabase Auth + osu! OAuth 2.0 |
| **Payments** | Stripe API |
| **Deployment** | Docker-ready, Vercel-optimized |

---

## üöÄ Getting Started

### Prerequisites

- Node.js 18 or higher
- npm or yarn
- Supabase project
- osu! API Client (OAuth)
- Stripe account (for donation features)

### Installation

1. **Clone the repository**
   ```bash
   git clone https://github.com/yourusername/osu-challenge-tracker.git
   cd osu-challenge-tracker/frontend
   ```

2. **Install dependencies**
   ```bash
   npm install
   ```

3. **Configure environment variables**
   
   Create a `.env.local` file in the `frontend` directory (use `.env.local.example` as reference):

   ```bash
   # App Configuration
   NEXT_PUBLIC_APP_URL=http://localhost:3000

   # Supabase
   NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
   NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
   SUPABASE_SERVICE_KEY=your-service-role-key

   # osu! OAuth
   OSU_CLIENT_ID=your-osu-client-id
   OSU_CLIENT_SECRET=your-osu-client-secret
   OSU_REDIRECT_URI=http://localhost:3000/api/auth/callback

   # Security
   # Generate with: node -e "console.log(require('crypto').randomBytes(32).toString('base64'))"
   TOKEN_ENCRYPTION_KEY=base64-encoded-32-byte-key
   SESSION_SECRET=your-session-secret
   SCHEDULER_SHARED_SECRET=long-random-string-for-cron-auth

   # Stripe
   STRIPE_SECRET_KEY=sk_test_...
   STRIPE_WEBHOOK_SECRET=whsec_...
   NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_...
   ```

4. **Start the development server**
   ```bash
   npm run dev
   ```

   Navigate to [http://localhost:3000](http://localhost:3000)

### üê≥ Docker Deployment

Build and run the production container:

```bash
# Build
docker build -t osu-challengers ./frontend

# Run
docker run -p 3000:3000 --env-file .env.local osu-challengers
```

---

## üìÅ Project Structure

```
frontend/
‚îú‚îÄ‚îÄ components/              # React components
‚îÇ   ‚îú‚îÄ‚îÄ settings/           # Settings-specific components
‚îÇ   ‚îî‚îÄ‚îÄ ...                 # UI components, cards, modals
‚îú‚îÄ‚îÄ lib/                    # Utilities and business logic
‚îÇ   ‚îú‚îÄ‚îÄ api-utils.js        # API response handling & validation
‚îÇ   ‚îú‚îÄ‚îÄ auth-middleware.js  # Security middleware
‚îÇ   ‚îú‚îÄ‚îÄ osu-api.js          # osu! API wrapper
‚îÇ   ‚îú‚îÄ‚îÄ seasons.js          # Season logic and rotation
‚îÇ   ‚îú‚îÄ‚îÄ stripe.js           # Payment processing
‚îÇ   ‚îî‚îÄ‚îÄ supabase.js         # Database clients
‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îú‚îÄ‚îÄ api/                # Backend API routes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ admin/          # Protected admin endpoints
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth/           # OAuth flow
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ challenges/     # Challenge CRUD operations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cron/           # Scheduled tasks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook/        # Stripe webhooks
‚îÇ   ‚îú‚îÄ‚îÄ admin.js            # Admin dashboard
‚îÇ   ‚îú‚îÄ‚îÄ challenges.js       # Challenge listing
‚îÇ   ‚îú‚îÄ‚îÄ leaderboard.js      # Seasonal leaderboard
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îî‚îÄ‚îÄ public/                 # Static assets and fonts
```

---

## üîÑ Data Syncing Strategy

The platform uses a hybrid update strategy to respect osu! API rate limits while maintaining fresh data:

- **On-Demand Caching** ‚Äî Checks data freshness when users view challenges (default threshold: 5 minutes)
- **Background Cron Jobs** ‚Äî Scheduled tasks at `/api/cron/update-challenges` refresh active challenges periodically
- **Smart Caching** ‚Äî In-memory caching via `memory-cache.js` reduces database load

---

## ü§ù Contributing

Contributions are welcome! Here's how to get started:

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

---

## ‚ö†Ô∏è Disclaimer

This project is not affiliated with, endorsed, or sponsored by ppy Pty Ltd or osu!.

---

## üìû Support

For issues, questions, or feature requests, please [open an issue](https://github.com/yourusername/osu-challenge-tracker/issues) on GitHub.



================================================
FILE: docker-compose.yml
================================================
version: '3.8'

services:
  # Frontend Next.js application
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - NEXT_PUBLIC_SUPABASE_URL=${NEXT_PUBLIC_SUPABASE_URL}
      - NEXT_PUBLIC_SUPABASE_ANON_KEY=${NEXT_PUBLIC_SUPABASE_ANON_KEY}
      - OSU_CLIENT_ID=${OSU_CLIENT_ID}
      - OSU_CLIENT_SECRET=${OSU_CLIENT_SECRET}
      - OSU_REDIRECT_URI=${OSU_REDIRECT_URI}
      - NEXT_PUBLIC_APP_URL=${NEXT_PUBLIC_APP_URL}
    depends_on:
      - backend-worker
    restart: unless-stopped

  # Backend Python worker
  backend-worker:
    build:
      context: ./backend-worker
      dockerfile: Dockerfile
    environment:
      - SUPABASE_URL=${SUPABASE_URL}
      - SUPABASE_SERVICE_KEY=${SUPABASE_SERVICE_KEY}
      - OSU_CLIENT_ID=${OSU_CLIENT_ID}
      - OSU_CLIENT_SECRET=${OSU_CLIENT_SECRET}
      - TRACKED_ROOMS=${TRACKED_ROOMS}
      - UPDATE_INTERVAL=60
      - LOG_LEVEL=INFO
    restart: unless-stopped

  # Local PostgreSQL for development (optional)
  # Uncomment if you want to run Supabase locally
  # postgres:
  #   image: postgres:15-alpine
  #   environment:
  #     - POSTGRES_USER=postgres
  #     - POSTGRES_PASSWORD=postgres
  #     - POSTGRES_DB=osu_tracker
  #   ports:
  #     - "5432:5432"
  #   volumes:
  #     - postgres_data:/var/lib/postgresql/data
  #   restart: unless-stopped

  # Redis for caching (optional enhancement)
  # redis:
  #   image: redis:7-alpine
  #   ports:
  #     - "6379:6379"
  #   restart: unless-stopped

volumes:
  postgres_data:


================================================
FILE: setup.sh
================================================
#!/bin/bash

echo "üéÆ osu! Challenge Tracker Setup Script"
echo "======================================"

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Check if running from project root
if [ ! -f "README.md" ]; then
    echo -e "${RED}Please run this script from the project root directory${NC}"
    exit 1
fi

# Create project structure
echo -e "${YELLOW}Creating project structure...${NC}"
mkdir -p frontend/{components,lib,pages/{api/{auth,challenges,user},challenges},styles}
mkdir -p backend-worker/src

# Initialize frontend
echo -e "${YELLOW}Setting up frontend...${NC}"
cd frontend

# Create package.json
cat > package.json << 'EOF'
{
  "name": "osu-challenge-tracker",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "next": "14.0.4",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "@supabase/supabase-js": "^2.39.0",
    "swr": "^2.2.4",
    "lucide-react": "^0.303.0"
  },
  "devDependencies": {
    "autoprefixer": "^10.4.16",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.4.0",
    "eslint": "^8.56.0",
    "eslint-config-next": "14.0.4"
  }
}
EOF

# Create next.config.js
cat > next.config.js << 'EOF'
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  images: {
    domains: ['a.ppy.sh', 'assets.ppy.sh'],
  },
}

module.exports = nextConfig
EOF

# Create tailwind.config.js
cat > tailwind.config.js << 'EOF'
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        purple: {
          400: '#a855f7',
          500: '#9333ea',
          600: '#7c3aed',
          700: '#6d28d9',
          900: '#4c1d95',
        },
        pink: {
          400: '#f472b6',
          500: '#ec4899',
          900: '#831843',
        },
      },
    },
  },
  plugins: [],
}
EOF

# Create postcss.config.js
cat > postcss.config.js << 'EOF'
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
EOF

# Create global styles
cat > styles/globals.css << 'EOF'
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  body {
    @apply bg-gray-900 text-white;
  }
}

@layer utilities {
  .line-clamp-2 {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
}
EOF

# Create .env.local template
cat > .env.local.example << 'EOF'
# Supabase
NEXT_PUBLIC_SUPABASE_URL=your-supabase-url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-supabase-anon-key

# osu! OAuth
OSU_CLIENT_ID=your-osu-client-id
OSU_CLIENT_SECRET=your-osu-client-secret
OSU_REDIRECT_URI=http://localhost:3000/api/auth/callback

# App URL
NEXT_PUBLIC_APP_URL=http://localhost:3000
EOF

echo -e "${GREEN}Frontend structure created!${NC}"

# Setup backend
cd ../backend-worker

# Create .env template
cat > .env.example << 'EOF'
# Supabase
SUPABASE_URL=your-supabase-url
SUPABASE_SERVICE_KEY=your-supabase-service-key

# osu! API
OSU_CLIENT_ID=your-osu-client-id
OSU_CLIENT_SECRET=your-osu-client-secret

# Tracked rooms (comma-separated)
TRACKED_ROOMS=1392361
EOF

echo -e "${GREEN}Backend structure created!${NC}"

# Create main README
cd ..
cat > README.md << 'EOF'
# osu! Challenge Tracker

Track your progress across osu! community challenges with real-time updates!

## Features
- üéÆ Real-time challenge tracking
- üìä Detailed leaderboards
- üë§ Personal score history
- üîÑ Automatic updates every minute
- üé® Modern, responsive UI

## Tech Stack
- **Frontend**: Next.js, React, Tailwind CSS (Vercel)
- **Backend**: Python worker (Railway)
- **Database**: Supabase (PostgreSQL)
- **Auth**: osu! OAuth

## Quick Start

1. **Setup Environment**
   - Copy `.env.local.example` to `.env.local` in frontend
   - Copy `.env.example` to `.env` in backend-worker
   - Fill in your credentials

2. **Install Dependencies**
   ```bash
   cd frontend && npm install
   cd ../backend-worker && pip install -r requirements.txt
   ```

3. **Run Development**
   ```bash
   # Terminal 1 - Frontend
   cd frontend && npm run dev

   # Terminal 2 - Backend
   cd backend-worker && python src/worker.py
   ```

## Deployment
See [DEPLOYMENT.md](./DEPLOYMENT.md) for detailed deployment instructions.

## License
MIT
EOF

echo -e "${GREEN}‚úÖ Setup complete!${NC}"
echo ""
echo "Next steps:"
echo "1. Copy the provided code files to their respective locations"
echo "2. Set up your environment variables"
echo "3. Create accounts on Supabase, Vercel, and Railway"
echo "4. Follow the deployment guide"
echo ""
echo -e "${YELLOW}Don't forget to:${NC}"
echo "- Create an osu! OAuth application"
echo "- Set up your Supabase database with the provided schema"
echo "- Configure all environment variables"


================================================
FILE: .env.local.example
================================================
# =================================
# osu! Challenge Tracker Environment Configuration
# =================================

# Application Settings
NODE_ENV=development
NEXT_PUBLIC_APP_URL=http://localhost:3000
NEXT_PUBLIC_APP_NAME="osu! Challenge Tracker"

# =================================
# Database Configuration (Supabase)
# =================================
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_KEY=your-service-role-key

# Database connection pool settings
SUPABASE_MAX_CONNECTIONS=20
SUPABASE_IDLE_TIMEOUT=30000

# =================================
# Authentication & Security
# =================================

# JWT Configuration
JWT_SECRET=your-super-secret-jwt-key-min-32-chars
JWT_EXPIRES_IN=7d
JWT_ISSUER=osu-challenge-tracker

# Session Configuration
SESSION_SECRET=your-session-secret-key
SESSION_MAX_AGE=604800000
SESSION_SECURE=false
SESSION_SAME_SITE=lax

# Password hashing
BCRYPT_ROUNDS=12

# CORS Settings
CORS_ORIGINS=http://localhost:3000,http://localhost:3001
CORS_CREDENTIALS=true

# Rate Limiting
RATE_LIMIT_WINDOW_MS=60000
RATE_LIMIT_MAX_REQUESTS=100
RATE_LIMIT_SKIP_FAILED_REQUESTS=true

# =================================
# osu! API Configuration
# =================================
OSU_CLIENT_ID=your-osu-client-id
OSU_CLIENT_SECRET=your-osu-client-secret
OSU_REDIRECT_URI=http://localhost:3000/api/auth/callback

# API Endpoints
OSU_API_BASE_URL=https://osu.ppy.sh/api/v2
OSU_OAUTH_URL=https://osu.ppy.sh/oauth/authorize
OSU_TOKEN_URL=https://osu.ppy.sh/oauth/token

# API Rate Limiting
OSU_API_RATE_LIMIT=60
OSU_API_BURST_LIMIT=120
OSU_API_TIMEOUT=10000

# =================================
# API Tracking & Monitoring
# =================================
VERCEL_API_TOKEN=your_vercel_api_token_here

# =================================
# Caching Configuration
# =================================

# Redis (if using)
REDIS_URL=redis://localhost:6379
REDIS_PASSWORD=
REDIS_DB=0
REDIS_MAX_RETRIES=3

# Memory Cache Settings
CACHE_TTL_DEFAULT=300
CACHE_TTL_SCORES=120
CACHE_TTL_USERS=3600
CACHE_TTL_CHALLENGES=600

# =================================
# File Upload & Storage
# =================================

# Upload limits
MAX_FILE_SIZE=5242880
ALLOWED_FILE_TYPES=image/jpeg,image/png,image/gif,image/webp

# Storage configuration
STORAGE_PROVIDER=supabase
STORAGE_BUCKET=avatars
STORAGE_MAX_SIZE=52428800

# =================================
# Email Configuration (Optional)
# =================================

# SMTP Settings
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_SECURE=false
SMTP_USER=your-email@gmail.com
SMTP_PASS=your-app-password

# Email Templates
EMAIL_FROM="osu! Challenge Tracker <noreply@yourapp.com>"
EMAIL_SUPPORT=support@yourapp.com

# =================================
# Monitoring & Logging
# =================================

# Logging
LOG_LEVEL=info
LOG_FILE=logs/app.log
LOG_MAX_SIZE=10485760
LOG_MAX_FILES=5

# Error Tracking (Sentry)
SENTRY_DSN=
SENTRY_ENVIRONMENT=development
SENTRY_TRACES_SAMPLE_RATE=0.1

# Performance Monitoring
ENABLE_PERFORMANCE_MONITORING=false
PERFORMANCE_SAMPLE_RATE=0.1

# Health Check
HEALTH_CHECK_INTERVAL=30000
HEALTH_CHECK_TIMEOUT=5000

# =================================
# Analytics & Tracking (Optional)
# =================================

# Google Analytics
NEXT_PUBLIC_GA_MEASUREMENT_ID=
GA_SECRET=

# Feature Flags
FEATURE_REALTIME_UPDATES=true
FEATURE_DARK_MODE=true
FEATURE_NOTIFICATIONS=false
FEATURE_ADMIN_PANEL=true

# =================================
# Development & Testing
# =================================

# Debug Settings
DEBUG_API_CALLS=false
DEBUG_AUTH=false
DEBUG_RATE_LIMITING=false

# Testing
TEST_DATABASE_URL=
TEST_OSU_CLIENT_ID=
TEST_OSU_CLIENT_SECRET=

# Mock Data
USE_MOCK_OSU_API=false
MOCK_DELAY_MS=100

# =================================
# Production Overrides
# =================================

# Security Headers
HSTS_MAX_AGE=31536000
CONTENT_SECURITY_POLICY="default-src 'self'; script-src 'self' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self' https:;"

# Performance
COMPRESSION_ENABLED=true
COMPRESSION_LEVEL=6

# Database
DATABASE_POOL_SIZE=10
DATABASE_STATEMENT_TIMEOUT=30000
DATABASE_IDLE_TIMEOUT=10000

# =================================
# Worker Configuration (If using background jobs)
# =================================

# Worker Settings
WORKER_CONCURRENCY=2
WORKER_MAX_MEMORY=512
WORKER_TIMEOUT=300000

# Job Queue
QUEUE_REDIS_URL=redis://localhost:6379/1
QUEUE_DEFAULT_JOB_OPTIONS={"removeOnComplete":50,"removeOnFail":100}

# Scheduled Jobs
CRON_UPDATE_SCORES="*/2 * * * *"
CRON_CLEANUP_SESSIONS="0 0 * * *"
CRON_BACKUP_DATA="0 2 * * *"

# =================================
# Backup Configuration
# =================================

# Backup Settings
BACKUP_ENABLED=false
BACKUP_PROVIDER=s3
BACKUP_BUCKET=your-backup-bucket
BACKUP_RETENTION_DAYS=30

# AWS S3 (if using for backups)
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_REGION=us-east-1

# =================================
# Notes
# =================================

# To get started:
# 1. Copy this file to .env.local
# 2. Fill in the required values (marked as required in documentation)
# 3. Generate secure secrets for JWT_SECRET and SESSION_SECRET
# 4. Create a Supabase project and fill in the database configuration
# 5. Register an osu! OAuth application and fill in the osu! API configuration
#
# Security Notes:
# - Never commit .env.local to version control
# - Use different secrets for each environment
# - Rotate secrets regularly in production
# - Keep environment variables secure and limit access
#
# For production deployment:
# - Set NODE_ENV=production
# - Use strong, unique secrets
# - Enable HTTPS and set appropriate security headers
# - Configure proper CORS origins
# - Set up monitoring and logging
# - Use environment-specific database credentials


================================================
FILE: frontend/Dockerfile
================================================
# Build stage
FROM node:18-alpine AS builder

# Set working directory
WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production

# Copy source code
COPY . .

# Build the Next.js application
RUN npm run build

# Production stage
FROM node:18-alpine AS runner

WORKDIR /app

# Copy necessary files from builder
COPY --from=builder /app/package*.json ./
COPY --from=builder /app/.next ./.next
COPY --from=builder /app/public ./public
COPY --from=builder /app/node_modules ./node_modules

# Create a non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001
USER nextjs

# Expose port
EXPOSE 3000

# Set environment to production
ENV NODE_ENV production

# Start the application
CMD ["npm", "start"]


================================================
FILE: frontend/middleware.js
================================================
import { NextResponse } from 'next/server';
import apiTracker from './lib/api-tracker';

export function middleware(request) {
  //const startTime = Date.now();
  //const { pathname, searchParams } = request.nextUrl;
  //const method = request.method;
  
  // Track middleware invocation for all routes
  //apiTracker.trackMiddleware(pathname);
  
  // Create response
  //const response = NextResponse.next();
  
  // Only track API routes for function invocations
  //if (pathname.startsWith('/api/')) {
  //  // Add headers to track the request
  //  response.headers.set('x-call-start', startTime.toString());
  //  response.headers.set('x-tracked-endpoint', pathname);
  //  response.headers.set('x-tracked-method', method);
  //  
    // Check current limit status and add warning headers
  //  const limitStatus = apiTracker.checkLimits();
  //  response.headers.set('x-api-limit-status', limitStatus);
    
  //  if (limitStatus === 'critical') {
  //    response.headers.set('x-api-limit-warning', 'CRITICAL: API usage above 95%');
  //  } else if (limitStatus === 'warning') {
  //    response.headers.set('x-api-limit-warning', 'WARNING: API usage above 85%');
  //  }
    
    // Add tracking completion hook
    // Note: This runs when the response is being sent
  //  const originalResponse = response;
    
    // Override the response to capture completion
  //  const trackedResponse = new Response(originalResponse.body, {
  //    status: originalResponse.status,
  //    statusText: originalResponse.statusText,
  //    headers: originalResponse.headers
  //  });
    
    // Track the function call completion
    // This is an approximation since middleware runs before the API handler
  //  setTimeout(() => {
  //    const duration = Date.now() - startTime;
  //    const success = trackedResponse.status < 400;
      
      // Estimate memory usage based on endpoint complexity
  //    let memoryEstimate = 128; // Base memory
  //    if (pathname.includes('admin')) memoryEstimate = 256;
  //    if (pathname.includes('challenge') || pathname.includes('scores')) memoryEstimate = 192;
      
      // Estimate response size from headers
  //    let responseSize = 0;
  //    const contentLength = trackedResponse.headers.get('content-length');
  //    if (contentLength) {
  //      responseSize = parseInt(contentLength, 10);
  //    } else {
        // Estimate based on endpoint type
  //      if (pathname.includes('stats') || pathname.includes('admin')) responseSize = 2048;
  //      else if (pathname.includes('scores')) responseSize = 1024;
  //      else responseSize = 512;
  //    }
      
  //    apiTracker.trackInternal(
  //      pathname, 
  //      method, 
  //      duration, 
  //      success, 
  //      memoryEstimate, 
  //      responseSize
  //    );
  //  }, 0);
    
  //  return NextResponse.next();
  //}
  
  return NextResponse.next();
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public files (public folder)
     */
    '/((?!_next/static|_next/image|favicon.ico|public/).*)',
  ],
};

// Enhanced API wrapper for more accurate tracking
export function withAPITracking(handler, options = {}) {
  return async (req, res) => {
    const startTime = Date.now();
    const endpoint = req.url || req.nextUrl?.pathname || 'unknown';
    const method = req.method || 'GET';
    const memoryMB = options.memoryMB || 128;
    
    // Get original response methods to intercept size
    const originalJson = res.json;
    const originalSend = res.send;
    const originalEnd = res.end;
    
    let responseSize = 0;
    let responseData = null;
    
    // Override response methods to capture size
    res.json = function(data) {
      responseData = data;
      responseSize = JSON.stringify(data).length;
      return originalJson.call(this, data);
    };
    
    res.send = function(data) {
      responseSize = typeof data === 'string' ? data.length : JSON.stringify(data).length;
      return originalSend.call(this, data);
    };
    
    res.end = function(data) {
      if (data && typeof data === 'string') {
        responseSize = data.length;
      }
      return originalEnd.call(this, data);
    };
    
    try {
      // Execute the original handler
      const result = await handler(req, res);
      
      // Track successful function call
      const duration = Date.now() - startTime;
      apiTracker.trackInternal(endpoint, method, duration, true, memoryMB, responseSize);
      
      return result;
    } catch (error) {
      // Track failed function call
      const duration = Date.now() - startTime;
      apiTracker.trackInternal(endpoint, method, duration, false, memoryMB, responseSize);
      
      throw error;
    }
  };
}

// Enhanced external API wrapper with better tracking
export function withExternalAPITracking(apiName) {
  return function(originalFetch) {
    return async function(url, options = {}) {
      const startTime = Date.now();
      const method = options.method || 'GET';
      const endpoint = typeof url === 'string' ? new URL(url).pathname : url.pathname;
      
      try {
        const response = await originalFetch(url, options);
        const duration = Date.now() - startTime;
        const success = response.ok;
        
        // Get response size
        let responseSize = 0;
        const contentLength = response.headers.get('content-length');
        if (contentLength) {
          responseSize = parseInt(contentLength, 10);
        }
        
        // Track the external API call
        apiTracker.trackExternal(apiName, endpoint, method, duration, success, responseSize);
        
        if (!success) {
          console.warn(`‚ùå External API ${apiName} failed: ${method} ${url} (${response.status})`);
        }
        
        return response;
      } catch (error) {
        const duration = Date.now() - startTime;
        apiTracker.trackExternal(apiName, endpoint, method, duration, false, 0);
        
        console.error(`üö® External API ${apiName} error: ${method} ${url}`, error);
        throw error;
      }
    };
  };
}

// Utility to track edge functions (call this from your edge functions)
export function trackEdgeFunction(functionName, executionUnits = 1) {
  apiTracker.trackEdgeFunction(functionName, executionUnits);
}

// Utility to track image optimizations (call this when serving optimized images)
export function trackImageOptimization(originalSize, optimizedSize) {
  apiTracker.trackImageOptimization(originalSize, optimizedSize);
}


================================================
FILE: frontend/next.config.js
================================================
/** @type {import('next').NextConfig} */
const securityHeaders = [
  {
    key: 'X-Content-Type-Options',
    value: 'nosniff'
  },
  {
    key: 'X-Frame-Options',
    value: 'DENY'
  },
  {
    key: 'X-XSS-Protection',
    value: '1; mode=block'
  }
];

const nextConfig = {
  reactStrictMode: true,
  images: {
    domains: ['a.ppy.sh', 'assets.ppy.sh'],
  },
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: securityHeaders,
      },
    ];
  },
};

module.exports = nextConfig;


================================================
FILE: frontend/package.json
================================================
{
    "name": "osu-challenge-tracker",
    "version": "2.0.0",
    "description": "Track osu! multiplayer challenges with automatic updates",
    "private": true,
    "scripts": {
        "dev": "next dev -H 0.0.0.0",
        "build": "next build",
        "start": "next start",
        "lint": "next lint"
    },
    "dependencies": {
        "@stripe/stripe-js": "^2.4.0",
        "@supabase/supabase-js": "^2.39.0",
        "autoprefixer": "^10.4.16",
        "canvas-confetti": "^1.9.2",
        "cheerio": "^1.1.2",
        "dotenv": "^17.2.3",
        "lucide-react": "^0.303.0",
        "micro": "^10.0.1",
        "next": "^14.2.29",
        "p-limit": "^6.2.0",
        "postcss": "^8.4.32",
        "punycode": "^2.3.1",
        "react": "18.2.0",
        "react-dom": "18.2.0",
        "react-hot-toast": "^2.4.1",
        "stripe": "^14.17.0",
        "swr": "^2.2.4",
        "tailwindcss": "^3.4.0",
        "text-to-svg": "^3.1.5"
    },
    "devDependencies": {
        "eslint": "^8.56.0",
        "eslint-config-next": "14.0.4"
    },
    "overrides": {
        "punycode": "^2.3.1",
        "whatwg-url": {
            "punycode": "^2.3.1"
        },
        "tough-cookie": {
            "punycode": "^2.3.1"
        }
    },
    "resolutions": {
        "punycode": "^2.3.1",
        "**/punycode": "^2.3.1"
    },
    "engines": {
        "node": ">=18.0.0"
    }
}



================================================
FILE: frontend/postcss.config.js
================================================
module.exports = {
  plugins: {
    'tailwindcss': {},
    'autoprefixer': {},
  },
}



================================================
FILE: frontend/tailwind.config.js
================================================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      fontFamily: {
        'sans': ['Inter', 'ui-sans-serif', 'system-ui', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'Helvetica Neue', 'Arial', 'Noto Sans', 'sans-serif'],
      },
      borderWidth: {
        '3': '3px',
      },
      colors: {
        // Pink shades for primary accent
        primary: {
          50: '#fdf2f8',
          100: '#fce7f3',
          200: '#fbcfe8',
          300: '#f9a8d4',
          400: '#f472b6',
          500: '#ec4899',
          600: '#db2777',
          700: '#be185d',
          800: '#9d174d',
          900: '#831843',
        },
        // Neutral grays for light theme
        neutral: {
          50: '#fafafa',
          100: '#f5f5f5',
          200: '#e5e5e5',
          300: '#d4d4d4',
          400: '#a3a3a3',
          500: '#737373',
          600: '#525252',
          700: '#404040',
          800: '#262626',
          900: '#171717',
        },
        // Keep purple for secondary elements
        purple: {
          400: '#a855f7',
          500: '#9333ea',
          600: '#7c3aed',
          700: '#6d28d9',
          900: '#4c1d95',
        },
      },
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
      },
      // Add backdrop blur and filter support
      backdropBlur: {
        xs: '2px',
        sm: '4px',
        DEFAULT: '8px',
        md: '12px',
        lg: '16px',
        xl: '24px',
        '2xl': '40px',
        '3xl': '64px',
      },
    },
  },
  // Enable backdrop filter utilities
  variants: {
    extend: {
      backdropFilter: ['responsive'],
    },
  },
  plugins: [],
}


================================================
FILE: frontend/vercel.json
================================================
{
  "redirects": [
    {
      "source": "/",
      "destination": "https://challengersnexus.com/",
      "permanent": true,
      "has": [
        {
          "type": "host",
          "value": "osu-challenge-tracker.vercel.app"
        }
      ]
    },
    {
      "source": "/:path*",
      "destination": "https://challengersnexus.com/:path*",
      "permanent": true,
      "has": [
        {
          "type": "host",
          "value": "osu-challenge-tracker.vercel.app"
        }
      ]
    }
  ],
  "headers": [
    {
      "source": "/_next/static/(.*)",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    },
    {
      "source": "/static/(.*)",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    },
    {
      "source": "/(.*)\\.ico",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    },
    {
      "source": "/(.*)\\.png",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    },
    {
      "source": "/(.*)\\.jpg",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    },
    {
      "source": "/(.*)\\.jpeg",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    },
    {
      "source": "/(.*)\\.gif",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    },
    {
      "source": "/(.*)\\.webp",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    },
    {
      "source": "/(.*)\\.svg",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    },
    {
      "source": "/(.*)\\.woff",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    },
    {
      "source": "/(.*)\\.woff2",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    },
    {
      "source": "/(.*)\\.ttf",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    },
    {
      "source": "/(.*)\\.eot",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    },
    {
      "source": "/(.*)\\.otf",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    },
    {
      "source": "/(.*)\\.js",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    },
    {
      "source": "/(.*)\\.css",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    },
    {
      "source": "/(.*)\\.json",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    },
    {
      "source": "/favicon.ico",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=86400"
        }
      ]
    },
    {
      "source": "/robots.txt",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=3600"
        }
      ]
    },
    {
      "source": "/sitemap.xml",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=3600"
        }
      ]
    },
    {
      "source": "/manifest.json",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=86400"
        }
      ]
    }
  ]
}


================================================
FILE: frontend/components/AuthDebug.js
================================================
import { useState, useEffect } from 'react';
import { supabase } from '../lib/supabase';

export default function AuthDebug() {
  const [debugInfo, setDebugInfo] = useState('Loading...');
  const [cookies, setCookies] = useState('');
  const [userFromDB, setUserFromDB] = useState(null);

  useEffect(() => {
    testAuth();
  }, []);

  const testAuth = async () => {
    try {
      // Step 1: Check cookies
      const allCookies = document.cookie;
      setCookies(allCookies);
      console.log('üç™ All cookies:', allCookies);

      // Step 2: Find session cookie
      const cookies = document.cookie.split('; ');
      const sessionCookie = cookies.find(c => c.startsWith('osu_session='));
      
      if (!sessionCookie) {
        setDebugInfo('‚ùå No osu_session cookie found');
        return;
      }

      const userId = sessionCookie.split('=')[1];
      console.log('üÜî User ID from cookie:', userId);
      setDebugInfo(`üÜî User ID: ${userId}`);

      // Step 3: Try to fetch user from database
      console.log('üóÉÔ∏è Fetching user from database...');
      const { data: user, error } = await supabase
        .from('users')
        .select('*')
        .eq('id', parseInt(userId))
        .single();

      console.log('üë§ User from DB:', user);
      console.log('‚ùå DB Error:', error);

      if (error) {
        setDebugInfo(`‚ùå DB Error: ${error.message}`);
        return;
      }

      if (user) {
        setUserFromDB(user);
        setDebugInfo(`‚úÖ Found user: ${user.username} (Admin: ${user.admin})`);
      } else {
        setDebugInfo('‚ùå User not found in database');
      }

    } catch (error) {
      console.error('üö® Test error:', error);
      setDebugInfo(`üö® Error: ${error.message}`);
    }
  };

  return (
    <div className="fixed bottom-4 right-4 bg-black text-white p-4 rounded-lg max-w-sm text-xs z-50">
      <h3 className="font-bold mb-2">Auth Debug</h3>
      <div className="space-y-1">
        <div><strong>Status:</strong> {debugInfo}</div>
        <div><strong>Cookies:</strong> {cookies || 'None'}</div>
        {userFromDB && (
          <div className="mt-2 p-2 bg-green-900 rounded">
            <strong>User Found:</strong><br />
            ID: {userFromDB.id}<br />
            Username: {userFromDB.username}<br />
            Admin: {userFromDB.admin ? 'Yes' : 'No'}
          </div>
        )}
        <button 
          onClick={testAuth}
          className="mt-2 px-2 py-1 bg-blue-600 rounded hover:bg-blue-700"
        >
          Test Again
        </button>
      </div>
    </div>
  );
}


================================================
FILE: frontend/components/ChallengeCard.js
================================================
import { Calendar, Users, Music, Star } from 'lucide-react';

export default function ChallengeCard({ 
  challenge, 
  size = 'medium', 
  challengeType = 'monthly', // 'weekly', 'monthly', or 'custom'
  showSeasonBadge = false 
}) {
  const formatDate = (dateString) => {
    if (!dateString) return 'N/A';
    return new Date(dateString).toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
    });
  };

  const getTimeRemaining = (endDate) => {
    if (!endDate) return null;
    
    // Force UTC interpretation by adding 'Z' if not present
    const utcDateString = endDate.includes('Z') || endDate.includes('+') || endDate.includes('T') && endDate.length > 19 
      ? endDate 
      : endDate + 'Z';
    
    const end = new Date(utcDateString);
    const now = new Date();
    
    if (isNaN(end.getTime())) return null;
    
    const totalMs = end - now;
    if (totalMs <= 0) return { expired: true };
    
    const days = Math.floor(totalMs / (1000 * 60 * 60 * 24));
    const hours = Math.floor((totalMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((totalMs % (1000 * 60 * 60)) / (1000 * 60));
    
    if (days > 0) {
      return { days, label: days === 1 ? 'Day left' : 'Days left' };
    } else if (hours > 0) {
      return { hours, label: hours === 1 ? 'Hour left' : 'Hours left' };
    } else if (minutes > 0) {
      return { minutes, label: minutes === 1 ? 'Minute left' : 'Minutes left' };
    } else {
      return { expired: true };
    }
  };

  const getDifficultyClass = (difficulty) => {
  // Use osu!'s difficulty ranges with glassmorphism styling
  if (difficulty < 1.25) return 'difficulty-star-easy';
  if (difficulty < 2.0) return 'difficulty-star-easy-normal';
  if (difficulty < 2.5) return 'difficulty-star-normal';
  if (difficulty < 3.3) return 'difficulty-star-normal-hard';
  if (difficulty < 4.2) return 'difficulty-star-hard';
  if (difficulty < 4.9) return 'difficulty-star-hard-insane';
  if (difficulty < 5.8) return 'difficulty-star-insane';
  if (difficulty < 6.7) return 'difficulty-star-insane-expert';
  if (difficulty < 7.7) return 'difficulty-star-expert';
  return 'difficulty-star-expert-plus';
};

  const timeRemaining = getTimeRemaining(challenge.end_date);
  
  // Display name: custom_name takes priority over name
  const displayName = challenge.custom_name || challenge.name;

  // Get background image and map info
  const backgroundImage = challenge.playlists?.[0]?.beatmap_cover_url;
  const mapInfo = challenge.playlists?.[0];

  // Get badge class based on challenge type
  const getBadgeClass = () => {
    switch(challengeType) {
      case 'weekly':
        return 'challenge-badge-weekly';
      case 'monthly':
        return 'challenge-badge-monthly';
      case 'custom':
        return 'challenge-badge-custom';
      default:
        return 'challenge-badge-monthly';
    }
  };

  // Size configurations
  const sizeConfig = {
    small: {
      cardClass: 'h-48',
      padding: 'p-2 sm:p-3',
      textSize: 'text-xs',
      titleSize: 'text-sm',
      iconSize: 'w-2.5 h-2.5 sm:w-3 sm:h-3',
      numberSize: 'text-sm sm:text-base',
      badgeScale: 'scale-90',
      iconPadding: 'p-1 sm:p-1.5'
    },
    medium: {
      cardClass: 'h-56 sm:h-64',
      padding: 'p-3 sm:p-4',
      textSize: 'text-xs sm:text-sm',
      titleSize: 'text-base sm:text-lg',
      iconSize: 'w-3 h-3 sm:w-4 sm:h-4',
      numberSize: 'text-base sm:text-lg md:text-xl',
      badgeScale: '',
      iconPadding: 'p-1 sm:p-1.5 md:p-2'
    },
    large: {
      cardClass: 'h-72 sm:h-80',
      padding: 'p-4 sm:p-5 md:p-6',
      textSize: 'text-sm sm:text-base',
      titleSize: 'text-lg sm:text-xl',
      iconSize: 'w-4 h-4 sm:w-5 sm:h-5',
      numberSize: 'text-lg sm:text-xl md:text-2xl',
      badgeScale: 'sm:scale-110',
      iconPadding: 'p-1.5 sm:p-2 md:p-2.5'
    }
  };

  const config = sizeConfig[size];

  return (
    <div className={`group relative overflow-hidden glass-3 rounded-xl sm:rounded-2xl ${config.cardClass} transition-shadow duration-300 hover:shadow-2xl cursor-pointer`}>
      
      {/* Top 80% - Background Image Section */}
      <div className="relative h-[80%] overflow-hidden">
        {backgroundImage ? (
        <div 
          className="absolute inset-0"
          style={{
            backgroundImage: `url(${backgroundImage})`,
            backgroundSize: 'cover',
            backgroundPosition: 'center',
            filter: 'brightness(0.8)'
          }}
        >
          {/* Enhanced gradient overlay with side shadows */}
          <div className="absolute inset-0 bg-gradient-to-t from-black/70 via-transparent to-transparent" />
          {/* Left shadow */}
          <div className="absolute inset-y-0 left-0 w-12 bg-gradient-to-r from-black/50 to-transparent" />
          {/* Right shadow */}
          <div className="absolute inset-y-0 right-0 w-12 bg-gradient-to-l from-black/50 to-transparent" />
          {/* Bottom shadow (enhanced) */}
          <div className="absolute bottom-0 left-0 right-0 h-24 bg-gradient-to-t from-black/80 to-transparent" />
        </div>
      ) : (
        <div className="absolute inset-0 bg-gradient-to-br from-purple-600/30 to-pink-600/30" />
      )}

        {/* Challenge Type Badge - Top Right */}
        <div className={`absolute top-3 right-3 z-20 ${config.badgeScale}`}>
          <span className={getBadgeClass()}>
            {challengeType.charAt(0).toUpperCase() + challengeType.slice(1)}
          </span>
        </div>

        {/* Challenge Name on Image */}
        <div className="absolute bottom-0 left-0 right-0 p-4 z-10">
          {/* Difficulty Star Rating - Above challenge name */}
          {mapInfo?.beatmap_difficulty && (
            <div className="mb-2">
              <div className={`inline-flex items-center gap-1 px-2 py-0.5 rounded-full ${config.textSize} font-bold text-white text-shadow-adaptive-sm ${getDifficultyClass(mapInfo.beatmap_difficulty)}`}>
                <Star className="w-3 h-3 fill-current" />
                <span>{mapInfo.beatmap_difficulty.toFixed(2)}</span>
              </div>
            </div>
          )}
          
          <h3 className={`${config.titleSize} font-bold text-white mb-1 line-clamp-2 text-shadow-adaptive-lg`}>
            {displayName}
          </h3>
          
          {/* Map Info */}
          {mapInfo && (
            <div className="space-y-0.5">
              <div className="flex items-center gap-3 sm:gap-5 md:gap-8 text-white/80 flex-wrap">
                <span className={`${config.textSize} font-semibold text-white text-shadow-adaptive truncate`}>
                  {mapInfo.beatmap_title}
                </span>
                <span className={`${config.textSize} text-shadow-adaptive-sm truncate`}>
                  by {mapInfo.beatmap_artist}
                </span>
                {mapInfo.beatmap_version && (
                  <span className={`${config.textSize} text-white/70 text-shadow-adaptive-sm truncate`}>
                    [{mapInfo.beatmap_version}]
                  </span>
                )}
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Bottom 20% - Stats Bar */}
      <div className="h-[20%] bg-black/40 backdrop-blur-sm border-t border-white/10">
        <div className={`h-full flex items-center ${config.padding}`}>
          <div className="flex gap-6 lg:gap-20">
            {/* Players - Red */}
            <div className="flex items-center gap-3">
              <div className={`${config.iconPadding} icon-gradient-red rounded-lg icon-container-red`}>
                <Users className={`${config.iconSize} text-white icon-shadow-adaptive-sm`} />
              </div>
              <div className="lg:flex lg:items-center lg:gap-1.5">
                <p className={`${config.numberSize} font-bold text-white leading-tight text-shadow-adaptive`}>
                  {challenge.participant_count || 0}
                </p>
                <p className={`${config.textSize} lg:text-2xl text-white/70 font-bold leading-tight text-shadow-adaptive-sm`}>
                  Players
                </p>
              </div>
            </div>

            {/* Maps - Dark Purple */}
            <div className="flex items-center gap-3">
              <div className={`${config.iconPadding} icon-gradient-dark-purple rounded-lg icon-container-dark-purple`}>
                <Music className={`${config.iconSize} text-white icon-shadow-adaptive-sm`} />
              </div>
              <div className="lg:flex lg:items-center lg:gap-1.5">
                <p className={`${config.numberSize} font-bold text-white leading-tight text-shadow-adaptive`}>
                  {challenge.playlists?.length || 0}
                </p>
                <p className={`${config.textSize} lg:text-2xl text-white/70 font-bold leading-tight text-shadow-adaptive-sm`}>
                  {challenge.playlists?.length === 1 ? 'Map' : 'Maps'}
                </p>
              </div>
            </div>

            {/* Time - Green */}
            <div className="flex items-center gap-3">
              <div className={`${config.iconPadding} icon-gradient-green rounded-lg icon-container-green`}>
                <Calendar className={`${config.iconSize} text-white icon-shadow-adaptive-sm`} />
              </div>
              <div className="lg:flex lg:items-center lg:gap-1.5">
                {timeRemaining && !timeRemaining.expired ? (
                  <>
                    <p className={`${config.numberSize} font-bold text-white leading-tight text-shadow-adaptive`}>
                      {timeRemaining.days || timeRemaining.hours || timeRemaining.minutes}
                    </p>
                    <p className={`${config.textSize} lg:text-2xl text-white/70 font-bold leading-tight text-shadow-adaptive-sm`}>
                      {timeRemaining.label}
                    </p>
                  </>
                ) : (
                  <>
                    <p className={`${config.numberSize} font-bold ${timeRemaining?.expired ? 'text-red-400' : 'text-green-400'} leading-tight text-shadow-adaptive`}>
                      {timeRemaining?.expired ? 'Ended' : 'Active'}
                    </p>
                    <p className={`${config.textSize} lg:text-2xl text-white/70 font-bold leading-tight text-shadow-adaptive-sm`}>
                      Status
                    </p>
                  </>
                )}
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}


================================================
FILE: frontend/components/ChristmasSnowfall.js
================================================
// frontend/components/ChristmasSnowfall.js
import { useMemo } from 'react';

export default function ChristmasSnowfall() {
  // Memoize snowflakes so they don't regenerate on re-renders
  const snowflakes = useMemo(() => 
    Array.from({ length: 35 }, (_, i) => ({
      id: i,
      left: Math.random() * 100,
      animationDuration: 10 + Math.random() * 20, // 10-30s
      animationDelay: Math.random() * -20, // Staggered start
      size: 2 + Math.random() * 3, // 2-5px
      opacity: 0.3 + Math.random() * 0.5, // 0.3-0.8
    }))
  , []); // Empty dependency array = only generate once

  return (
    <>
      <div className="fixed inset-0 pointer-events-none z-50 overflow-hidden">
        {snowflakes.map((flake) => (
          <div
            key={flake.id}
            className="snowflake absolute"
            style={{
              left: `${flake.left}%`,
              width: `${flake.size}px`,
              height: `${flake.size}px`,
              opacity: flake.opacity,
              animationDuration: `${flake.animationDuration}s`,
              animationDelay: `${flake.animationDelay}s`,
            }}
          />
        ))}
      </div>

      <style jsx>{`
        .snowflake {
          background: white;
          border-radius: 50%;
          filter: blur(1px);
          animation: fall linear infinite;
        }

        @keyframes fall {
          0% {
            transform: translateY(-10vh) translateX(0);
          }
          100% {
            transform: translateY(110vh) translateX(20px);
          }
        }

        /* Add slight horizontal drift */
        .snowflake:nth-child(3n) {
          animation-name: fall-drift-left;
        }

        .snowflake:nth-child(3n+1) {
          animation-name: fall-drift-right;
        }

        @keyframes fall-drift-left {
          0% {
            transform: translateY(-10vh) translateX(0);
          }
          100% {
            transform: translateY(110vh) translateX(-30px);
          }
        }

        @keyframes fall-drift-right {
          0% {
            transform: translateY(-10vh) translateX(0);
          }
          100% {
            transform: translateY(110vh) translateX(30px);
          }
        }
      `}</style>
    </>
  );
}


================================================
FILE: frontend/components/ChristmasTree.js
================================================
import { useState } from 'react';

export default function ChristmasTree({ position = 'fixed' }) {
  const [isShaking, setIsShaking] = useState(false);
  const [clickCount, setClickCount] = useState(0);

  const playAudio = () => {
    const audioFiles = [
        '/christmas/audio_Si5PjM5D.mp3',
        '/christmas/audio_PU4zkIzK.mp3',
        '/christmas/audio_ApBIZqNs.mp3',
        '/christmas/audio_YIePuI14.mp3',
        '/christmas/audio_qUoOspeX.mp3',
        '/christmas/audio_fmdV2nYe.mp3',
        '/christmas/audio_eQwLDsqb.mp3',
        '/christmas/audio_KB8w61qk.mp3'
    ];
    
    // Pick a random audio file
    const randomAudio = audioFiles[Math.floor(Math.random() * audioFiles.length)];
    
    // Random playback speed between 0.5x and 2x
    const randomSpeed = 0.5 + Math.random() * 1.5;
    
    const audio = new Audio(randomAudio);
    audio.playbackRate = randomSpeed;
    audio.play();

    // Shake animation
    setIsShaking(true);
    setTimeout(() => setIsShaking(false), 500);

    // Track clicks for easter egg
    setClickCount(prev => prev + 1);
  };

  return (
    <>
      <div 
        className={`fixed bottom-8 right-8 z-50 cursor-pointer transition-transform hover:scale-110 ${
          isShaking ? 'animate-shake' : ''
        } ${clickCount > 10 ? 'animate-spin-slow' : ''}`}
        onClick={playAudio}
      >
        <svg 
          width="100" 
          height="120" 
          viewBox="0 0 100 120" 
          className="drop-shadow-2xl"
        >
          {/* Tree trunk */}
          <rect x="42" y="95" width="16" height="15" rx="2" fill="#5D4037" />
          
          {/* Tree layers - Bottom Tier */}
          <path d="M20 95 L50 65 L80 95 Z" fill="#1B5E20" />
          {/* Tree layers - Middle Tier */}
          <path d="M25 75 L50 45 L75 75 Z" fill="#2E7D32" />
          {/* Tree layers - Top Tier */}
          <path d="M32 55 L50 25 L68 55 Z" fill="#388E3C" />
          
          {/* Ornaments */}
          <circle cx="35" cy="85" r="3.5" fill="#ef4444" className="ornament-pulse" />
          <circle cx="65" cy="85" r="3.5" fill="#eab308" className="ornament-pulse" style={{animationDelay: '0.3s'}} />
          <circle cx="50" cy="70" r="3.5" fill="#3b82f6" className="ornament-pulse" style={{animationDelay: '0.6s'}} />
          <circle cx="40" cy="55" r="3.5" fill="#eab308" className="ornament-pulse" style={{animationDelay: '0.9s'}} />
          <circle cx="60" cy="55" r="3.5" fill="#ef4444" className="ornament-pulse" style={{animationDelay: '1.2s'}} />
          
          {/* Star on top */}
          <polygon 
            points="50,15 53,23 61,23 55,28 57,36 50,31 43,36 45,28 39,23 47,23" 
            fill="#FFD600"
            className="star-twinkle"
          />
          
          {/* Glow effect */}
          <circle cx="50" cy="25" r="15" fill="url(#starGlow)" opacity="0.4" className="star-glow" />
          
          <defs>
            <radialGradient id="starGlow">
              <stop offset="0%" stopColor="#ffd700" stopOpacity="0.8" />
              <stop offset="100%" stopColor="#ffd700" stopOpacity="0" />
            </radialGradient>
          </defs>
        </svg>
      </div>

      <style jsx>{`
        @keyframes pulse-ornament {
          0%, 100% { opacity: 1; transform: scale(1); }
          50% { opacity: 0.7; transform: scale(1.2); }
        }

        .star-twinkle { animation: twinkle-star 1.5s ease-in-out infinite; transform-origin: center; }
        @keyframes twinkle-star {
          0%, 100% { filter: drop-shadow(0 0 2px #ffd700); opacity: 1; }
          50% { filter: drop-shadow(0 0 10px #ffd700); opacity: 0.8; }
        }

        .star-glow { animation: pulse-glow 2s ease-in-out infinite; }
        @keyframes pulse-glow {
          0%, 100% { opacity: 0.2; }
          50% { opacity: 0.5; }
        }

        .animate-shake { animation: shake 0.5s ease-in-out; }
        @keyframes shake {
          0%, 100% { transform: rotate(0deg); }
          25% { transform: rotate(-8deg); }
          75% { transform: rotate(8deg); }
        }

        .animate-spin-slow { animation: spin-slow 4s linear infinite; }
        @keyframes spin-slow {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
      `}</style>
    </>
  );
}


================================================
FILE: frontend/components/CombinedLeaderboard.js
================================================
import { Trophy, Award, Target, Activity, Crown, Star, Users } from 'lucide-react';
import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';

// Utility function to sanitize user input
const sanitizeText = (text) => {
  if (typeof text !== 'string') return '';
  return text.replace(/[<>&"']/g, (match) => {
    const escapeMap = {
      '<': '&lt;',
      '>': '&gt;',
      '&': '&amp;',
      '"': '&quot;',
      "'": '&#x27;'
    };
    return escapeMap[match];
  });
};

// Helper function to get country flag URL from flagcdn.com
const getCountryFlagUrl = (countryCode) => {
  if (!countryCode || countryCode.length !== 2) return null;
  return `https://flagcdn.com/w20/${countryCode.toLowerCase()}.png`;
};

export default function CombinedLeaderboard({ leaderboard = [], loading = false, totalMaps = 0 }) {
  const [sortBy, setSortBy] = useState('total_score');
  const [sortOrder, setSortOrder] = useState('desc');
  const [showMobileView, setShowMobileView] = useState(false);
  const router = useRouter();

  // Check if mobile view should be used
  useEffect(() => {
    const checkMobile = () => {
      setShowMobileView(window.innerWidth < 768);
    };
    
    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  if (loading) {
    return (
      <div className="text-center py-8 sm:py-12">
        <div className="animate-spin rounded-full h-6 w-6 sm:h-8 sm:w-8 border-b-2 border-purple-400 mx-auto mb-3 sm:mb-4"></div>
        <span className="text-white/70 text-shadow-adaptive-sm text-sm sm:text-base">Loading combined leaderboard...</span>
      </div>
    );
  }

  if (!Array.isArray(leaderboard) || leaderboard.length === 0) {
    return (
      <div className="text-center py-8 sm:py-12">
        <Trophy className="w-10 h-10 sm:w-12 sm:h-12 mx-auto mb-3 sm:mb-4 text-white/30 icon-shadow-adaptive" />
        <p className="text-white/70 text-shadow-adaptive-sm text-sm sm:text-base">No combined scores available yet.</p>
      </div>
    );
  }

  const formatScore = (score) => {
    if (typeof score !== 'number' || isNaN(score)) return '0';
    if (score >= 1000000) return (score / 1000000).toFixed(1) + 'M';
    if (score >= 1000) return (score / 1000).toFixed(1) + 'K';
    return score.toLocaleString();
  };

  const formatAccuracy = (accuracy) => {
    if (typeof accuracy !== 'number' || isNaN(accuracy)) return '0.00';
    return Math.max(0, Math.min(100, accuracy)).toFixed(2);
  };

  const formatCombo = (combo) => {
    if (typeof combo !== 'number' || isNaN(combo)) return '0';
    return Math.max(0, combo);
  };

  const handleSort = (column) => {
    if (sortBy === column) {
      setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');
    } else {
      setSortBy(column);
      setSortOrder(column === 'player' ? 'asc' : 'desc');
    }
  };

  // Handle clicking on a username to go to their profile
  const handleUsernameClick = (player) => {
    if (!player || !player.user_id) {
      console.warn('No user ID found for player:', player);
      return;
    }
    
    router.push(`/profile/${player.user_id}`);
  };

  // Sort leaderboard based on current sort settings
  const sortedLeaderboard = [...leaderboard].sort((a, b) => {
    let aVal, bVal;
    
    switch (sortBy) {
      case 'total_score':
        aVal = a.total_score || 0;
        bVal = b.total_score || 0;
        break;
      case 'average_accuracy':
        aVal = a.average_accuracy || 0;
        bVal = b.average_accuracy || 0;
        break;
      case 'best_combo':
        aVal = a.best_combo || 0;
        bVal = b.best_combo || 0;
        break;
      case 'maps_played':
        aVal = a.maps_played || 0;
        bVal = b.maps_played || 0;
        break;
      case 'player':
        aVal = (a.username || '').toLowerCase();
        bVal = (b.username || '').toLowerCase();
        break;
      default:
        aVal = a.total_score || 0;
        bVal = b.total_score || 0;
    }
    
    if (sortOrder === 'asc') {
      return aVal > bVal ? 1 : -1;
    } else {
      return aVal < bVal ? 1 : -1;
    }
  });

  const SortButton = ({ column, children, align = 'left' }) => (
    <button
      onClick={() => handleSort(column)}
      className={`flex items-center gap-1 hover:text-purple-300 transition-colors font-medium w-full text-shadow-adaptive-sm ${
        align === 'right' ? 'justify-end' : 
        align === 'center' ? 'justify-center' : 
        'justify-start'
      }`}
      aria-label={`Sort by ${column}`}
    >
      {children}
      {sortBy === column && (
        <span className="text-xs text-purple-300">
          {sortOrder === 'asc' ? '‚Üë' : '‚Üì'}
        </span>
      )}
    </button>
  );

  const getAccuracyGradient = (accuracy) => {
    if (accuracy >= 98) return 'from-pink-500 to-purple-500';
    if (accuracy >= 95) return 'from-green-500 to-emerald-500';
    if (accuracy >= 90) return 'from-cyan-500 to-blue-500';
    if (accuracy >= 85) return 'from-yellow-500 to-orange-500';
    return 'from-pink-500 to-red-500';
  };

  const getAccuracyBorder = (accuracy) => {
    if (accuracy >= 98) return 'acc-badge-purple';
    if (accuracy >= 95) return 'acc-badge-green';
    if (accuracy >= 90) return 'acc-badge-blue';
    if (accuracy >= 85) return 'acc-badge-yellow';
    return 'acc-badge-red';
  };

  const getRankGradient = (rank) => {
    if (rank === 1) return 'from-blue-400 to-blue-600';      // 7‚òÖ
    if (rank === 2) return 'from-purple-400 to-purple-600';  // 6‚òÖ
    if (rank === 3) return 'from-red-400 to-red-600';        // 5‚òÖ
    if (rank <= 10) return 'from-orange-400 to-red-500';
    return 'from-gray-400 to-gray-600';
  };

  const getParticipationGradient = (mapsPlayed) => {
    const percentage = (mapsPlayed / totalMaps) * 100;
    if (percentage === 100) return 'from-pink-500 to-purple-500';
    if (percentage >= 80) return 'from-green-500 to-emerald-500';
    if (percentage >= 60) return 'from-cyan-500 to-blue-500';
    if (percentage >= 40) return 'from-yellow-500 to-orange-500';
    return 'from-pink-500 to-red-500';
  };

  const getParticipationBorder = (mapsPlayed) => {
    const percentage = (mapsPlayed / totalMaps) * 100;
    if (percentage === 100) return 'acc-badge-purple';
    if (percentage >= 80) return 'acc-badge-green';
    if (percentage >= 60) return 'acc-badge-blue';
    if (percentage >= 40) return 'acc-badge-yellow';
    return 'acc-badge-red';
  };

  // Mobile Card View
  if (showMobileView) {
    return (
      <div className="space-y-3 sm:space-y-4">
        {/* Top 3 Podium Cards for Mobile */}
        {sortedLeaderboard.slice(0, 3).length >= 3 && (
          <div className="mb-4 sm:mb-6">
            <h3 className="text-base sm:text-lg font-bold text-white/90 mb-3 sm:mb-4 text-center text-shadow-adaptive flex items-center justify-center gap-2">
              <Crown className="w-4 h-4 sm:w-5 sm:h-5 text-yellow-400 icon-shadow-adaptive" />
              Top 3 Winners
            </h3>
            <div className="grid grid-cols-1 gap-2 sm:gap-3">
              {sortedLeaderboard.slice(0, 3).map((player, index) => {
                const rank = index + 1;
                const username = sanitizeText(player.username || 'Unknown');
                const country = sanitizeText(player.country || '');
                const bgGradient = rank === 1 ? 'podium-bg-blue' : rank === 2 ? 'podium-bg-purple' : 'podium-bg-red';
                const borderClass = rank === 1 ? 'podium-border-blue' : rank === 2 ? 'podium-border-purple' : 'podium-border-red';
                
                return (
                  <div 
                    key={player.user_id || index}
                    className={`${bgGradient} ${borderClass} rounded-xl sm:rounded-2xl p-3 sm:p-4 transform hover:scale-[1.02] transition-all`}
                  >
                    <div className="flex items-center gap-3 sm:gap-4">
                      {/* Rank Badge */}
                      <div className={`w-10 h-10 sm:w-12 sm:h-12 rounded-lg sm:rounded-xl bg-gradient-to-b ${getRankGradient(rank)} flex items-center justify-center shadow-lg flex-shrink-0`}>
                        <span className="text-white font-black text-xs sm:text-sm text-shadow-adaptive">
                          #{rank}
                        </span>
                      </div>
                      
                      {/* Player Info */}
                      <div className="flex-1 min-w-0">
                        <div className="flex items-center gap-2 mb-1 sm:mb-2">
                          {player.avatar_url && (
                            <img 
                              src={player.avatar_url} 
                              alt={`${username}'s avatar`}
                              className="w-6 h-6 sm:w-8 sm:h-8 rounded-full avatar-border flex-shrink-0"
                              onError={(e) => { e.target.style.display = 'none'; }}
                            />
                          )}
                          <button 
                            className="font-bold text-white hover:text-white/80 transition-colors text-shadow-adaptive truncate text-left text-sm sm:text-base" 
                            onClick={() => handleUsernameClick(player)}
                          >
                            {username}
                          </button>
                          {country && getCountryFlagUrl(country) && (
                            <img 
                              src={getCountryFlagUrl(country)} 
                              alt={`${country} flag`}
                              className="w-4 h-3 sm:w-5 sm:h-3 object-cover rounded-sm shadow-sm flex-shrink-0"
                              onError={(e) => { e.target.style.display = 'none'; }}
                            />
                          )}
                          {rank === 1 && (
                            <Crown className="w-3 h-3 sm:w-4 sm:h-4 text-yellow-300 icon-shadow-adaptive" />
                          )}
                        </div>
                        
                        {/* Stats Grid */}
                        <div className="grid grid-cols-2 gap-2 sm:gap-3 text-xs sm:text-sm">
                          <div>
                            <span className="text-white/80 text-shadow-adaptive-sm">Total Score:</span>
                            <div className="font-mono font-bold text-white text-glow-blue text-shadow-adaptive">
                              {formatScore(player.total_score)}
                            </div>
                          </div>
                          <div>
                            <span className="text-white/80 text-shadow-adaptive-sm">Avg Accuracy:</span>
                            <div className={`inline-flex px-1.5 py-0.5 sm:px-2 sm:py-1 bg-gradient-to-b ${getAccuracyGradient(player.average_accuracy)} ${getAccuracyBorder(player.average_accuracy)} text-white rounded-full font-bold text-xs shadow-md mt-0.5 sm:mt-1`}>
                              {formatAccuracy(player.average_accuracy)}%
                            </div>
                          </div>
                          <div>
                            <span className="text-white/80 text-shadow-adaptive-sm">Best Combo:</span>
                            <div className="font-mono text-white font-bold text-glow-green text-shadow-adaptive">
                              {formatCombo(player.best_combo)}x
                            </div>
                          </div>
                          <div>
                            <span className="text-white/80 text-shadow-adaptive-sm">Maps Played:</span>
                            <div className={`inline-flex px-1.5 py-0.5 sm:px-2 sm:py-1 bg-gradient-to-b ${getParticipationGradient(player.maps_played)} ${getParticipationBorder(player.maps_played)} text-white rounded-full font-bold text-xs shadow-md mt-0.5 sm:mt-1`}>
                              {player.maps_played}/{totalMaps}
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        )}

        {/* Remaining Players */}
        <div className="space-y-2 sm:space-y-3">
          {sortedLeaderboard.slice(3).map((player, index) => {
            const rank = index + 4;
            const username = sanitizeText(player.username || 'Unknown');
            const country = sanitizeText(player.country || '');
            
            return (
              <div 
                key={player.user_id || index}
                className="p-3 sm:p-4 transition-all rounded-lg sm:rounded-xl border border-white/10 hover:bg-white/5"
              >
                <div className="flex items-start gap-3">
                  {/* Rank Badge */}
                  <div className="w-8 h-8 sm:w-10 sm:h-10 rounded-lg sm:rounded-xl glass-2 flex items-center justify-center shadow-md flex-shrink-0">
                    <span className="text-white/90 font-bold text-xs sm:text-sm text-shadow-adaptive">
                      #{rank}
                    </span>
                  </div>
                  
                  {/* Player Info */}
                  <div className="flex-1 min-w-0">
                    <div className="flex items-center gap-2 mb-1 sm:mb-2">
                      {player.avatar_url && (
                        <img 
                          src={player.avatar_url} 
                          alt={`${username}'s avatar`}
                          className="w-6 h-6 sm:w-8 sm:h-8 rounded-full avatar-border flex-shrink-0"
                          onError={(e) => { e.target.style.display = 'none'; }}
                        />
                      )}
                      <button 
                        className="font-bold text-white hover:text-purple-300 transition-colors text-shadow-adaptive truncate text-left text-sm" 
                        onClick={() => handleUsernameClick(player)}
                      >
                        {username}
                      </button>
                      {country && getCountryFlagUrl(country) && (
                        <img 
                          src={getCountryFlagUrl(country)} 
                          alt={`${country} flag`}
                          className="w-4 h-3 sm:w-5 sm:h-3 object-cover rounded-sm shadow-sm flex-shrink-0"
                          onError={(e) => { e.target.style.display = 'none'; }}
                        />
                      )}
                    </div>
                    
                    {/* Stats Grid */}
                    <div className="grid grid-cols-2 gap-2 sm:gap-3 text-xs">
                      <div>
                        <span className="text-white/70 text-shadow-adaptive-sm">Score:</span>
                        <div className="font-mono font-bold text-white text-shadow-adaptive">
                          {formatScore(player.total_score)}
                        </div>
                      </div>
                      <div>
                        <span className="text-white/70 text-shadow-adaptive-sm">Accuracy:</span>
                        <div className={`inline-flex px-1.5 py-0.5 sm:px-2 sm:py-1 bg-gradient-to-b ${getAccuracyGradient(player.average_accuracy)} ${getAccuracyBorder(player.average_accuracy)} text-white rounded-full font-bold text-xs shadow-md mt-0.5`}>
                          {formatAccuracy(player.average_accuracy)}%
                        </div>
                      </div>
                      <div>
                        <span className="text-white/70 text-shadow-adaptive-sm">Combo:</span>
                        <div className="font-mono text-white font-bold text-shadow-adaptive">
                          {formatCombo(player.best_combo)}x
                        </div>
                      </div>
                      <div>
                        <span className="text-white/70 text-shadow-adaptive-sm">Maps:</span>
                        <div className="text-white/90 font-medium text-shadow-adaptive">
                          {player.maps_played}/{totalMaps}
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      </div>
    );
  }

  // Desktop Table View - No glass wrapping, integrated into parent
  return (
    <div className="overflow-x-auto">
      <table className="w-full" role="table" aria-label="Combined score leaderboard">
        <thead>
          <tr className="border-b border-white/20">
            <th className="py-3 sm:py-4 px-3 sm:px-4 text-xs sm:text-sm font-semibold text-white/90 text-left text-shadow-adaptive-sm">
              Rank
            </th>
            <th className="py-3 sm:py-4 px-3 sm:px-4 text-xs sm:text-sm font-semibold text-white/90 text-left text-shadow-adaptive-sm">
              <SortButton column="player" align="left">Player</SortButton>
            </th>
            <th className="py-3 sm:py-4 px-4 sm:px-6 text-xs sm:text-sm font-semibold text-white/90 text-center text-shadow-adaptive-sm">
              <SortButton column="total_score" align="center">
                <Trophy className="w-3 h-3 sm:w-4 sm:h-4 icon-shadow-adaptive-sm" />
                Total Score
              </SortButton>
            </th>
            <th className="py-3 sm:py-4 px-4 sm:px-6 text-xs sm:text-sm font-semibold text-white/90 text-center text-shadow-adaptive-sm">
              <SortButton column="average_accuracy" align="center">
                <Target className="w-3 h-3 sm:w-4 sm:h-4 icon-shadow-adaptive-sm" />
                Avg Accuracy
              </SortButton>
            </th>
            <th className="py-3 sm:py-4 px-4 sm:px-6 text-xs sm:text-sm font-semibold text-white/90 text-center text-shadow-adaptive-sm">
              <SortButton column="best_combo" align="center">
                <Award className="w-3 h-3 sm:w-4 sm:h-4 icon-shadow-adaptive-sm" />
                Best Combo
              </SortButton>
            </th>
            <th className="py-3 sm:py-4 px-4 sm:px-6 text-xs sm:text-sm font-semibold text-white/90 text-center text-shadow-adaptive-sm">
              <SortButton column="maps_played" align="center">
                <Activity className="w-3 h-3 sm:w-4 sm:h-4 icon-shadow-adaptive-sm" />
                Maps
              </SortButton>
            </th>
          </tr>
        </thead>
        <tbody>
          {sortedLeaderboard.map((player, index) => {
            const rank = index + 1;
            const username = sanitizeText(player.username || 'Unknown');
            const country = sanitizeText(player.country || '');
            const isTop3 = rank <= 3;
            
            return (
              <tr 
                key={player.user_id || index}
                className={`transition-all border-b border-white/10 last:border-b-0 hover:bg-white/5 ${
                  isTop3 ? 'bg-white/5' : ''
                }`}
                role="row"
              >
                <td className="py-3 sm:py-4 px-3 sm:px-4" role="cell">
                  <div className="flex items-center justify-start gap-1">
                    {isTop3 ? (
                      <div className={`w-10 h-10 sm:w-12 sm:h-12 rounded-lg sm:rounded-xl bg-gradient-to-b ${getRankGradient(rank)} flex items-center justify-center shadow-lg`}>
                        <span className="text-white font-black text-xs sm:text-sm text-shadow-adaptive">
                          #{rank}
                        </span>
                      </div>
                    ) : (
                      <span className="text-sm sm:text-lg font-bold text-white/90 text-shadow-adaptive">
                        #{rank}
                      </span>
                    )}
                    {rank === 1 && (
                      <Crown className="w-4 h-4 sm:w-5 sm:h-5 text-yellow-300 ml-2 icon-shadow-adaptive" />
                    )}
                  </div>
                </td>
                <td className="py-3 sm:py-4 px-3 sm:px-4" role="cell">
                  <div className="flex items-center gap-2 sm:gap-3">
                    {player.avatar_url && (
                      <img 
                        src={player.avatar_url} 
                        alt={`${username}'s avatar`}
                        className="w-10 h-10 sm:w-12 sm:h-12 rounded-full avatar-border flex-shrink-0"
                        onError={(e) => { e.target.style.display = 'none'; }}
                      />
                    )}
                    <div className="min-w-0 flex-1">
                      <button 
                        className="font-bold text-white hover:text-purple-300 transition-colors text-shadow-adaptive truncate text-sm sm:text-lg text-left" 
                        onClick={() => handleUsernameClick(player)}
                      >
                        {username}
                      </button>
                      {country && (
                        <div className="flex items-center gap-1 mt-0.5">
                          {getCountryFlagUrl(country) && (
                            <img 
                              src={getCountryFlagUrl(country)} 
                              alt={`${country} flag`}
                              className="w-4 h-3 sm:w-5 sm:h-3.5 object-cover rounded-sm shadow-sm"
                              onError={(e) => { e.target.style.display = 'none'; }}
                            />
                          )}
                          <span className="text-xs text-white/70 font-medium text-shadow-adaptive-sm">
                            {country.toUpperCase()}
                          </span>
                        </div>
                      )}
                    </div>
                  </div>
                </td>
                <td className="py-3 sm:py-4 px-4 sm:px-6 text-center" role="cell">
                  <span className="font-mono font-black text-white text-base sm:text-xl text-glow-blue text-shadow-adaptive">
                    {formatScore(player.total_score)}
                  </span>
                </td>
                <td className="py-3 sm:py-4 px-4 sm:px-6 text-center" role="cell">
                  <div className={`inline-flex px-2 py-1 sm:px-3 sm:py-1.5 bg-gradient-to-b ${getAccuracyGradient(player.average_accuracy)} ${getAccuracyBorder(player.average_accuracy)} text-white rounded-full font-bold text-xs sm:text-sm shadow-md`}>
                    {formatAccuracy(player.average_accuracy)}%
                  </div>
                </td>
                <td className="py-3 sm:py-4 px-4 sm:px-6 text-center" role="cell">
                  <span className="font-mono text-white font-bold text-base sm:text-lg text-glow-green text-shadow-adaptive">
                    {formatCombo(player.best_combo)}x
                  </span>
                </td>
                <td className="py-3 sm:py-4 px-4 sm:px-6 text-center" role="cell">
                  <div className={`inline-flex px-2 py-1 sm:px-3 sm:py-1.5 bg-gradient-to-b ${getParticipationGradient(player.maps_played)} ${getParticipationBorder(player.maps_played)} text-white rounded-full font-bold text-xs sm:text-sm shadow-md`}>
                    {player.maps_played}/{totalMaps}
                  </div>
                </td>
              </tr>
            );
          })}
        </tbody>
      </table>
    </div>
  );
}


================================================
FILE: frontend/components/DonationForm.js
================================================
import { useState, useEffect } from 'react';
import { loadStripe } from '@stripe/stripe-js';
import { 
  CreditCard, Lock, AlertCircle, Loader2, Mail, 
  MessageSquare, Eye, EyeOff, Gift, Sparkles,
  Heart, Check, ChevronRight, Shield
} from 'lucide-react';

// Initialize Stripe
const stripePromise = loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY);

export default function DonationForm({ user, selectedAmount, onSuccess, onError }) {
  const [amount, setAmount] = useState('20');
  const [isRecurring, setIsRecurring] = useState(false);
  const [email, setEmail] = useState(user?.email || '');
  const [message, setMessage] = useState('');
  const [isAnonymous, setIsAnonymous] = useState(false);
  const [processing, setProcessing] = useState(false);
  const [customAmount, setCustomAmount] = useState('');
  const [activeAmount, setActiveAmount] = useState(20);
  const [formErrors, setFormErrors] = useState({});
  const [focusedInput, setFocusedInput] = useState(null);

  const predefinedAmounts = [5, 10, 20, 50, 100];

  useEffect(() => {
    if (selectedAmount) {
      setAmount(selectedAmount.toString());
      setActiveAmount(selectedAmount);
      setCustomAmount('');
    }
  }, [selectedAmount]);

  const handleAmountSelect = (value) => {
    setActiveAmount(value);
    setAmount(value.toString());
    setCustomAmount('');
  };

  const handleCustomAmountChange = (e) => {
    const value = e.target.value;
    if (/^\d*$/.test(value)) {
      setCustomAmount(value);
      if (value) {
        setAmount(value);
        setActiveAmount(parseInt(value));
      }
    }
  };

  const validateForm = () => {
    const errors = {};
    const finalAmount = customAmount || amount;
    
    if (!finalAmount || parseInt(finalAmount) < 1) {
      errors.amount = 'Please enter an amount of at least $1';
    }
    
    if (!user && !email) {
      errors.email = 'Email is required for guest donations';
    } else if (!user && email && !/\S+@\S+\.\S+/.test(email)) {
      errors.email = 'Please enter a valid email address';
    }
    
    setFormErrors(errors);
    return Object.keys(errors).length === 0;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!validateForm()) return;
    
    setProcessing(true);
    
    try {
      const finalAmount = customAmount || amount;
      
      const response = await fetch('/api/create-payment-intent', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          amount: Math.round(parseInt(finalAmount) * 100),
          currency: 'usd',
          isRecurring,
          email: user?.email || email,
          userId: user?.id,
          message,
          isAnonymous,
          metadata: {
            username: user?.username || 'Guest',
            donationType: isRecurring ? 'recurring' : 'one-time'
          }
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to create payment intent');
      }

      const stripe = await stripePromise;
      const { error } = await stripe.redirectToCheckout({
        sessionId: data.sessionId
      });

      if (error) {
        throw error;
      }
    } catch (error) {
      console.error('Payment error:', error);
      onError(error);
    } finally {
      setProcessing(false);
    }
  };

  const getFinalAmount = () => {
    return customAmount || amount;
  };

  return (
    <div className="space-y-6">
      {/* Donation Type Selector - Redesigned */}
      <div>
        <label className="block text-sm font-bold text-white mb-3 text-shadow-adaptive flex items-center gap-2">
          <Gift className="w-4 h-4 icon-shadow-adaptive-sm" />
          Donation Type
        </label>
        <div className="grid grid-cols-2 gap-3">
          <button
            type="button"
            onClick={() => setIsRecurring(false)}
            className={`
              relative p-4 rounded-xl font-semibold text-white transition-all duration-300
              ${!isRecurring 
                ? 'glass-2 border-2 border-primary-500 shadow-lg scale-[1.02]' 
                : 'glass-1 border-2 border-transparent hover:glass-2'
              }
            `}
          >
            <div className="flex items-center justify-center gap-2">
              <Heart className="w-5 h-5 icon-shadow-adaptive-sm" />
              <span className="text-shadow-adaptive">One-time</span>
            </div>
            {!isRecurring && (
              <div className="absolute -top-2 -right-2">
                <div className="w-6 h-6 bg-primary-500 rounded-full flex items-center justify-center">
                  <Check className="w-4 h-4 text-white" />
                </div>
              </div>
            )}
          </button>

          <button
            type="button"
            onClick={() => setIsRecurring(true)}
            className={`
              relative p-4 rounded-xl font-semibold text-white transition-all duration-300
              ${isRecurring 
                ? 'glass-2 border-2 border-primary-500 shadow-lg scale-[1.02]' 
                : 'glass-1 border-2 border-transparent hover:glass-2'
              }
            `}
          >
            <div className="flex items-center justify-center gap-2">
              <Sparkles className="w-5 h-5 icon-shadow-adaptive-sm" />
              <span className="text-shadow-adaptive">Monthly</span>
            </div>
            {isRecurring && (
              <div className="absolute -top-2 -right-2">
                <div className="w-6 h-6 bg-primary-500 rounded-full flex items-center justify-center">
                  <Check className="w-4 h-4 text-white" />
                </div>
              </div>
            )}
          </button>
        </div>
      </div>

      {/* Amount Selection - Redesigned */}
      <div>
        <label className="block text-sm font-bold text-white mb-3 text-shadow-adaptive flex items-center gap-2">
          <CreditCard className="w-4 h-4 icon-shadow-adaptive-sm" />
          Select Amount (USD)
        </label>
        
        {/* Quick Select Amounts - Better mobile layout */}
        <div className="grid grid-cols-3 gap-2 sm:gap-3 mb-4">
          {predefinedAmounts.slice(0, 3).map((value) => (
            <button
              key={value}
              type="button"
              onClick={() => handleAmountSelect(value)}
              className={`
                relative p-3 sm:p-4 rounded-xl font-bold text-white transition-all duration-300
                ${activeAmount === value && !customAmount
                  ? 'glass-3 scale-105 border-2 border-primary-500' 
                  : 'glass-1 border-2 border-transparent hover:glass-2 hover:border-white/30'
                }
              `}
            >
              <div className="text-xl sm:text-2xl text-shadow-adaptive">${value}</div>
              {activeAmount === value && !customAmount && (
                <div className="absolute -top-1.5 -right-1.5">
                  <div className="w-5 h-5 bg-primary-500 rounded-full flex items-center justify-center">
                    <Check className="w-3 h-3 text-white" />
                  </div>
                </div>
              )}
            </button>
          ))}
        </div>

        <div className="grid grid-cols-2 gap-2 sm:gap-3 mb-4">
          {predefinedAmounts.slice(3).map((value) => (
            <button
              key={value}
              type="button"
              onClick={() => handleAmountSelect(value)}
              className={`
                relative p-3 sm:p-4 rounded-xl font-bold text-white transition-all duration-300
                ${activeAmount === value && !customAmount
                  ? 'glass-3 scale-105 border-2 border-primary-500' 
                  : 'glass-1 border-2 border-transparent hover:glass-2 hover:border-white/30'
                }
              `}
            >
              <div className="text-xl sm:text-2xl text-shadow-adaptive">${value}</div>
              {activeAmount === value && !customAmount && (
                <div className="absolute -top-1.5 -right-1.5">
                  <div className="w-5 h-5 bg-primary-500 rounded-full flex items-center justify-center">
                    <Check className="w-3 h-3 text-white" />
                  </div>
                </div>
              )}
            </button>
          ))}
        </div>

        {/* Custom Amount - Improved design */}
        <div className="relative">
          <div className={`
            relative overflow-hidden rounded-xl transition-all duration-300
            ${focusedInput === 'custom' ? 'ring-2 ring-primary-500' : ''}
            ${customAmount ? 'glass-3 border-2 border-primary-500' : 'glass-2 border-2 border-transparent'}
          `}>
            <div className="absolute left-4 top-1/2 -translate-y-1/2 text-white text-xl font-bold pointer-events-none text-shadow-adaptive">
              $
            </div>
            <input
              type="text"
              inputMode="numeric"
              pattern="[0-9]*"
              value={customAmount}
              onChange={handleCustomAmountChange}
              onFocus={() => setFocusedInput('custom')}
              onBlur={() => setFocusedInput(null)}
              placeholder="Enter custom amount"
              className="w-full pl-10 pr-4 py-4 bg-transparent font-bold text-white placeholder-white/50 text-lg focus:outline-none text-shadow-adaptive"
            />
            {customAmount && (
              <div className="absolute right-4 top-1/2 -translate-y-1/2">
                <div className="w-6 h-6 bg-primary-500 rounded-full flex items-center justify-center">
                  <Check className="w-4 h-4 text-white" />
                </div>
              </div>
            )}
          </div>
        </div>
        
        {formErrors.amount && (
          <div className="mt-2 flex items-center gap-2 text-red-300">
            <AlertCircle className="w-4 h-4 icon-shadow-adaptive-sm" />
            <span className="text-sm text-shadow-adaptive-sm">{formErrors.amount}</span>
          </div>
        )}
      </div>

      {/* Email for Guests - Redesigned */}
      {!user && (
        <div>
          <label className="block text-sm font-bold text-white mb-3 text-shadow-adaptive flex items-center gap-2">
            <Mail className="w-4 h-4 icon-shadow-adaptive-sm" />
            Email Address
          </label>
          <div className={`
            relative rounded-xl overflow-hidden transition-all duration-300
            ${focusedInput === 'email' ? 'ring-2 ring-primary-500' : ''}
            ${formErrors.email ? 'glass-2 border-2 border-red-400' : 'glass-2 border-2 border-transparent'}
          `}>
            <input
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              onFocus={() => setFocusedInput('email')}
              onBlur={() => setFocusedInput(null)}
              placeholder="your@email.com"
              className="w-full px-4 py-3 bg-transparent font-medium text-white placeholder-white/50 focus:outline-none text-shadow-adaptive"
            />
          </div>
          {formErrors.email && (
            <div className="mt-2 flex items-center gap-2 text-red-300">
              <AlertCircle className="w-4 h-4 icon-shadow-adaptive-sm" />
              <span className="text-sm text-shadow-adaptive-sm">{formErrors.email}</span>
            </div>
          )}
          <p className="mt-2 text-xs text-white/60 text-shadow-adaptive-sm">
            We'll send your receipt here
          </p>
        </div>
      )}

      {/* Message - Redesigned */}
      <div>
        <label className="block text-sm font-bold text-white mb-3 text-shadow-adaptive flex items-center gap-2">
          <MessageSquare className="w-4 h-4 icon-shadow-adaptive-sm" />
          Support Message (optional)
        </label>
        <div className={`
          relative rounded-xl overflow-hidden transition-all duration-300
          ${focusedInput === 'message' ? 'ring-2 ring-primary-500' : ''}
          glass-2 border-2 border-transparent
        `}>
          <textarea
            value={message}
            onChange={(e) => setMessage(e.target.value)}
            onFocus={() => setFocusedInput('message')}
            onBlur={() => setFocusedInput(null)}
            placeholder="Share why you're supporting osu!Challengers..."
            rows={3}
            className="w-full px-4 py-3 bg-transparent font-medium text-white placeholder-white/50 focus:outline-none resize-none text-shadow-adaptive"
          />
        </div>
      </div>

      {/* Privacy Options - Redesigned */}
      <div className="space-y-3">
        <button
          type="button"
          onClick={() => setIsAnonymous(!isAnonymous)}
          className={`
            w-full p-4 rounded-xl transition-all duration-300 group
            ${isAnonymous ? 'glass-2 border-2 border-primary-500' : 'glass-1 border-2 border-transparent hover:glass-2'}
          `}
        >
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              {isAnonymous ? (
                <EyeOff className="w-5 h-5 text-white icon-shadow-adaptive-sm" />
              ) : (
                <Eye className="w-5 h-5 text-white/70 icon-shadow-adaptive-sm group-hover:text-white" />
              )}
              <div className="text-left">
                <div className="font-semibold text-white text-shadow-adaptive">
                  Anonymous Donation
                </div>
                <div className="text-xs text-white/60 text-shadow-adaptive-sm">
                  Your name won't be displayed publicly
                </div>
              </div>
            </div>
            <div className={`
              w-6 h-6 rounded-full flex items-center justify-center transition-all
              ${isAnonymous ? 'bg-primary-500' : 'glass-2'}
            `}>
              {isAnonymous && <Check className="w-4 h-4 text-white" />}
            </div>
          </div>
        </button>
      </div>

      {/* Payment Security Notice - Redesigned */}
      <div className="glass-1 rounded-xl p-4 border-2 border-green-400/30">
        <div className="flex items-start gap-3">
          <div className="p-2 icon-gradient-green rounded icon-container-green">
            <Shield className="w-4 h-4 text-white icon-shadow-adaptive-sm" />
          </div>
          <div className="flex-1">
            <h4 className="font-semibold text-white mb-1 text-shadow-adaptive">
              Secure Payment Processing
            </h4>
            <p className="text-xs text-white/80 text-shadow-adaptive-sm">
              Your payment is encrypted and processed securely through Stripe. 
              We never store your payment information.
            </p>
          </div>
        </div>
      </div>

      {/* Submit Button - Redesigned */}
      <button
        onClick={handleSubmit}
        disabled={processing || !getFinalAmount()}
        className={`
          w-full py-5 rounded-xl font-bold text-lg transition-all duration-300 relative overflow-hidden
          ${processing || !getFinalAmount()
            ? 'glass-1 text-white/30 cursor-not-allowed'
            : 'bg-gradient-to-r from-primary-500 to-pink-500 text-white transform hover:scale-[1.02] hover:shadow-xl active:scale-[0.98]'
          }
        `}
      >
        {processing ? (
          <div className="flex items-center justify-center gap-3">
            <Loader2 className="w-6 h-6 animate-spin icon-shadow-adaptive" />
            <span className="text-shadow-adaptive">Processing Payment...</span>
          </div>
        ) : (
          <div className="flex items-center justify-center gap-3">
            <Heart className="w-6 h-6 icon-shadow-adaptive" />
            <span className="text-shadow-adaptive">
              Donate ${getFinalAmount() || '0'} {isRecurring ? 'Monthly' : 'Now'}
            </span>
            <ChevronRight className="w-6 h-6 icon-shadow-adaptive" />
          </div>
        )}
        
        {/* Animated gradient overlay */}
        {!processing && getFinalAmount() && (
          <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent -translate-x-full hover:translate-x-full transition-transform duration-1000 ease-in-out" />
        )}
      </button>

      {/* Legal Notice - Simplified */}
      <p className="text-xs text-white/50 text-center text-shadow-adaptive-sm">
        Donations are non-refundable and support the osu!Challengers platform
      </p>
    </div>
  );
}


================================================
FILE: frontend/components/ErrorBoundary.js
================================================
import React from 'react';
import { AlertTriangle, RefreshCw, Home, ExternalLink } from 'lucide-react';

// Error types for better categorization
const ERROR_TYPES = {
  NETWORK: 'network',
  API: 'api',
  AUTH: 'auth',
  RATE_LIMIT: 'rate_limit',
  NOT_FOUND: 'not_found',
  PERMISSION: 'permission',
  VALIDATION: 'validation',
  UNKNOWN: 'unknown'
};

// Determine error type from error object
function getErrorType(error) {
  if (!error) return ERROR_TYPES.UNKNOWN;
  
  const message = error.message?.toLowerCase() || '';
  
  if (error.name === 'TypeError' && message.includes('fetch')) {
    return ERROR_TYPES.NETWORK;
  }
  
  if (error.status) {
    if (error.status === 401 || error.status === 403) {
      return ERROR_TYPES.AUTH;
    }
    if (error.status === 404) {
      return ERROR_TYPES.NOT_FOUND;
    }
    if (error.status === 429) {
      return ERROR_TYPES.RATE_LIMIT;
    }
    if (error.status >= 400 && error.status < 500) {
      return ERROR_TYPES.VALIDATION;
    }
    if (error.status >= 500) {
      return ERROR_TYPES.API;
    }
  }
  
  if (message.includes('network') || message.includes('fetch')) {
    return ERROR_TYPES.NETWORK;
  }
  
  if (message.includes('unauthorized') || message.includes('forbidden')) {
    return ERROR_TYPES.AUTH;
  }
  
  return ERROR_TYPES.UNKNOWN;
}

// Get user-friendly error messages
function getErrorMessage(error, errorType) {
  const messages = {
    [ERROR_TYPES.NETWORK]: {
      title: 'Connection Problem',
      description: 'Unable to connect to our servers. Please check your internet connection and try again.',
      action: 'Retry'
    },
    [ERROR_TYPES.API]: {
      title: 'Server Error',
      description: 'Our servers are experiencing issues. This is usually temporary.',
      action: 'Try Again'
    },
    [ERROR_TYPES.AUTH]: {
      title: 'Authentication Required',
      description: 'You need to log in to access this feature.',
      action: 'Login'
    },
    [ERROR_TYPES.RATE_LIMIT]: {
      title: 'Too Many Requests',
      description: 'You\'re making requests too quickly. Please wait a moment before trying again.',
      action: 'Wait & Retry'
    },
    [ERROR_TYPES.NOT_FOUND]: {
      title: 'Not Found',
      description: 'The content you\'re looking for doesn\'t exist or has been moved.',
      action: 'Go Home'
    },
    [ERROR_TYPES.PERMISSION]: {
      title: 'Access Denied',
      description: 'You don\'t have permission to access this resource.',
      action: 'Go Back'
    },
    [ERROR_TYPES.VALIDATION]: {
      title: 'Invalid Request',
      description: 'The request contains invalid data. Please check your input and try again.',
      action: 'Retry'
    },
    [ERROR_TYPES.UNKNOWN]: {
      title: 'Something Went Wrong',
      description: 'An unexpected error occurred. Please try refreshing the page.',
      action: 'Refresh'
    }
  };

  return messages[errorType] || messages[ERROR_TYPES.UNKNOWN];
}

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { 
      hasError: false, 
      error: null,
      errorInfo: null,
      errorId: null,
      retryCount: 0
    };
  }

  static getDerivedStateFromError(error) {
    // Generate a unique error ID for tracking
    const errorId = `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    return { 
      hasError: true, 
      error,
      errorId
    };
  }

  componentDidCatch(error, errorInfo) {
    const errorType = getErrorType(error);
    
    // Store error info
    this.setState({ errorInfo });
    
    // Log error details
    const errorDetails = {
      id: this.state.errorId,
      type: errorType,
      message: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: window.location.href,
      retryCount: this.state.retryCount
    };

    console.error('Error caught by boundary:', errorDetails);
    
    // In production, send to error tracking service
    if (process.env.NODE_ENV === 'production') {
      try {
        // Send to error tracking service (e.g., Sentry)
        if (window.Sentry) {
          window.Sentry.withScope((scope) => {
            scope.setTag('errorBoundary', true);
            scope.setTag('errorType', errorType);
            scope.setContext('errorDetails', errorDetails);
            window.Sentry.captureException(error);
          });
        }
        
        // Optionally send to your own error logging endpoint
        fetch('/api/errors', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(errorDetails)
        }).catch(() => {
          // Silently fail if error logging fails
        });
      } catch (reportingError) {
        console.error('Failed to report error:', reportingError);
      }
    }
  }

  handleRetry = () => {
    this.setState(prevState => ({
      hasError: false,
      error: null,
      errorInfo: null,
      retryCount: prevState.retryCount + 1
    }));
  };

  handleRefresh = () => {
    window.location.reload();
  };

  handleGoHome = () => {
    window.location.href = '/';
  };

  handleLogin = () => {
    window.location.href = '/api/auth/login';
  };

  render() {
    if (this.state.hasError) {
      const errorType = getErrorType(this.state.error);
      const errorMessage = getErrorMessage(this.state.error, errorType);
      const isNetworkError = errorType === ERROR_TYPES.NETWORK;
      const isAuthError = errorType === ERROR_TYPES.AUTH;
      const isRateLimit = errorType === ERROR_TYPES.RATE_LIMIT;

      // Custom fallback from props
      if (this.props.fallback) {
        return this.props.fallback(this.state.error, this.handleRetry);
      }

      return (
        <div className="min-h-screen bg-gradient-to-br from-gray-900 via-purple-900/20 to-gray-900 text-white flex items-center justify-center p-4">
          <div className="max-w-md w-full text-center">
            {/* Error Icon */}
            <div className="mb-6">
              <AlertTriangle className="w-16 h-16 text-red-400 mx-auto" />
            </div>

            {/* Error Message */}
            <h1 className="text-2xl font-bold mb-2">{errorMessage.title}</h1>
            <p className="text-gray-400 mb-6">{errorMessage.description}</p>

            {/* Additional Info for Rate Limiting */}
            {isRateLimit && (
              <div className="bg-yellow-900/20 border border-yellow-500/30 rounded-lg p-4 mb-6">
                <p className="text-yellow-300 text-sm">
                  Rate limit will reset in a few minutes. You can try again then.
                </p>
              </div>
            )}

            {/* Action Buttons */}
            <div className="space-y-3 mb-6">
              {isAuthError ? (
                <button
                  onClick={this.handleLogin}
                  className="w-full px-6 py-3 bg-purple-600 hover:bg-purple-700 rounded-lg transition-colors flex items-center justify-center gap-2"
                >
                  <ExternalLink className="w-4 h-4" />
                  Login with osu!
                </button>
              ) : errorType === ERROR_TYPES.NOT_FOUND ? (
                <button
                  onClick={this.handleGoHome}
                  className="w-full px-6 py-3 bg-purple-600 hover:bg-purple-700 rounded-lg transition-colors flex items-center justify-center gap-2"
                >
                  <Home className="w-4 h-4" />
                  Go Home
                </button>
              ) : (
                <button
                  onClick={isNetworkError ? this.handleRetry : this.handleRefresh}
                  className="w-full px-6 py-3 bg-purple-600 hover:bg-purple-700 rounded-lg transition-colors flex items-center justify-center gap-2"
                  disabled={isRateLimit}
                >
                  <RefreshCw className="w-4 h-4" />
                  {errorMessage.action}
                </button>
              )}

              {/* Secondary Actions */}
              <div className="flex gap-2">
                <button
                  onClick={this.handleGoHome}
                  className="flex-1 px-4 py-2 text-gray-400 hover:text-white border border-gray-600 hover:border-gray-500 rounded-lg transition-colors"
                >
                  Home
                </button>
                <button
                  onClick={this.handleRefresh}
                  className="flex-1 px-4 py-2 text-gray-400 hover:text-white border border-gray-600 hover:border-gray-500 rounded-lg transition-colors"
                >
                  Refresh
                </button>
              </div>
            </div>

            {/* Retry Count */}
            {this.state.retryCount > 0 && (
              <p className="text-xs text-gray-500 mb-4">
                Retry attempts: {this.state.retryCount}
              </p>
            )}

            {/* Support Information */}
            <div className="text-xs text-gray-500">
              <p>Error ID: {this.state.errorId}</p>
              {process.env.NEXT_PUBLIC_SUPPORT_EMAIL && (
                <p className="mt-1">
                  Need help? Contact{' '}
                  <a 
                    href={`mailto:${process.env.NEXT_PUBLIC_SUPPORT_EMAIL}?subject=Error Report - ${this.state.errorId}`}
                    className="text-purple-400 hover:text-purple-300"
                  >
                    support
                  </a>
                </p>
              )}
            </div>

            {/* Development Error Details */}
            {process.env.NODE_ENV === 'development' && (
              <details className="mt-8 text-left">
                <summary className="cursor-pointer text-sm text-gray-500 hover:text-gray-400">
                  Error Details (Development Only)
                </summary>
                <div className="mt-2 p-4 bg-black/50 rounded text-xs overflow-auto max-h-64">
                  <div className="mb-2">
                    <strong>Type:</strong> {errorType}
                  </div>
                  <div className="mb-2">
                    <strong>Message:</strong> {this.state.error?.message}
                  </div>
                  {this.state.error?.stack && (
                    <div className="mb-2">
                      <strong>Stack:</strong>
                      <pre className="mt-1 whitespace-pre-wrap">{this.state.error.stack}</pre>
                    </div>
                  )}
                  {this.state.errorInfo?.componentStack && (
                    <div>
                      <strong>Component Stack:</strong>
                      <pre className="mt-1 whitespace-pre-wrap">{this.state.errorInfo.componentStack}</pre>
                    </div>
                  )}
                </div>
              </details>
            )}
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

// HOC for wrapping components with error boundaries
export function withErrorBoundary(Component, errorBoundaryProps = {}) {
  const WrappedComponent = (props) => (
    <ErrorBoundary {...errorBoundaryProps}>
      <Component {...props} />
    </ErrorBoundary>
  );
  
  WrappedComponent.displayName = `withErrorBoundary(${Component.displayName || Component.name})`;
  
  return WrappedComponent;
}

// Hook for error boundary integration
export function useErrorHandler() {
  return (error, errorInfo) => {
    // This can be used to manually trigger error boundary
    throw error;
  };
}

export default ErrorBoundary;


================================================
FILE: frontend/components/ExpandedPartnerModal.js
================================================
import FormattedDescription from '../lib/text-formatting';
import { useState, useRef, useEffect } from 'react';
import { X } from 'lucide-react';

export default function ExpandedPartnerModal({ partner, isVisible, onClose, startPosition }) {
  const modalRef = useRef(null);
  const [animationPhase, setAnimationPhase] = useState('entering');
  const [isMobile, setIsMobile] = useState(false);

  // Detect mobile viewport
  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth < 768);
    };
    
    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  useEffect(() => {
    if (isVisible) {
      setAnimationPhase('entering');
      // Prevent body scroll on mobile
      if (isMobile) {
        document.body.style.overflow = 'hidden';
      }
      setTimeout(() => setAnimationPhase('expanded'), 50);
    } else {
      // Restore body scroll
      document.body.style.overflow = '';
    }
  }, [isVisible, isMobile]);

  const handleClose = () => {
    setAnimationPhase('exiting');
    setTimeout(() => {
      document.body.style.overflow = '';
      onClose();
    }, 300);
  };

  const handleBackdropClick = (e) => {
    if (e.target === e.currentTarget) {
      handleClose();
    }
  };

  // Handle touch events for mobile
  const handleTouchStart = useRef(null);
  const handleTouchMove = (e) => {
    if (!isMobile) return;
    
    const touch = e.touches[0];
    const startY = handleTouchStart.current;
    
    if (startY && touch.clientY - startY > 100) {
      // Swipe down to close on mobile
      handleClose();
    }
  };

  const handleTouchStartCapture = (e) => {
    if (isMobile) {
      handleTouchStart.current = e.touches[0].clientY;
    }
  };

  useEffect(() => {
    const handleEsc = (e) => {
      if (e.key === 'Escape' && isVisible) {
        handleClose();
      }
    };
    document.addEventListener('keydown', handleEsc);
    return () => document.removeEventListener('keydown', handleEsc);
  }, [isVisible]);

  if (!isVisible && animationPhase === 'exiting') return null;
  if (!partner) return null;

  const getTransformStyle = () => {
    if (!startPosition) return {};
    
    // Responsive modal dimensions
    const modalWidth = isMobile ? Math.min(window.innerWidth - 32, 400) : 600;
    const modalHeight = isMobile ? Math.min(window.innerHeight - 64, 600) : 500;
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    const centerX = viewportWidth / 2 - modalWidth / 2;
    const centerY = viewportHeight / 2 - modalHeight / 2;
    
    // Smaller scale start for mobile
    const scaleStart = isMobile 
      ? Math.min(60 / modalWidth, 60 / modalHeight)
      : Math.min(80 / modalWidth, 80 / modalHeight);
    
    if (animationPhase === 'entering') {
      return {
        transform: `translate(${startPosition.x - centerX}px, ${startPosition.y - centerY}px) scale(${scaleStart})`,
        opacity: 1,
      };
    } else if (animationPhase === 'expanded') {
      return {
        transform: 'translate(0px, 0px) scale(1)',
        opacity: 1,
      };
    } else {
      return {
        transform: `translate(${startPosition.x - centerX}px, ${startPosition.y - centerY}px) scale(${scaleStart})`,
        opacity: 0,
      };
    }
  };

  return (
    <div
      className={`
        fixed inset-0 z-50 flex items-center justify-center transition-all duration-300
        ${isMobile ? 'p-4' : 'p-4'}
        ${animationPhase === 'expanded' ? 'bg-black/50 backdrop-blur-sm' : 'bg-transparent'}
      `}
      onClick={handleBackdropClick}
      onTouchStart={handleTouchStartCapture}
      onTouchMove={handleTouchMove}
    >
      <div
        ref={modalRef}
        className={`
          relative glass-2 rounded-3xl shadow-2xl overflow-hidden transition-all duration-300 ease-out
          ${isMobile 
            ? 'w-full max-w-sm max-h-[90vh] rounded-2xl' 
            : 'w-full max-w-2xl'
          }
        `}
        style={getTransformStyle()}
      >
        {/* Mobile swipe indicator */}
        {isMobile && (
          <div className={`
            absolute top-2 left-1/2 transform -translate-x-1/2 w-8 h-1 bg-white/40 rounded-full
            transition-opacity duration-300
            ${animationPhase === 'expanded' ? 'opacity-100' : 'opacity-0'}
          `} />
        )}

        {/* Close Button */}
        <button
          onClick={handleClose}
          className={`
            absolute z-10 glass-2 hover:glass-3 rounded-full transition-all duration-200 hover:scale-110 text-white
            ${isMobile ? 'top-4 right-4 p-1.5' : 'top-6 right-6 p-2'}
            ${animationPhase === 'expanded' ? 'opacity-100' : 'opacity-0'}
          `}
        >
          <X className={`icon-shadow-adaptive-sm ${isMobile ? 'w-4 h-4' : 'w-5 h-5'}`} />
        </button>

        {/* Content */}
        <div className={`
          overflow-y-auto max-h-full
          ${isMobile ? 'pt-6 px-5 pb-5' : 'pt-8 px-8 pb-6'}
        `}>
          {/* Header */}
          <div className={`
            flex items-center mb-6
            ${isMobile ? 'gap-4 flex-col text-center' : 'gap-6'}
          `}>
            <div className={`
              rounded-3xl overflow-hidden bg-white shadow-lg border-3 !border-white/60
              ${isMobile ? 'w-20 h-20 rounded-2xl' : 'w-24 h-24'}
            `}>
              <img
                src={partner.icon_url}
                alt={partner.name}
                className="w-full h-full object-cover"
                onError={(e) => {
                  e.target.onerror = null;
                  e.target.src = `https://ui-avatars.com/api/?name=${encodeURIComponent(partner.name)}&background=9333ea&color=fff&size=256`;
                }}
              />
            </div>
            <div className={isMobile ? 'text-center' : ''}>
              <h2 className={`
                font-bold text-white mb-2 text-shadow-adaptive-lg
                ${isMobile ? 'text-2xl' : 'text-3xl'}
              `}>
                {partner.name}
              </h2>
              <div className={`
                text-white/80 text-shadow-adaptive-sm
                ${isMobile ? 'text-xs' : 'text-sm'}
              `}>
                Partnership Spotlight
              </div>
            </div>
          </div>

          {/* Description with Formatting Support */}
          <div 
            className={`
              transition-all duration-500 delay-100
              ${animationPhase === 'expanded' ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-4'}
            `}
          >
            <h3 className={`
              font-semibold text-white mb-3 text-shadow-adaptive
              ${isMobile ? 'text-base' : 'text-lg'}
            `}>
              About This Partnership
            </h3>
            
            {/* Use FormattedDescription if description exists, otherwise fallback */}
            {partner.description ? (
              <div className={`
                text-white/90 leading-relaxed text-shadow-adaptive-sm
                ${isMobile ? 'text-sm' : 'text-base'}
              `}>
                <FormattedDescription 
                  text={partner.description} 
                  className="[&_strong]:text-white [&_em]:text-white/95 [&_a]:text-purple-300 [&_a:hover]:text-purple-200 [&_code]:bg-white/20 [&_code]:text-purple-200 [&_mark]:bg-yellow-400/30 [&_mark]:text-yellow-100"
                />
              </div>
            ) : (
              <p className={`
                text-white/90 leading-relaxed text-shadow-adaptive-sm
                ${isMobile ? 'text-sm' : 'text-base'}
              `}>
                Learn more about our partnership with {partner.name} and discover how this collaboration enhances your gaming experience. Click the link below to explore their platform and connect with their community.
              </p>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};


================================================
FILE: frontend/components/ExpandedTeamModal.js
================================================
import FormattedDescription from '../lib/text-formatting';
import { useState, useRef, useEffect, useMemo, memo, useCallback } from 'react';
import { X, Github, Twitter, ExternalLink } from 'lucide-react';
import { createPortal } from 'react-dom';

const ExpandedTeamModal = memo(function ExpandedTeamModal({ 
  member, 
  isVisible, 
  onClose, 
  startPosition 
}) {
  const modalRef = useRef(null);
  const [animationPhase, setAnimationPhase] = useState('entering');
  const [isMobile, setIsMobile] = useState(false);
  const [isMounted, setIsMounted] = useState(false);
  
  // ))) state 
  const [clickCount, setClickCount] = useState(0);
  const [joke, setJoke] = useState(null);
  const [showJokeModal, setShowJokeModal] = useState(false);
  const [jokeAnimating, setJokeAnimating] = useState(false);

  useEffect(() => {  // <-- Move here, inside component
    setIsMounted(true);
  }, []);

  // Detect mobile viewport
  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth < 768);
    };
    
    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  // Auto-dismiss ))) panel after animation + 3 seconds
  useEffect(() => {
    if (showJokeModal) {
      const timer = setTimeout(() => {
        setJokeAnimating(true);
        setTimeout(() => {
          setShowJokeModal(false);
          setJokeAnimating(false);
        }, 4000);
      }, 7000);
      
      return () => clearTimeout(timer);
    }
  }, [showJokeModal]);

  useEffect(() => {
    if (isVisible) {
      setAnimationPhase('entering');
      // Reset ))) state when modal opens
      setClickCount(0);
      setJoke(null);
      setShowJokeModal(false);
      
      // Prevent body scroll on mobile
      if (isMobile) {
        document.body.style.overflow = 'hidden';
      }
      const timer = setTimeout(() => setAnimationPhase('expanded'), 50);
      return () => clearTimeout(timer);
    } else {
      // Restore body scroll
      document.body.style.overflow = '';
    }
  }, [isVisible, isMobile]);

  // ))) click handler
  const handleAvatarClick = useCallback(async () => {

    const newCount = clickCount + 1;
    setClickCount(newCount);

    if (newCount === 10) {
      try {
        const response = await fetch('https://icanhazdadjoke.com/', {
          headers: { 'Accept': 'application/json' }
        });
        const data = await response.json();
        setJoke(data.joke);
        setShowJokeModal(true);
        setClickCount(0);
      } catch (error) {
        console.error('Error fetching joke:', error);
        setJoke("Why did the programmer quit his job? Because he didn't get arrays!");
        setShowJokeModal(true);
        setClickCount(0);
      }
    }

    // Reset counter after 3 seconds of inactivity
    setTimeout(() => {
      if (newCount < 10) {
        setClickCount(0);
      }
    }, 3000);
  }, [clickCount, member]);

  const handleClose = useCallback(() => {
    setAnimationPhase('exiting');
    const timer = setTimeout(() => {
      document.body.style.overflow = '';
      onClose();
    }, 300);
    return () => clearTimeout(timer);
  }, [onClose]);

  const handleBackdropClick = useCallback((e) => {
    if (e.target === e.currentTarget) {
      handleClose();
    }
  }, [handleClose]);

  // Handle touch events for mobile
  const handleTouchStart = useRef(null);
  const handleTouchMove = useCallback((e) => {
    if (!isMobile) return;
    
    const touch = e.touches[0];
    const startY = handleTouchStart.current;
    
    if (startY && touch.clientY - startY > 100) {
      // Swipe down to close on mobile
      handleClose();
    }
  }, [isMobile, handleClose]);

  const handleTouchStartCapture = useCallback((e) => {
    if (isMobile) {
      handleTouchStart.current = e.touches[0].clientY;
    }
  }, [isMobile]);

  useEffect(() => {
    const handleEsc = (e) => {
      if (e.key === 'Escape' && isVisible) {
        if (showJokeModal) {
          setShowJokeModal(false);
        } else {
          handleClose();
        }
      }
    };
    document.addEventListener('keydown', handleEsc);
    return () => document.removeEventListener('keydown', handleEsc);
  }, [isVisible, handleClose, showJokeModal]);

  // Memoize expensive computations
  const avatarUrl = useMemo(() => 
    member?.avatar_url || 
    `https://ui-avatars.com/api/?name=${encodeURIComponent(member?.name || '')}&background=9333ea&color=fff&size=256`,
    [member?.avatar_url, member?.name]
  );

  const roleBadgeClass = useMemo(() => {
    if (!member?.role) return 'staff-badge staff-badge-strategist';
    
    const roleLower = member.role.toLowerCase();
    if (roleLower.includes('lead') || roleLower.includes('project')) {
      return 'staff-badge staff-badge-lead';
    } else if (roleLower.includes('develop') || roleLower.includes('engineer') || roleLower.includes('program')) {
      return 'staff-badge staff-badge-developer';
    } else if (roleLower.includes('design') || roleLower.includes('ui') || roleLower.includes('ux')) {
      return 'staff-badge staff-badge-designer';
    } else if (roleLower.includes('map') || roleLower.includes('beat')) {
      return 'staff-badge staff-badge-mapper';
    } else if (roleLower.includes('community') || roleLower.includes('manager')) {
      return 'staff-badge staff-badge-strategist';
    } else if (roleLower.includes('qa') || roleLower.includes('test')) {
      return 'staff-badge staff-badge-qa';
    } else if (roleLower.includes('artist') || roleLower.includes('art')) {
      return 'staff-badge staff-badge-artist';
    } else if (roleLower.includes('composer') || roleLower.includes('music')) {
      return 'staff-badge staff-badge-composer';
    } else {
      return 'staff-badge staff-badge-strategist';
    }
  }, [member?.role]);

  const getTransformStyle = useMemo(() => {
    if (!startPosition) return {};
    
    // Responsive modal dimensions
    const modalWidth = isMobile ? Math.min(window.innerWidth - 32, 400) : 600;
    const modalHeight = isMobile ? Math.min(window.innerHeight - 64, 600) : 500;
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    const centerX = viewportWidth / 2 - modalWidth / 2;
    const centerY = viewportHeight / 2 - modalHeight / 2;
    
    // Smaller scale start for mobile
    const scaleStart = isMobile 
      ? Math.min(60 / modalWidth, 60 / modalHeight)
      : Math.min(80 / modalWidth, 80 / modalHeight);
    
    if (animationPhase === 'entering') {
      return {
        transform: `translate(${startPosition.x - centerX}px, ${startPosition.y - centerY}px) scale(${scaleStart})`,
        opacity: 1,
      };
    } else if (animationPhase === 'expanded') {
      return {
        transform: 'translate(0px, 0px) scale(1)',
        opacity: 1,
      };
    } else {
      return {
        transform: `translate(${startPosition.x - centerX}px, ${startPosition.y - centerY}px) scale(${scaleStart})`,
        opacity: 0,
      };
    }
  }, [startPosition, animationPhase, isMobile]);

  // Render social links
  const socialLinks = useMemo(() => {
    const hasSocialLinks = member?.social_links && Object.keys(member.social_links).length > 0;
    const hasOsuProfile = member?.osu_username;
    
    if (!hasSocialLinks && !hasOsuProfile) {
      return null;
    }

    return (
      <div className="flex items-center gap-3 mt-4 flex-wrap justify-center md:justify-start">
        {member.social_links?.github && (
          <a 
            href={`https://github.com/${member.social_links.github}`}
            target="_blank"
            rel="noopener noreferrer"
            className="flex items-center gap-2 px-3 py-2 glass-2 rounded-lg hover:glass-3 transition-all duration-200"
          >
            <Github className="w-4 h-4 text-white/90" />
            <span className="text-sm text-white/90 text-shadow-adaptive-sm">GitHub</span>
          </a>
        )}
        {member.social_links?.twitter && (
          <a 
            href={`https://twitter.com/${member.social_links.twitter}`}
            target="_blank"
            rel="noopener noreferrer"
            className="flex items-center gap-2 px-3 py-2 glass-2 rounded-lg hover:glass-3 transition-all duration-200"
          >
            <Twitter className="w-4 h-4 text-white/90" />
            <span className="text-sm text-white/90 text-shadow-adaptive-sm">Twitter</span>
          </a>
        )}
        {member.social_links?.discord && (
          <div className="flex items-center gap-2 px-3 py-2 glass-2 rounded-lg">
            <span className="text-sm">üí¨</span>
            <span className="text-sm text-white/90 text-shadow-adaptive-sm" title={`Discord: ${member.social_links.discord}`}>
              {member.social_links.discord}
            </span>
          </div>
        )}
        {member?.social_links?.website && (
          <a 
            href={member.social_links.website.startsWith('http') ? member.social_links.website : `https://${member.social_links.website}`}
            target="_blank"
            rel="noopener noreferrer"
            className="flex items-center gap-2 px-3 py-2 glass-2 rounded-lg hover:glass-3 transition-all duration-200"
          >
            <ExternalLink className="w-4 h-4 text-white/90" />
            <span className="text-sm text-white/90 text-shadow-adaptive-sm">Website</span>
          </a>
        )}
        {member?.social_links?.youtube && (
          <a 
            href={member.social_links.youtube}
            target="_blank"
            rel="noopener noreferrer"
            className="flex items-center gap-2 px-3 py-2 glass-2 rounded-lg hover:glass-3 transition-all duration-200"
          >
            <span className="text-sm">‚ñ∂</span>
            <span className="text-sm text-white/90 text-shadow-adaptive-sm">YouTube</span>
          </a>
        )}
        {member.osu_username && (
          <a 
            href={`https://osu.ppy.sh/users/${member.osu_username}`}
            target="_blank"
            rel="noopener noreferrer"
            className="flex items-center gap-2 px-3 py-2 glass-2 rounded-lg hover:glass-3 transition-all duration-200"
          >
            <ExternalLink className="w-4 h-4 text-white/90" />
            <span className="text-sm text-white/90 text-shadow-adaptive-sm">osu! Profile</span>
          </a>
        )}
      </div>
    );
  }, [member?.social_links, member?.osu_username]);

  const handleImageError = useCallback((e) => {
    e.target.onerror = null;
    e.target.src = `https://ui-avatars.com/api/?name=${encodeURIComponent(member?.name || '')}&background=9333ea&color=fff&size=256`;
  }, [member?.name]);

  if (!isVisible && animationPhase === 'exiting') return null;
  if (!member) return null;

  return (
    <>
      <div
        className={`
          fixed inset-0 z-50 flex items-center justify-center transition-all duration-300 will-change-transform
          ${isMobile ? 'p-4' : 'p-4'}
          ${animationPhase === 'expanded' ? 'bg-black/50 backdrop-blur-sm' : 'bg-transparent'}
        `}
        onClick={handleBackdropClick}
        onTouchStart={handleTouchStartCapture}
        onTouchMove={handleTouchMove}
      >
        <div
          ref={modalRef}
          className={`
            relative glass-2 rounded-3xl shadow-2xl overflow-hidden transition-all duration-300 ease-out will-change-transform
            ${isMobile 
              ? 'w-full max-w-sm max-h-[90vh] rounded-2xl' 
              : 'w-full max-w-2xl'
            }
          `}
          style={getTransformStyle}
        >
          {/* Mobile swipe indicator */}
          {isMobile && (
            <div className={`
              absolute top-2 left-1/2 transform -translate-x-1/2 w-8 h-1 bg-white/40 rounded-full
              transition-opacity duration-300
              ${animationPhase === 'expanded' ? 'opacity-100' : 'opacity-0'}
            `} />
          )}

          {/* Close Button */}
          <button
            onClick={handleClose}
            className={`
              absolute z-10 glass-2 hover:glass-3 rounded-full transition-all duration-200 hover:scale-110 text-white
              ${isMobile ? 'top-4 right-4 p-1.5' : 'top-6 right-6 p-2'}
              ${animationPhase === 'expanded' ? 'opacity-100' : 'opacity-0'}
            `}
          >
            <X className={`icon-shadow-adaptive-sm ${isMobile ? 'w-4 h-4' : 'w-5 h-5'}`} />
          </button>

          {/* Content */}
          <div className={`
            overflow-y-auto max-h-full
            ${isMobile ? 'pt-6 px-5 pb-5' : 'pt-8 px-8 pb-6'}
          `}>
            {/* Header */}
            <div className={`
              flex items-center mb-6
              ${isMobile ? 'gap-4 flex-col text-center' : 'gap-6'}
            `}>
              <div 
                onClick={handleAvatarClick}
                className={`
                  rounded-3xl overflow-hidden bg-white shadow-lg avatar-border
                  ${isMobile ? 'w-20 h-20 rounded-2xl' : 'w-24 h-24'}
                  cursor-pointer
                `}
              >
                <img
                  src={avatarUrl}
                  alt={member.name}
                  className="w-full h-full object-cover"
                  onError={handleImageError}
                  loading="lazy"
                />
              </div>
              <div className={isMobile ? 'text-center' : ''}>
                <h2 className={`
                  font-bold text-white mb-2 text-shadow-adaptive-lg
                  ${isMobile ? 'text-2xl' : 'text-3xl'}
                `}>
                  {member.name}
                </h2>
                <div className={roleBadgeClass}>
                  {member.role}
                </div>
              </div>
            </div>

            {/* Bio with Formatting Support */}
            <div 
              className={`
                transition-all duration-500 delay-100
                ${animationPhase === 'expanded' ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-4'}
              `}
            >
              {member.bio && (
                <>
                  <h3 className={`
                    font-semibold text-white mb-3 text-shadow-adaptive
                    ${isMobile ? 'text-base' : 'text-lg'}
                  `}>
                    About {member.name}
                  </h3>
                  
                  <div className={`
                    text-white/90 leading-relaxed text-shadow-adaptive-sm mb-4
                    ${isMobile ? 'text-sm' : 'text-base'}
                  `}>
                    <FormattedDescription 
                      text={member.bio} 
                      className="[&_strong]:text-white [&_em]:text-white/95 [&_a]:text-purple-300 [&_a:hover]:text-purple-200 [&_code]:bg-white/20 [&_code]:text-purple-200 [&_mark]:bg-yellow-400/30 [&_mark]:text-yellow-100"
                    />
                  </div>
                </>
              )}

              {/* Social Links */}
              {socialLinks}
            </div>
          </div>
        </div>
      </div>

      {/* ))) Panel */}
      {showJokeModal && createPortal(
        <div 
          className="fixed top-0 left-0 right-0 z-[100] p-4"
          style={{
            animation: jokeAnimating 
              ? 'slideUpSlow 4s ease-in forwards' 
              : 'slideDownSlow 4s ease-out forwards'
          }}
        >
                <style jsx>{`
            @keyframes slideDownSlow {
              from {
                transform: translateY(-100%);
                opacity: 0;
              }
              to {
                transform: translateY(0);
                opacity: 1;
              }
            }
            @keyframes slideUpSlow {
              from {
                transform: translateY(0);
                opacity: 1;
              }
              to {
                transform: translateY(-100%);
                opacity: 0;
              }
            }
          `}</style>
          
          <div 
            className="bg-white rounded-lg p-6 max-w-md mx-auto shadow-lg"
          >
            <p className="text-gray-800 text-center leading-relaxed">
              {joke}
            </p>
          </div>
        </div>,
        document.body
      )}
    </>
  );
});

export default ExpandedTeamModal;


================================================
FILE: frontend/components/Layout.js
================================================
import { useState, useEffect, useRef } from 'react';
import Link from 'next/link';
import { useRouter } from 'next/router';
import { useAuth } from '../lib/AuthContext';
import { useSettings } from '../lib/SettingsContext';
import { Trophy, User, LogIn, LogOut, BarChart3, Plus, Heart, Link2, X, Menu, Home, Settings, ChevronDown, MessageCircle, MoreHorizontal } from 'lucide-react';

export default function Layout({ children, backgroundImage = '/default-bg.png' }) {
  const { user, loading, isAdmin, signOut } = useAuth(); 
  const { backgroundStyle, loading: settingsLoading, isFromCache } = useSettings();
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
  const [profileDropdownOpen, setProfileDropdownOpen] = useState(false);
  const [moreDropdownOpen, setMoreDropdownOpen] = useState(false);
  const [hoveredItem, setHoveredItem] = useState(null);
  const [hoverTimeout, setHoverTimeout] = useState(null);
  const [showTooltip, setShowTooltip] = useState(false);
  const [tooltipVisible, setTooltipVisible] = useState(false);
  const [bgReady, setBgReady] = useState(false);
  const dropdownRef = useRef(null);
  const moreDropdownRef = useRef(null);
  const router = useRouter();

  // DEBUG LOGGING
  useEffect(() => {
    console.log('[Layout] Component mounted');
    console.log('[Layout] Browser:', navigator.userAgent);
    console.log('[Layout] Window size:', window.innerWidth, 'x', window.innerHeight);
    
    // Check if nav exists after render
    setTimeout(() => {
      const nav = document.querySelector('nav.hidden.md\\:flex');
      const navLinks = document.querySelectorAll('nav.hidden.md\\:flex a, nav.hidden.md\\:flex button');
      
      console.log('[Layout] Nav element exists:', !!nav);
      console.log('[Layout] Nav links found:', navLinks.length);
      
      if (nav) {
        const rect = nav.getBoundingClientRect();
        const styles = window.getComputedStyle(nav);
        console.log('[Layout] Nav dimensions:', rect.width, 'x', rect.height);
        console.log('[Layout] Nav position:', rect.left, rect.top);
        console.log('[Layout] Nav display:', styles.display);
        console.log('[Layout] Nav visibility:', styles.visibility);
        console.log('[Layout] Nav opacity:', styles.opacity);
      }
    }, 500);
  }, []);

  // Log auth state changes
  useEffect(() => {
    console.log('[Layout] Auth state - loading:', loading, 'user:', !!user, 'isAdmin:', isAdmin);
  }, [loading, user, isAdmin]);

  // Log settings state
  useEffect(() => {
    console.log('[Layout] Settings - loading:', settingsLoading, 'isFromCache:', isFromCache, 'bgReady:', bgReady);
  }, [settingsLoading, isFromCache, bgReady]);

  // Mark background as ready after settings load or immediately if from cache
  useEffect(() => {
    if (!settingsLoading || isFromCache) {
      setBgReady(true);
    }
  }, [settingsLoading, isFromCache]);

  // Close mobile menu when route changes
  useEffect(() => {
    setMobileMenuOpen(false);
    setMoreDropdownOpen(false);
  }, [router.pathname]);

  // Close dropdowns when clicking outside
  useEffect(() => {
    function handleClickOutside(event) {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setProfileDropdownOpen(false);
      }
      if (moreDropdownRef.current && !moreDropdownRef.current.contains(event.target)) {
        setMoreDropdownOpen(false);
      }
    }

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  // Handle hover logic for navigation items
  const handleMouseEnter = (itemHref) => {
    setHoveredItem(itemHref);
    setShowTooltip(false);
    setTooltipVisible(false);
    
    if (hoverTimeout) {
      clearTimeout(hoverTimeout);
    }
    
    const timeout = setTimeout(() => {
      setHoveredItem(currentHoveredItem => {
        if (currentHoveredItem === itemHref) {
          setShowTooltip(true);
          setTimeout(() => setTooltipVisible(true), 10);
        }
        return currentHoveredItem;
      });
    }, 10000);
    
    setHoverTimeout(timeout);
  };

  const handleMouseLeave = () => {
    setHoveredItem(null);
    setShowTooltip(false);
    setTooltipVisible(false);
    
    if (hoverTimeout) {
      clearTimeout(hoverTimeout);
      setHoverTimeout(null);
    }
  };

  // Clean up timeout on unmount
  useEffect(() => {
    return () => {
      if (hoverTimeout) {
        clearTimeout(hoverTimeout);
      }
    };
  }, [hoverTimeout]);

  const handleLogout = async () => {
    try {
      console.log('üö™ Starting logout...');
      await signOut();
      
      console.log('‚úÖ Logout completed');
      setProfileDropdownOpen(false);
      
      if (router.pathname !== '/') {
        router.push('/');
      }
      
    } catch (error) {
      console.error('üö® Logout error:', error);
      setProfileDropdownOpen(false);
      if (router.pathname !== '/') {
        router.push('/');
      }
    }
  };

  // Primary navigation items
  const primaryNavItems = [
    { href: '/', label: 'home', icon: Home },
    { href: '/challenges', label: 'challenges', icon: Trophy },
    { href: '/leaderboard', label: 'leaderboard', icon: BarChart3 },
  ];

  // Secondary navigation items
  const secondaryNavItems = [
    { href: '/donate', label: 'donate', icon: Heart },
    { href: '/partners', label: 'partners', icon: Link2 },
    { href: 'https://discord.com/invite/FbXx6uZpUg', label: 'discord', icon: MessageCircle, external: true },
  ];

  // All navigation items combined
  const allNavItems = [...primaryNavItems, ...secondaryNavItems];

  // Render a single nav item
  const renderNavItem = (item, inDropdown = false) => {
    const isActive = router.pathname === item.href;
    
    if (inDropdown) {
      // Dropdown item styling
      if (item.external) {
        return (
          <a
            key={item.href}
            href={item.href}
            target="_blank"
            rel="noopener noreferrer"
            className="w-full px-5 py-3 text-left hover:bg-white/10 transition-colors flex items-center gap-3 text-white/90 hover:text-white"
            onClick={() => setMoreDropdownOpen(false)}
          >
            <item.icon className="w-4 h-4" />
            <span className="font-medium text-sm text-shadow-adaptive-lg">{item.label}</span>
          </a>
        );
      }
      return (
        <Link
          key={item.href}
          href={item.href}
          prefetch={false}
          className="w-full px-5 py-3 text-left hover:bg-white/10 transition-colors flex items-center gap-3 text-white/90 hover:text-white"
          onClick={() => setMoreDropdownOpen(false)}
        >
          <item.icon className="w-4 h-4" />
          <span className="font-medium text-sm text-shadow-adaptive-lg">{item.label}</span>
        </Link>
      );
    }

    // Inline nav pill styling
    if (item.external) {
      return (
        <a 
          key={item.href}
          href={item.href}
          target="_blank"
          rel="noopener noreferrer"
          className="nav-pill-inactive text-shadow-adaptive-sm hover:nav-pill-active relative"
          onMouseEnter={() => handleMouseEnter(item.href)}
          onMouseLeave={handleMouseLeave}
        >
          <div className="flex items-center gap-2">
            <item.icon className="w-4 h-4 icon-shadow-adaptive-sm" />
            {item.label}
          </div>
          
          {/* Tooltip */}
          {hoveredItem === item.href && showTooltip && (
            <div 
              className={`absolute top-full mt-2 left-1/2 transform -translate-x-1/2 z-50 transition-all duration-300 ease-out ${
                tooltipVisible ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-2'
              }`}
            >
              <div className="glass-3 rounded-lg px-3 py-2 text-sm text-white font-medium text-shadow-adaptive-sm whitespace-nowrap">
                Just click bro
                <div className="absolute -top-1 left-1/2 transform -translate-x-1/2 w-2 h-2 glass-3 rotate-45"></div>
              </div>
            </div>
          )}
        </a>
      );
    }

    return (
      <Link 
        key={item.href}
        href={item.href}
        prefetch={false}
        className={
          isActive 
            ? 'nav-pill-active text-shadow-adaptive-sm relative'
            : 'nav-pill-inactive text-shadow-adaptive-sm relative'
        }
        onMouseEnter={() => handleMouseEnter(item.href)}
        onMouseLeave={handleMouseLeave}
      >
        <div className="flex items-center gap-2">
          <item.icon className="w-4 h-4 icon-shadow-adaptive-sm" />
          {item.label}
        </div>
        
        {/* Tooltip */}
        {hoveredItem === item.href && showTooltip && (
          <div className={`absolute top-full mt-2 left-1/2 transform -translate-x-1/2 z-50 transition-all duration-300 ease-out ${
              tooltipVisible ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-2'
            }`}>
            <div className="glass-3 rounded-lg px-3 py-2 text-sm text-white font-medium text-shadow-adaptive-sm whitespace-nowrap">
              Just click bro
              <div className="absolute -top-1 left-1/2 transform -translate-x-1/2 w-2 h-2 glass-3 rotate-45"></div>
            </div>
          </div>
        )}
      </Link>
    );
  };

  return (
    <div className="min-h-screen relative">
      {/* Background image layer with smooth transition */}
      <div 
        className={`bg-fixed-mobile -z-20 transition-opacity duration-500 ${bgReady ? 'opacity-100' : 'opacity-0'}`}
        style={backgroundStyle}
      />
      
      {/* Header with grid pattern AND Christmas lights */}
      <header className="relative z-40 overflow-visible">
        {/* Grid pattern with fade AND Christmas lights */}
        <div className="absolute inset-0">
          <svg className="absolute inset-0 w-full h-full" xmlns="http://www.w3.org/2000/svg">
            <defs>
              {/* Glow filter for the grid lines */}
              <filter id="gridGlow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation="0.8" result="coloredBlur"/>
                <feMerge> 
                  <feMergeNode in="coloredBlur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
              
              {/* Gradient mask that makes grid lines fade from top to bottom */}
              <linearGradient id="gridFade" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style={{stopColor: 'white', stopOpacity: 1}} />
                <stop offset="70%" style={{stopColor: 'white', stopOpacity: 0.3}} />
                <stop offset="100%" style={{stopColor: 'white', stopOpacity: 0}} />
              </linearGradient>
              
              <mask id="fadeMask">
                <rect width="100%" height="100%" fill="url(#gridFade)" />
              </mask>
              
              {/* Regular grid pattern - every line */}
              <pattern id="grid" width="24" height="24" patternUnits="userSpaceOnUse" patternTransform="translate(12, 12)">
                <path d="M 24 0 L 0 0 0 24" fill="none" stroke="white" strokeWidth="0.5" opacity="0.6" filter="url(#gridGlow)"/>
              </pattern>
              
              {/* Thicker grid pattern - every 5th line with offset */}
              <pattern id="thickGrid" width="120" height="120" patternUnits="userSpaceOnUse" patternTransform="translate(12, 12)">
                <path d="M 120 0 L 0 0 0 120" fill="none" stroke="white" strokeWidth="1.5" opacity="0.4" filter="url(#gridGlow)"/>
              </pattern>

              {/* Christmas light glow filters */}
              <filter id="lightGlowRed" x="-100%" y="-100%" width="300%" height="300%">
                <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                <feMerge>
                  <feMergeNode in="coloredBlur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>

              <filter id="lightGlowGreen" x="-100%" y="-100%" width="300%" height="300%">
                <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                <feMerge>
                  <feMergeNode in="coloredBlur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>

              <filter id="lightGlowGold" x="-100%" y="-100%" width="300%" height="300%">
                <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                <feMerge>
                  <feMergeNode in="coloredBlur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
            </defs>
            
            {/* Layer the regular grid first, then the thick grid on top */}
            <rect width="100%" height="100%" fill="url(#grid)" mask="url(#fadeMask)" />
            <rect width="100%" height="100%" fill="url(#thickGrid)" mask="url(#fadeMask)" />
          </svg>
        </div>

        <div className="max-w-7xl mx-auto px-4 py-4 relative">
          <div className="flex items-center justify-between">
            <Link 
              href="/"
              prefetch={false}
              className="flex items-center gap-3 hover:opacity-80 transition-opacity"
            >
              {/* Replace with your PNG logo */}
              <img 
                src="/logo.png" 
                alt="osu!Challengers Nexus"
                className="h-10 md:h-12 lg:h-16"
                onError={(e) => {
                  // Fallback to text if logo doesn't load
                  e.target.style.display = 'none';
                  e.target.nextSibling.style.display = 'block';
                }}
              />
              <div style={{ display: 'none' }}>
                <h1 className="text-lg md:text-xl font-bold text-white text-shadow-adaptive">
                  osu!Challengers
                </h1>
                <p className="text-xs text-white/70 text-shadow-adaptive-sm">Nexus</p>
              </div>
            </Link>

            {/* Desktop Navigation */}
            <nav className="hidden md:flex flex-1 items-center justify-center gap-1 lg:gap-2 relative">
              {/* Primary nav items - always visible on md+ */}
              {primaryNavItems.map((item) => {
                console.log('[Layout] Rendering nav item:', item.label);
                return renderNavItem(item);
              })}

              {/* Secondary nav items - only visible on xl+ */}
              <div className="hidden xl:contents">
                {secondaryNavItems.map((item) => {
                  console.log('[Layout] Rendering nav item:', item.label);
                  return renderNavItem(item);
                })}
              </div>

              {/* "More" dropdown - only visible on md to xl */}
              <div className="xl:hidden relative" ref={moreDropdownRef}>
                <button
                  onClick={() => setMoreDropdownOpen(!moreDropdownOpen)}
                  className={`nav-pill-more text-shadow-adaptive-sm flex items-center gap-2 ${moreDropdownOpen ? 'nav-pill-more-active' : ''}`}
                >
                  <MoreHorizontal className="w-4 h-4 icon-shadow-adaptive-sm" />
                  <span>more</span>
                  <ChevronDown className={`w-3 h-3 transition-transform ${moreDropdownOpen ? 'rotate-180' : ''}`} />
                </button>

                {/* More Dropdown */}
                {moreDropdownOpen && (
                  <div className="absolute top-full right-0 w-48 mt-2 season-dropdown rounded-2xl shadow-lg z-[100] backdrop-blur-lg overflow-hidden">
                    {secondaryNavItems.map((item, index) => (
                      <div 
                        key={item.href}
                        className={index < secondaryNavItems.length - 1 ? 'border-b border-white/10' : ''}
                      >
                        {renderNavItem(item, true)}
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </nav>

            {/* Auth Section */}
            <div className="hidden md:block">
              {loading ? (
                <div className="px-5 py-2.5 text-white/50 text-shadow-adaptive-sm">Loading...</div>
              ) : !user ? (
                <Link 
                  href="/api/auth/login"
                  prefetch={false}
                  className="btn-primary text-shadow-adaptive-sm flex items-center gap-2"
                >
                  <LogIn className="w-4 h-4 icon-shadow-adaptive-sm" />
                  log in with osu!
                </Link>
              ) : (
                <div className="relative" ref={dropdownRef}>
                  <button
                    onClick={() => setProfileDropdownOpen(!profileDropdownOpen)}
                    className="flex items-center gap-2 px-4 py-2 rounded-full backdrop-blur-md bg-white/15 hover:bg-white/20 transition-all duration-300 border-2 border-white/20 hover:border-white/30"
                  >
                    {user.avatar_url ? (
                      <img 
                        src={user.avatar_url} 
                        alt={user.username}
                        className="w-8 h-8 rounded-full ring-2 ring-white/30"
                      />
                    ) : (
                      <div className="w-8 h-8 bg-gradient-primary rounded-full flex items-center justify-center text-white">
                        <User className="w-4 h-4" />
                      </div>
                    )}
                    <div className="hidden lg:flex flex-col text-left">
                      <span className="text-sm font-medium text-white text-shadow-adaptive-sm leading-tight">
                        {user.username}
                      </span>
                      {isAdmin && (
                        <span className="text-xs text-primary-300 text-shadow-adaptive-sm leading-tight">
                          Admin
                        </span>
                      )}
                    </div>
                    <ChevronDown className={`w-4 h-4 text-white/70 transition-transform ${profileDropdownOpen ? 'rotate-180' : ''}`} />
                  </button>

                  {/* Profile Dropdown */}
                  {profileDropdownOpen && (
                    <div className="absolute top-full right-0 w-56 mt-2 season-dropdown rounded-2xl shadow-lg z-[100] backdrop-blur-lg">
                      <Link
                        href={`/profile/${user.id}`}
                        prefetch={false}
                        className="w-full px-5 py-3 text-left hover:bg-white/10 transition-colors border-b border-white/10 first:rounded-t-2xl flex items-center gap-3 text-white/90 hover:text-white"
                        onClick={() => setProfileDropdownOpen(false)}
                      >
                        <User className="w-4 h-4" />
                        <span className="font-medium text-sm text-shadow-adaptive-lg">View Profile</span>
                      </Link>
                      
                      {/* Settings Link */}
                      <Link
                        href="/settings"
                        prefetch={false}
                        className="w-full px-5 py-3 text-left hover:bg-white/10 transition-colors border-b border-white/10 flex items-center gap-3 text-white/90 hover:text-white"
                        onClick={() => setProfileDropdownOpen(false)}
                      >
                        <Settings className="w-4 h-4" />
                        <span className="font-medium text-sm text-shadow-adaptive-lg">Settings</span>
                      </Link>
                      
                      {isAdmin && (
                        <Link
                          href="/admin"
                          prefetch={false}
                          className="w-full px-5 py-3 text-left hover:bg-white/10 transition-colors border-b border-white/10 flex items-center gap-3 text-white/90 hover:text-white"
                          onClick={() => setProfileDropdownOpen(false)}
                        >
                          <Plus className="w-4 h-4" />
                          <span className="font-medium text-sm text-shadow-adaptive-lg">Admin</span>
                        </Link>
                      )}

                      <button
                        onClick={handleLogout}
                        className="w-full px-5 py-3 text-left hover:bg-white/10 transition-colors last:rounded-b-2xl flex items-center gap-3 text-white/90 hover:text-white"
                      >
                        <LogOut className="w-4 h-4" />
                        <span className="font-medium text-sm text-shadow-adaptive-lg">Logout</span>
                      </button>
                    </div>
                  )}
                </div>
              )}
            </div>

            {/* Mobile Navigation */}
            <div className="md:hidden flex items-center gap-2">
              {/* User Avatar on Mobile */}
              {user && (
                <div className="flex items-center gap-2">
                  {user.avatar_url ? (
                    <img 
                      src={user.avatar_url} 
                      alt={user.username}
                      className="w-8 h-8 rounded-full ring-2 ring-white/30"
                    />
                  ) : (
                    <div className="w-8 h-8 bg-gradient-primary rounded-full flex items-center justify-center text-white">
                      <User className="w-4 h-4" />
                    </div>
                  )}
                </div>
              )}

              {/* Mobile Menu Button */}
              <button
                onClick={() => setMobileMenuOpen(!mobileMenuOpen)}
                className="p-2 text-white/70 hover:text-white transition-colors"
                aria-label="Toggle menu"
              >
                {mobileMenuOpen ? (
                  <X className="w-6 h-6 icon-shadow-adaptive-sm" />
                ) : (
                  <Menu className="w-6 h-6 icon-shadow-adaptive-sm" />
                )}
              </button>
            </div>
          </div>
        </div>

        {/* Mobile Menu Overlay */}
        {mobileMenuOpen && (
          <div className="md:hidden fixed inset-0 z-50 bg-black/50 backdrop-blur-sm">
            <div className="absolute top-0 right-0 w-72 h-full bg-black/90 backdrop-blur-md border-l border-white/10">
              {/* Mobile Menu Header */}
              <div className="flex items-center justify-between p-4 border-b border-white/10">
                <div className="flex items-center gap-3">
                  <img 
                    src="/logo.png" 
                    alt="osu!Challengers Nexus"
                    className="h-8 icon-shadow-adaptive"
                    onError={(e) => {
                      e.target.style.display = 'none';
                      e.target.nextSibling.style.display = 'block';
                    }}
                  />
                  <div style={{ display: 'none' }}>
                    <h2 className="text-lg font-bold text-white text-shadow-adaptive">
                      osu!Challengers
                    </h2>
                  </div>
                </div>
                <button
                  onClick={() => setMobileMenuOpen(false)}
                  className="p-2 text-white/70 hover:text-white transition-colors"
                >
                  <X className="w-6 h-6" />
                </button>
              </div>

              {/* Mobile Menu Content */}
              <div className="p-4 space-y-2">
                {/* Navigation Items - all items for mobile */}
                {allNavItems.map((item) => (
                item.external ? (
                  <a 
                    key={item.href}
                    href={item.href}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="flex items-center gap-3 px-4 py-3 rounded-lg transition-all duration-200 text-base text-white/80 hover:bg-white/10 hover:text-white"
                  >
                    <item.icon className="w-5 h-5 icon-shadow-adaptive-sm" />
                    {item.label}
                  </a>
                ) : (
                  <Link 
                    key={item.href}
                    href={item.href}
                    prefetch={false}
                    className={`
                      flex items-center gap-3 px-4 py-3 rounded-lg transition-all duration-200 text-base
                      ${router.pathname === item.href 
                        ? 'bg-white/20 text-white border border-white/20' 
                        : 'text-white/80 hover:bg-white/10 hover:text-white'
                      }
                    `}
                  >
                    <item.icon className="w-5 h-5 icon-shadow-adaptive-sm" />
                    {item.label}
                  </Link>
                )
                ))}

                {/* Divider */}
                <div className="border-t border-white/10 my-4"></div>

                {/* Auth Section */}
                {loading ? (
                  <div className="px-4 py-3 text-white/50 text-base">Loading...</div>
                ) : !user ? (
                  <Link 
                    href="/api/auth/login"
                    prefetch={false}
                    className="flex items-center gap-3 px-4 py-3 bg-gradient-primary rounded-lg text-white font-medium transition-all duration-200 hover:opacity-90"
                  >
                    <LogIn className="w-5 h-5" />
                    log in with osu!
                  </Link>
                ) : (
                  <div className="space-y-3">
                    {/* User Info */}
                    <div className="flex items-center gap-3 px-4 py-3 bg-white/5 rounded-lg">
                      {user.avatar_url ? (
                        <img 
                          src={user.avatar_url} 
                          alt={user.username}
                          className="w-10 h-10 rounded-full ring-2 ring-white/30"
                        />
                      ) : (
                        <div className="w-10 h-10 bg-gradient-primary rounded-full flex items-center justify-center text-white">
                          <User className="w-5 h-5" />
                        </div>
                      )}
                      <div>
                        <div className="text-white font-medium text-shadow-adaptive-sm">
                          {user.username}
                        </div>
                        {isAdmin && (
                          <div className="text-xs text-primary-300 text-shadow-adaptive-sm">
                            Admin
                          </div>
                        )}
                      </div>
                    </div>

                    {/* Profile Actions */}
                    <Link 
                      href={`/profile/${user.id}`}
                      prefetch={false}
                      className="flex items-center gap-3 px-4 py-3 w-full text-left text-white/80 hover:bg-white/10 hover:text-white transition-all duration-200 rounded-lg"
                    >
                      <User className="w-5 h-5 icon-shadow-adaptive-sm" />
                      view profile
                    </Link>

                    {/* Settings Link for Mobile */}
                    <Link 
                      href="/settings"
                      prefetch={false}
                      className="flex items-center gap-3 px-4 py-3 w-full text-left text-white/80 hover:bg-white/10 hover:text-white transition-all duration-200 rounded-lg"
                    >
                      <Settings className="w-5 h-5 icon-shadow-adaptive-sm" />
                      settings
                    </Link>

                    {/* Admin Link */}
                    {isAdmin && (
                      <Link 
                        href="/admin"
                        prefetch={false}
                        className="flex items-center gap-3 px-4 py-3 w-full text-left text-white/80 hover:bg-white/10 hover:text-white transition-all duration-200 rounded-lg"
                      >
                        <Plus className="w-5 h-5 icon-shadow-adaptive-sm" />
                        admin
                      </Link>
                    )}

                    {/* Logout Button */}
                    <button
                      onClick={handleLogout}
                      className="flex items-center gap-3 px-4 py-3 w-full text-left text-white/80 hover:bg-white/10 hover:text-white transition-all duration-200 rounded-lg"
                    >
                      <LogOut className="w-5 h-5 icon-shadow-adaptive-sm" />
                      logout
                    </button>
                  </div>
                )}
              </div>
            </div>
          </div>
        )}
      </header>

      {/* Main Content */}
      <main className="relative z-10">{children}</main>

      {/* Footer */}
      <footer className="mt-20 py-8">
        <div className="max-w-7xl mx-auto px-4 text-center">
          <p className="font-medium text-white text-shadow-adaptive text-sm md:text-base">
            osu!Challengers Nexus - Track your progress across our community challenges!
          </p>
          <p className="mt-2 text-white/90 text-shadow-adaptive-sm text-xs md:text-sm">
            Not affiliated with osu! or ppy Pty Ltd
          </p>
        </div>
      </footer>
    </div>
  );
}


================================================
FILE: frontend/components/Loading.js
================================================
import React from 'react';
import { Loader2, Sparkles } from 'lucide-react';

const LoadingSpinner = ({ 
  message = "Loading...", 
  size = "large", 
  className = "",
  showMessage = true,
  variant = "default" // default, purple, blue, green
}) => {
  const sizeClasses = {
    small: "h-6 w-6 border-2",
    medium: "h-8 w-8 border-3", 
    large: "h-12 w-12 border-4",
    xlarge: "h-16 w-16 border-4"
  };

  const textSizeClasses = {
    small: "text-xs",
    medium: "text-sm", 
    large: "text-base",
    xlarge: "text-lg"
  };

  const spinnerVariants = {
    default: "border-white/30 border-t-white border-b-white",
    purple: "border-white/30 border-t-purple-400 border-b-pink-400",
    blue: "border-white/30 border-t-blue-400 border-b-cyan-400",
    green: "border-white/30 border-t-emerald-400 border-b-green-400"
  };

  return (
    <div className={`text-center ${className}`}>
      <div 
        className={`animate-spin rounded-full mx-auto mb-3 sm:mb-4 ${sizeClasses[size]} ${spinnerVariants[variant]} icon-shadow-adaptive transition-all duration-300`}
        style={{
          filter: 'drop-shadow(0 0 8px rgba(255, 255, 255, 0.3))'
        }}
      />
      {showMessage && (
        <p className={`text-white/90 font-medium text-shadow-adaptive-sm ${textSizeClasses[size]} transition-all duration-300`}>
          {message}
        </p>
      )}
    </div>
  );
};

// Full page loading component - glass card removed, only background animation
const FullPageLoading = ({ message = "Loading...", showLogo = false }) => {
  return (
    <div className="min-h-screen flex items-center justify-center relative">
      
      <div className="max-w-md w-full mx-4">
        {showLogo && (
          <div className="flex items-center justify-center gap-3 mb-6">
            <Sparkles className="w-8 h-8 text-purple-400 icon-shadow-adaptive animate-pulse" />
            <h2 className="text-2xl font-bold text-white text-shadow-adaptive">osu!Challengers</h2>
          </div>
        )}
        <LoadingSpinner message={message} size="large" variant="purple" />
      </div>
    </div>
  );
};

// Section loading component - glass card removed
const SectionLoading = ({ 
  message = "Loading...", 
  className = "",
  variant = "default",
  compact = false 
}) => {
  return (
    <div className={`flex items-center justify-center ${compact ? 'py-8' : 'py-12'} ${className}`}>
      <LoadingSpinner 
        message={message} 
        size="medium" 
        variant={variant}
      />
    </div>
  );
};

// Inline loading component - glass cards removed
const InlineLoading = ({ 
  message = "", 
  size = "small", 
  className = "",
  variant = "default",
  minimal = false 
}) => {
  if (minimal) {
    return (
      <div className={`flex items-center justify-center gap-2 ${className}`}>
        <Loader2 className="w-4 h-4 animate-spin text-white/80 icon-shadow-adaptive-sm" />
        {message && (
          <span className="text-white/90 text-sm font-medium text-shadow-adaptive-sm">
            {message}
          </span>
        )}
      </div>
    );
  }

  return (
    <div className={`flex items-center justify-center ${className}`}>
      <LoadingSpinner 
        message={message} 
        size={size} 
        showMessage={!!message}
        variant={variant}
      />
    </div>
  );
};

// Skeleton loading - keeping glass card as it's content placeholder
const SkeletonLoading = ({ 
  lines = 3, 
  className = "",
  showAvatar = false,
  showTitle = true 
}) => {
  return (
    <div className={`glass-1 rounded-2xl p-6 animate-pulse ${className}`}>
      <div className="flex items-start gap-4 mb-4">
        {showAvatar && (
          <div className="w-12 h-12 bg-white/20 rounded-full flex-shrink-0"></div>
        )}
        <div className="flex-1 space-y-3">
          {showTitle && (
            <div className="h-4 bg-white/20 rounded w-1/3"></div>
          )}
          {[...Array(lines)].map((_, i) => (
            <div 
              key={i} 
              className="h-3 bg-white/15 rounded"
              style={{ width: `${Math.random() * 40 + 60}%` }}
            />
          ))}
        </div>
      </div>
    </div>
  );
};

// Card grid skeleton - keeping glass cards as they represent content placeholders
const CardGridSkeleton = ({ 
  cards = 6, 
  columns = 3,
  className = "" 
}) => {
  const gridCols = {
    1: 'grid-cols-1',
    2: 'grid-cols-1 sm:grid-cols-2',
    3: 'grid-cols-1 sm:grid-cols-2 lg:grid-cols-3',
    4: 'grid-cols-1 sm:grid-cols-2 lg:grid-cols-4'
  };

  return (
    <div className={`grid ${gridCols[columns]} gap-4 sm:gap-6 ${className}`}>
      {[...Array(cards)].map((_, i) => (
        <div key={i} className="glass-1 rounded-2xl p-6 animate-pulse">
          <div className="space-y-4">
            <div className="w-12 h-12 bg-white/20 rounded-xl mx-auto"></div>
            <div className="h-4 bg-white/20 rounded w-2/3 mx-auto"></div>
            <div className="h-3 bg-white/15 rounded w-1/2 mx-auto"></div>
          </div>
        </div>
      ))}
    </div>
  );
};

// Table skeleton - keeping glass card as it represents content placeholder
const TableSkeleton = ({ 
  rows = 8, 
  columns = 4,
  className = "" 
}) => {
  return (
    <div className={`glass-1 rounded-2xl overflow-hidden ${className}`}>
      <div className="glass-2 p-4 border-b border-white/10">
        <div className="grid grid-cols-4 gap-4">
          {[...Array(columns)].map((_, i) => (
            <div key={i} className="h-4 bg-white/20 rounded"></div>
          ))}
        </div>
      </div>
      <div className="p-4 space-y-3">
        {[...Array(rows)].map((_, i) => (
          <div key={i} className="grid grid-cols-4 gap-4 items-center py-2">
            <div className="flex items-center gap-3">
              <div className="w-8 h-8 bg-white/20 rounded-full"></div>
              <div className="h-3 bg-white/15 rounded w-20"></div>
            </div>
            {[...Array(columns - 1)].map((_, j) => (
              <div key={j} className="h-3 bg-white/15 rounded w-16"></div>
            ))}
          </div>
        ))}
      </div>
    </div>
  );
};

// Export individual components and main Loading object
export { 
  LoadingSpinner, 
  FullPageLoading, 
  SectionLoading, 
  InlineLoading,
  SkeletonLoading,
  CardGridSkeleton,
  TableSkeleton
};

export default {
  Spinner: LoadingSpinner,
  FullPage: FullPageLoading,
  Section: SectionLoading,
  Inline: InlineLoading,
  Skeleton: SkeletonLoading,
  CardGrid: CardGridSkeleton,
  Table: TableSkeleton
};


================================================
FILE: frontend/components/MedalsDisplay.js
================================================
import React, { useMemo } from 'react';
import { Trophy, Star, Crown, Medal, Award, Sparkles, Target, Flame } from 'lucide-react';

// Medal definitions
const MEDAL_DEFINITIONS = {
  // Achievement medals
  first_victory: {
    name: 'First Victory',
    description: 'Win your first challenge',
    category: 'achievement',
    icon: Trophy,
    color: 'from-green-400 to-emerald-500',
    check: (stats) => (stats.firstPlaceCount || 0) >= 1
  },
  challenger: {
    name: 'Challenger', 
    description: 'Win 3 challenges',
    category: 'achievement',
    icon: Trophy,
    color: 'from-cyan-400 to-blue-500',
    check: (stats) => (stats.firstPlaceCount || 0) >= 3
  },
  gladiator: {
    name: 'Gladiator',
    description: 'Win 10 challenges', 
    category: 'achievement',
    icon: Trophy,
    color: 'from-pink-400 to-purple-500',
    check: (stats) => (stats.firstPlaceCount || 0) >= 10
  },
  
  // Streak medals
  consistent: {
    name: 'Consistent',
    description: 'Achieve a 7 challenge streak',
    category: 'streak',
    icon: Flame,
    color: 'from-orange-400 to-red-500',
    check: (stats, streaks) => (streaks?.longestStreak || 0) >= 7
  },
  dedicated: {
    name: 'Dedicated',
    description: 'Achieve a 14 challenge streak',
    category: 'streak',
    icon: Flame, 
    color: 'from-red-400 to-pink-500',
    check: (stats, streaks) => (streaks?.longestStreak || 0) >= 14
  },
  
  // Performance medals
  perfectionist: {
    name: 'Perfectionist',
    description: 'Achieve 100% accuracy',
    category: 'performance',
    icon: Target,
    color: 'from-yellow-400 to-orange-500',
    check: (stats, streaks, scores) => scores?.some(s => s.accuracy === 100) || false
  },
  top_performer: {
    name: 'Top Performer',
    description: 'Achieve 95%+ average accuracy',
    category: 'performance', 
    icon: Star,
    color: 'from-pink-400 to-purple-500',
    check: (stats) => (stats.avgAccuracy || 0) >= 95
  },
  
  // Participation medals
  active_player: {
    name: 'Active Player',
    description: 'Play 50+ maps',
    category: 'participation',
    icon: Medal,
    color: 'from-green-400 to-emerald-500', 
    check: (stats) => (stats.totalScores || 0) >= 50
  },
  veteran: {
    name: 'Veteran',
    description: 'Play 200+ maps',
    category: 'participation',
    icon: Medal,
    color: 'from-cyan-400 to-blue-500',
    check: (stats) => (stats.totalScores || 0) >= 200
  }
};

const TITLE_DEFINITIONS = {
  champion: {
    name: 'Champion',
    description: 'Current #1 player',
    category: 'seasonal',
    temporary: true,
    icon: Crown,
    color: 'from-yellow-400 to-orange-500',
    check: (stats, streaks, scores, seasonRank) => seasonRank === 1
  },
  rising_star: {
    name: 'Rising Star', 
    description: 'Top 10% this season',
    category: 'seasonal',
    temporary: true,
    icon: Star,
    color: 'from-purple-400 to-pink-500', 
    check: (stats, streaks, scores, seasonRank, seasonPercentile) => (seasonPercentile || 0) >= 90
  }
};

const MedalsDisplay = ({ stats, streaks, scores, userAchievements, seasonRank, seasonPercentile }) => {
  // Calculate earned medals client-side using existing data
  const earnedMedals = useMemo(() => {
    const earned = [];
    
    Object.entries(MEDAL_DEFINITIONS).forEach(([code, medal]) => {
      if (medal.check(stats, streaks, scores, seasonRank, seasonPercentile)) {
        earned.push({
          code,
          ...medal,
          earned_at: userAchievements?.find(a => a.achievement_code === code)?.earned_at || new Date()
        });
      }
    });
    
    return earned.sort((a, b) => new Date(b.earned_at) - new Date(a.earned_at));
  }, [stats, streaks, scores, userAchievements, seasonRank, seasonPercentile]);

  const earnedTitles = useMemo(() => {
    const earned = [];
    
    Object.entries(TITLE_DEFINITIONS).forEach(([code, title]) => {
      if (title.check(stats, streaks, scores, seasonRank, seasonPercentile)) {
        earned.push({
          code, 
          ...title,
          earned_at: userAchievements?.find(a => a.achievement_code === code)?.earned_at || new Date()
        });
      }
    });
    
    return earned;
  }, [stats, streaks, scores, userAchievements, seasonRank, seasonPercentile]);

  const categories = [
    { id: 'all', name: 'All', icon: Medal },
    { id: 'achievement', name: 'Achievement', icon: Trophy },
    { id: 'streak', name: 'Streak', icon: Flame },
    { id: 'performance', name: 'Performance', icon: Target },
    { id: 'participation', name: 'Participation', icon: Sparkles }
  ];

  const [selectedCategory, setSelectedCategory] = React.useState('all');

  const filteredMedals = earnedMedals.filter(medal => 
    selectedCategory === 'all' || medal.category === selectedCategory
  );

  return (
    <div className="space-y-6 sm:space-y-8">
      {/* Current Title */}
      {earnedTitles.length > 0 && (
        <div className="glass-1 rounded-2xl sm:rounded-3xl p-4 sm:p-6 shadow-lg">
          <h3 className="text-lg sm:text-2xl font-bold text-white mb-4 flex items-center gap-3 text-shadow-adaptive">
            <Crown className="w-6 h-6 sm:w-8 sm:h-8 text-yellow-400 icon-shadow-adaptive" />
            Current Title
          </h3>
          <div className="flex items-center gap-4 p-4 sm:p-6 glass-2 rounded-xl sm:rounded-2xl border border-yellow-400/30">
            <div className="w-12 h-12 sm:w-16 sm:h-16 bg-gradient-to-b from-yellow-400 to-orange-500 rounded-xl flex items-center justify-center">
              <Crown className="w-6 h-6 sm:w-8 sm:h-8 text-white" />
            </div>
            <div className="flex-1">
              <h4 className="text-lg sm:text-xl font-bold text-white text-shadow-adaptive">
                {earnedTitles[0].name}
              </h4>
              <p className="text-sm sm:text-base text-white/80 text-shadow-adaptive-sm">
                {earnedTitles[0].description}
              </p>
            </div>
          </div>
        </div>
      )}

      {/* Medals */}
      <div className="glass-1 rounded-2xl sm:rounded-3xl p-4 sm:p-8 shadow-lg">
        <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4 mb-6">
          <h3 className="text-lg sm:text-2xl font-bold text-white flex items-center gap-3 text-shadow-adaptive">
            <Medal className="w-6 h-6 sm:w-8 sm:h-8 text-white/90 icon-shadow-adaptive" />
            Medals ({earnedMedals.length})
          </h3>
          
          {/* Category Filter */}
          <div className="flex gap-2 overflow-x-auto pb-2 sm:pb-0">
            {categories.map((category) => {
              const Icon = category.icon;
              const isActive = selectedCategory === category.id;
              return (
                <button
                  key={category.id}
                  onClick={() => setSelectedCategory(category.id)}
                  className={`px-3 py-2 rounded-lg font-medium text-sm whitespace-nowrap transition-all flex items-center gap-2 ${
                    isActive 
                      ? 'bg-white/20 text-white shadow-lg' 
                      : 'glass-1 text-white/90 hover:text-white hover:glass-2'
                  }`}
                >
                  <Icon className="w-4 h-4" />
                  <span className="hidden sm:inline">{category.name}</span>
                </button>
              );
            })}
          </div>
        </div>

        {filteredMedals.length === 0 ? (
          <div className="text-center py-8 sm:py-12">
            <div className="w-16 h-16 sm:w-24 sm:h-24 bg-gradient-to-b from-gray-500/30 to-gray-600/30 rounded-full flex items-center justify-center mx-auto mb-4 sm:mb-6 glass-3">
              <Medal className="w-8 h-8 sm:w-12 sm:h-12 text-gray-400 icon-shadow-adaptive" />
            </div>
            <h4 className="text-lg sm:text-xl font-bold text-white/80 mb-2 text-shadow-adaptive">
              No Medals Yet
            </h4>
            <p className="text-sm sm:text-base text-white/60 text-shadow-adaptive-sm">
              Keep playing to earn your first medal!
            </p>
          </div>
        ) : (
          <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-3 sm:gap-4">
            {filteredMedals.map((medal) => {
              const Icon = medal.icon;
              return (
                <div
                  key={medal.code}
                  className="group relative p-4 sm:p-6 glass-2 rounded-xl sm:rounded-2xl"
                >
                  <div className={`w-12 h-12 sm:w-16 sm:h-16 bg-gradient-to-b ${medal.color} rounded-xl sm:rounded-2xl flex items-center justify-center mx-auto mb-3 sm:mb-4 shadow-lg`}>
                    <Icon className="w-6 h-6 sm:w-8 sm:h-8 text-white" />
                  </div>
                  
                  <div className="text-center">
                    <h4 className="font-bold text-white text-sm sm:text-base mb-1 text-shadow-adaptive">
                      {medal.name}
                    </h4>
                    <p className="text-xs sm:text-sm text-white/90 text-shadow-adaptive-sm line-clamp-2">
                      {medal.description}
                    </p>
                  </div>
                </div>
              );
            })}
          </div>
        )}
      </div>
    </div>
  );
};

export default MedalsDisplay;


================================================
FILE: frontend/components/ModSelector.js
================================================
import { useState, useEffect } from 'react';
import { X, Settings, Info, Check, AlertTriangle } from 'lucide-react';
import { OSU_MODS, CONFLICTING_MODS, SETTING_CONFIGS } from '../lib/osu-mods-reference';

export default function ModSelector({ selectedMods = [], onChange, matchType = 'exact' }) {
  const [conflicts, setConflicts] = useState([]);
  const [showSettings, setShowSettings] = useState({});

  useEffect(() => {
    checkConflicts();
  }, [selectedMods]);

  const checkConflicts = () => {
    const modAcronyms = selectedMods.map(mod => mod.acronym);
    const foundConflicts = [];

    for (const conflictGroup of CONFLICTING_MODS) {
      const conflictingFound = modAcronyms.filter(acronym => conflictGroup.includes(acronym));
      if (conflictingFound.length > 1) {
        foundConflicts.push(conflictingFound);
      }
    }

    setConflicts(foundConflicts);
  };

  const handleModToggle = (acronym) => {
    const isSelected = selectedMods.some(mod => mod.acronym === acronym);

    if (isSelected) {
      // Remove mod
      const newMods = selectedMods.filter(mod => mod.acronym !== acronym);
      onChange(newMods);

      // Hide settings panel
      setShowSettings(prev => ({ ...prev, [acronym]: false }));
    } else {
      // Add mod with EMPTY settings initially
      // Only populate settings when user explicitly changes them
      const newMod = {
        acronym,
        settings: {} // Start with empty settings object
      };

      onChange([...selectedMods, newMod]);
    }
  };

  const handleSettingChange = (modAcronym, settingKey, value) => {
    const newMods = selectedMods.map(mod => {
      if (mod.acronym === modAcronym) {
        return {
          ...mod,
          settings: {
            ...mod.settings,
            [settingKey]: value
          }
        };
      }
      return mod;
    });
    onChange(newMods);
  };

  const toggleSettings = (acronym) => {
    setShowSettings(prev => ({
      ...prev,
      [acronym]: !prev[acronym]
    }));
  };

  const getModByCategory = () => {
    const categories = {};
    Object.entries(OSU_MODS).forEach(([acronym, info]) => {
      if (!categories[info.category]) {
        categories[info.category] = [];
      }
      categories[info.category].push({ acronym, ...info });
    });
    return categories;
  };

  const isModSelected = (acronym) => {
    return selectedMods.some(mod => mod.acronym === acronym);
  };

  const getSelectedMod = (acronym) => {
    return selectedMods.find(mod => mod.acronym === acronym);
  };

  const getSettingRange = (config, modAcronym, settingKey) => {
    if (config.getMin && config.getMax) {
      return {
        min: config.getMin(modAcronym),
        max: config.getMax(modAcronym),
        step: config.getStep ? config.getStep(modAcronym) : config.step
      };
    }
    return {
      min: config.min,
      max: config.max,
      step: config.step
    };
  };

  const renderSettingsSummary = (selectedMod) => {
    if (!selectedMod.settings || Object.keys(selectedMod.settings).length === 0) {
      return null;
    }

    const summaryItems = [];
    Object.entries(selectedMod.settings).forEach(([key, value]) => {
      const config = SETTING_CONFIGS[key];
      if (config && config.format) {
        summaryItems.push(`${config.label}: ${config.format(value)}`);
      } else if (config && config.type === 'boolean') {
        if (value) summaryItems.push(config.label);
      } else if (config && config.type === 'select') {
        const option = config.options.find(opt => opt.value === value);
        if (option) summaryItems.push(`${config.label}: ${option.label}`);
      } else if (value !== undefined) {
        summaryItems.push(`${config?.label || key}: ${value}`);
      }
    });

    return summaryItems.length > 0 ? ` (${summaryItems.join(', ')})` : null;
  };

  const categories = getModByCategory();

  return (
    <div className="space-y-6">

      {/* Conflicts Warning */}
      {conflicts.length > 0 && (
        <div className="bg-red-50 border border-red-200 rounded-lg p-4">
          <div className="flex items-start gap-3">
            <AlertTriangle className="w-5 h-5 text-red-600 flex-shrink-0 mt-0.5" />
            <div>
              <h4 className="font-medium text-red-900 mb-1">Mod Conflicts Detected</h4>
              {conflicts.map((conflictGroup, index) => (
                <p key={index} className="text-sm text-red-700">
                  {conflictGroup.join(', ')} cannot be used together
                </p>
              ))}
            </div>
          </div>
        </div>
      )}

      {/* Selected Mods Summary */}
      {selectedMods.length > 0 && (
        <div className="bg-green-50 border border-green-200 rounded-lg p-4">
          <h4 className="font-medium text-green-900 mb-2">Selected Mods ({selectedMods.length})</h4>
          <div className="flex flex-wrap gap-2">
            {selectedMods.map(mod => {
              const settingsSummary = renderSettingsSummary(mod);
              return (
                <div key={mod.acronym} className="flex items-center gap-2 bg-green-100 text-green-800 px-3 py-1 rounded-full text-sm">
                  <span className="font-medium">{mod.acronym}</span>
                  {settingsSummary && (
                    <span className="text-xs opacity-75">{settingsSummary}</span>
                  )}
                  {Object.keys(mod.settings || {}).length > 0 && (
                    <Settings className="w-3 h-3" />
                  )}
                  <button
                    onClick={() => handleModToggle(mod.acronym)}
                    className="text-green-600 hover:text-green-800"
                  >
                    <X className="w-3 h-3" />
                  </button>
                </div>
              );
            })}
          </div>
        </div>
      )}

      {/* Mod Categories */}
      {Object.entries(categories).map(([category, mods]) => (
        <div key={category} className="space-y-3">
          <h3 className="text-lg font-semibold text-gray-800 border-b border-gray-200 pb-2">
            {category}
          </h3>

          <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
            {mods.map(mod => {
              const isSelected = isModSelected(mod.acronym);
              const selectedMod = getSelectedMod(mod.acronym);
              const hasSettings = mod.settings.length > 0;

              return (
                <div key={mod.acronym} className="space-y-2">
                  <button
                    onClick={() => handleModToggle(mod.acronym)}
                    className={`w-full p-3 rounded-lg border-2 transition-all duration-200 text-left ${
                      isSelected
                        ? 'border-blue-500 bg-blue-50 text-blue-900'
                        : 'border-gray-200 bg-white text-gray-700 hover:border-gray-300 hover:bg-gray-50'
                    }`}
                  >
                    <div className="flex items-center justify-between">
                      <div>
                        <div className="font-bold text-lg">{mod.acronym}</div>
                        <div className="text-sm opacity-75">{mod.name}</div>
                      </div>
                      {isSelected && <Check className="w-5 h-5 text-blue-600" />}
                    </div>
                  </button>

                  {/* Settings Button */}
                  {isSelected && hasSettings && (
                    <button
                      onClick={() => toggleSettings(mod.acronym)}
                      className={`w-full p-2 rounded-lg border text-sm transition-colors ${
                        showSettings[mod.acronym]
                          ? 'border-blue-300 bg-blue-100 text-blue-800'
                          : 'border-gray-300 bg-gray-100 text-gray-700 hover:bg-gray-200'
                      }`}
                    >
                      <div className="flex items-center justify-center gap-2">
                        <Settings className="w-4 h-4" />
                        <span>Settings</span>
                      </div>
                    </button>
                  )}

                  {/* Settings Panel */}
                  {isSelected && hasSettings && showSettings[mod.acronym] && selectedMod && (
                    <div className="bg-gray-50 border border-gray-200 rounded-lg p-4 space-y-3">
                      <h4 className="font-medium text-gray-800">{mod.name} Settings</h4>

                      {mod.settings.map(settingKey => {
                        const config = SETTING_CONFIGS[settingKey];
                        if (!config) return null;

                        const currentValue = selectedMod.settings[settingKey] ?? 
                          (typeof config.getDefault === 'function' ? config.getDefault(mod.acronym) : config.default);

                        return (
                          <div key={settingKey} className="space-y-2">
                            <label className="block text-sm font-medium text-gray-700">
                              {config.label}
                              {config.format && (
                                <span className="ml-2 text-gray-500">
                                  ({config.format(currentValue)})
                                </span>
                              )}
                            </label>

                            {config.type === 'boolean' && (
                              <label className="flex items-center gap-2">
                                <input
                                  type="checkbox"
                                  checked={currentValue}
                                  onChange={(e) => handleSettingChange(mod.acronym, settingKey, e.target.checked)}
                                  className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                                />
                                <span className="text-sm text-gray-600">Enable</span>
                              </label>
                            )}

                            {config.type === 'range' && (
                              <div className="space-y-2">
                                {(() => {
                                  const range = getSettingRange(config, mod.acronym, settingKey);
                                  return (
                                    <>
                                      {/* Current value display - larger and more prominent */}
                                      <div className="flex justify-between items-center">
                                        <span className="text-sm font-medium text-gray-700">
                                          Current: 
                                          <span className="ml-1 text-blue-600 font-semibold">
                                            {config.format ? config.format(currentValue) : currentValue}
                                          </span>
                                        </span>
                                        <span className="text-xs text-gray-500">
                                          Range: {range.min} - {range.max}
                                        </span>
                                      </div>

                                      {/* Range input with improved styling */}
                                      <div className="relative">
                                        <input
                                          type="range"
                                          min={range.min}
                                          max={range.max}
                                          step={range.step}
                                          value={currentValue}
                                          onChange={(e) => handleSettingChange(mod.acronym, settingKey, parseFloat(e.target.value))}
                                          className="w-full h-3 bg-gray-200 rounded-lg appearance-none cursor-pointer slider"
                                          style={{
                                            background: `linear-gradient(to right, #3b82f6 0%, #3b82f6 ${((currentValue - range.min) / (range.max - range.min)) * 100}%, #e5e7eb ${((currentValue - range.min) / (range.max - range.min)) * 100}%, #e5e7eb 100%)`
                                          }}
                                        />

                                        {/* Value indicator on slider */}
                                        <div 
                                          className="absolute top-0 w-1 h-3 bg-blue-700 rounded-full pointer-events-none"
                                          style={{
                                            left: `calc(${((currentValue - range.min) / (range.max - range.min)) * 100}% - 2px)`
                                          }}
                                        />
                                      </div>

                                      {/* Min/max labels */}
                                      <div className="flex justify-between text-xs text-gray-500">
                                        <span>{config.format ? config.format(range.min) : range.min}</span>
                                        <span>{config.format ? config.format(range.max) : range.max}</span>
                                      </div>

                                      {/* Default value indicator if different from current */}
                                      {(() => {
                                        const defaultValue = typeof config.getDefault === 'function' 
                                          ? config.getDefault(mod.acronym) 
                                          : config.default;

                                        if (defaultValue !== currentValue) {
                                          return (
                                            <div className="text-xs text-gray-500 italic">
                                              Default: {config.format ? config.format(defaultValue) : defaultValue}
                                              <button
                                                type="button"
                                                onClick={() => handleSettingChange(mod.acronym, settingKey, defaultValue)}
                                                className="ml-2 px-2 py-0.5 bg-gray-100 hover:bg-gray-200 rounded text-xs transition-colors"
                                              >
                                                Reset
                                              </button>
                                            </div>
                                          );
                                        }
                                        return null;
                                      })()}
                                    </>
                                  );
                                })()}
                              </div>
                            )}

                            {config.type === 'number' && (
                              <input
                                type="number"
                                value={currentValue}
                                onChange={(e) => handleSettingChange(mod.acronym, settingKey, parseInt(e.target.value) || 0)}
                                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                              />
                            )}

                            {config.type === 'select' && (
                              <select
                                value={currentValue}
                                onChange={(e) => {
                                  const val = config.options.find(opt => opt.value.toString() === e.target.value)?.value;
                                  handleSettingChange(mod.acronym, settingKey, val);
                                }}
                                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                              >
                                {config.options.map(option => (
                                  <option key={option.value} value={option.value}>
                                    {option.label}
                                  </option>
                                ))}
                              </select>
                            )}
                          </div>
                        );
                      })}
                    </div>
                  )}
                </div>
              );
            })}
          </div>
        </div>
      ))}
    </div>
  );
}


================================================
FILE: frontend/components/MonitoringDashboard.js
================================================
import { useState, useEffect } from 'react';
import { Activity, Database, Clock, AlertCircle, CheckCircle } from 'lucide-react';
import { useAPI } from '../hooks/useAPI';
import { formatDate } from '../lib/date-utils';

export default function MonitoringDashboard() {
  const [systemStatus, setSystemStatus] = useState({
    api: 'checking',
    database: 'checking',
    worker: 'checking'
  });

  const { data: healthData, error: healthError } = useAPI('/api/health', {
    refreshInterval: 30000 // Check every 30 seconds
  });

  const { data: stats } = useAPI('/api/stats', {
    refreshInterval: 60000 // Update every minute
  });

  useEffect(() => {
    if (healthData) {
      setSystemStatus({
        api: healthData.checks.api,
        database: healthData.checks.database,
        worker: 'ok' // Would need separate worker health endpoint
      });
    }
    if (healthError) {
      setSystemStatus(prev => ({
        ...prev,
        api: 'error'
      }));
    }
  }, [healthData, healthError]);

  const getStatusColor = (status) => {
    switch (status) {
      case 'ok': return 'text-green-400';
      case 'error': return 'text-red-400';
      case 'checking': return 'text-yellow-400';
      default: return 'text-gray-400';
    }
  };

  const getStatusIcon = (status) => {
    switch (status) {
      case 'ok': return <CheckCircle className="w-5 h-5" />;
      case 'error': return <AlertCircle className="w-5 h-5" />;
      default: return <Activity className="w-5 h-5 animate-pulse" />;
    }
  };

  return (
    <div className="bg-black/30 rounded-xl p-6 border border-purple-500/30">
      <h3 className="text-xl font-bold mb-4 flex items-center gap-2">
        <Activity className="w-5 h-5 text-purple-400" />
        System Status
      </h3>

      {/* Status Grid */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
        <div className="bg-gray-900/50 rounded-lg p-4">
          <div className="flex items-center justify-between mb-2">
            <span className="text-sm text-gray-400">API Status</span>
            <span className={getStatusColor(systemStatus.api)}>
              {getStatusIcon(systemStatus.api)}
            </span>
          </div>
          <p className={`font-semibold ${getStatusColor(systemStatus.api)}`}>
            {systemStatus.api.toUpperCase()}
          </p>
        </div>

        <div className="bg-gray-900/50 rounded-lg p-4">
          <div className="flex items-center justify-between mb-2">
            <span className="text-sm text-gray-400">Database</span>
            <span className={getStatusColor(systemStatus.database)}>
              {getStatusIcon(systemStatus.database)}
            </span>
          </div>
          <p className={`font-semibold ${getStatusColor(systemStatus.database)}`}>
            {systemStatus.database.toUpperCase()}
          </p>
        </div>

        <div className="bg-gray-900/50 rounded-lg p-4">
          <div className="flex items-center justify-between mb-2">
            <span className="text-sm text-gray-400">Worker</span>
            <span className={getStatusColor(systemStatus.worker)}>
              {getStatusIcon(systemStatus.worker)}
            </span>
          </div>
          <p className={`font-semibold ${getStatusColor(systemStatus.worker)}`}>
            {systemStatus.worker.toUpperCase()}
          </p>
        </div>
      </div>

      {/* Statistics */}
      {stats && (
        <div className="space-y-2 text-sm">
          <div className="flex justify-between">
            <span className="text-gray-400">Active Challenges</span>
            <span className="font-semibold">{stats.activeChallenges}</span>
          </div>
          <div className="flex justify-between">
            <span className="text-gray-400">Total Users</span>
            <span className="font-semibold">{stats.totalUsers}</span>
          </div>
          <div className="flex justify-between">
            <span className="text-gray-400">Scores Today</span>
            <span className="font-semibold">{stats.scoresToday}</span>
          </div>
          <div className="flex justify-between">
            <span className="text-gray-400">Last Update</span>
            <span className="font-semibold">
              {formatDate(stats.lastUpdate, 'relative')}
            </span>
          </div>
        </div>
      )}

      {/* Uptime */}
      {healthData && (
        <div className="mt-4 pt-4 border-t border-gray-800">
          <div className="flex items-center justify-between text-sm">
            <span className="text-gray-400 flex items-center gap-2">
              <Clock className="w-4 h-4" />
              Uptime
            </span>
            <span className="font-mono">
              {Math.floor(healthData.uptime / 3600)}h {Math.floor((healthData.uptime % 3600) / 60)}m
            </span>
          </div>
        </div>
      )}
    </div>
  );
}


================================================
FILE: frontend/components/PartnerCard.js
================================================
import { ExternalLink } from 'lucide-react';

export default function PartnerCard({ 
  partner, 
  size = 'medium', 
  onClick = null,
  isExpanded = false,
  cardRef = null 
}) {
  const sizeConfig = {
    small: {
      iconSize: 'w-16 h-16',
      textSize: 'text-sm',
      padding: 'p-3',
      gap: 'gap-2'
    },
    medium: {
      iconSize: 'w-20 h-20',
      textSize: 'text-base',
      padding: 'p-4',
      gap: 'gap-3'
    },
    large: {
      iconSize: 'w-24 h-24',
      textSize: 'text-lg',
      padding: 'p-6',
      gap: 'gap-4'
    }
  };

  const config = sizeConfig[size];

  const content = (
    <div className="relative overflow-hidden rounded-2xl transition-all duration-300 hover:scale-[1.02] hover:shadow-2xl glass-2">
      
      {/* Content */}
      <div className={`relative z-10 ${config.padding} flex flex-col items-center ${config.gap}`}>
        {/* Discord-style icon container */}
        <div className={`${config.iconSize} rounded-2xl overflow-hidden bg-white shadow-md transition-all duration-300 group-hover:shadow-xl group-hover:scale-110 group-hover:rounded-xl`}>
          <img
            src={partner.icon_url}
            alt={partner.name}
            className="w-full h-full object-cover"
            onError={(e) => {
              e.target.onerror = null;
              e.target.src = `https://ui-avatars.com/api/?name=${encodeURIComponent(partner.name)}&background=9333ea&color=fff&size=256`;
            }}
          />
        </div>
        
        {/* Partner name */}
        <div className="text-center">
          <h3 className={`${config.textSize} font-semibold text-neutral-800 group-hover:text-primary-600 transition-colors duration-300`}>
            {partner.name}
          </h3>
          
          {/* Description (if available and not small size) - Hidden when morphing is enabled */}
          {partner.description && size !== 'small' && !onClick && (
            <p className="text-xs text-neutral-600 mt-1 line-clamp-2 max-w-[150px]">
              {partner.description}
            </p>
          )}
        </div>
        
        {/* External link indicator */}
        <div className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity duration-300">
          <ExternalLink className="w-4 h-4 text-primary-500" />
        </div>
      </div>
    </div>
  );

  return (
  <div
    ref={cardRef}
    onClick={() => onClick && onClick(partner)}
    className={`
      group cursor-pointer transition-all duration-300 ease-out
      ${isExpanded ? 'opacity-0 pointer-events-none' : 'hover:scale-[1.02]'}
    `}
  >
    {content}
  </div>
);
}


================================================
FILE: frontend/components/RulesetManager.js
================================================
import { useState, useEffect } from 'react';
import { Save, X, Crown, AlertCircle, CheckCircle, Loader2, Target, Trophy, Settings2, Eye } from 'lucide-react';
import ModSelector from './ModSelector';
import { generateRulesetName, generateRulesetDescription, previewRulesetName } from '../lib/ruleset-name-generator';
import { OSU_MODS, SETTING_RANGES, SETTING_CONFIGS } from '../lib/osu-mods-reference';

export default function RulesetManager({ challengeId, onClose, onSuccess }) {
  const [loading, setLoading] = useState(false);
  const [saving, setSaving] = useState(false);
  const [challenge, setChallenge] = useState(null);
  const [winner, setWinner] = useState(null);
  const [formData, setFormData] = useState({
    required_mods: [],
    ruleset_match_type: 'at_least'  // CHANGED: Default from 'exact' to 'at_least'
  });
  const [errors, setErrors] = useState([]);
  const [hasChanges, setHasChanges] = useState(false);
  const [namePreview, setNamePreview] = useState({ name: '', description: '', isValid: true, modCount: 0 });

  useEffect(() => {
    loadChallengeData();
  }, [challengeId]);

  useEffect(() => {
    // Check if form has changes from original data
    if (challenge) {
      const hasRulesetChanges = 
        formData.ruleset_match_type !== (challenge.ruleset_match_type || 'at_least') ||  // CHANGED: Default comparison to 'at_least'
        JSON.stringify(formData.required_mods) !== JSON.stringify(challenge.required_mods || []);
      
      setHasChanges(hasRulesetChanges);
    }
  }, [formData, challenge]);

  // Update name preview whenever form data changes
  useEffect(() => {
    if (formData.required_mods && formData.ruleset_match_type) {
      try {
        const preview = previewRulesetName(formData.required_mods, formData.ruleset_match_type);
        setNamePreview(preview);
      } catch (error) {
        console.warn('Error generating name preview:', error);
        setNamePreview({ 
          name: 'Error generating name', 
          description: 'Please check your mod selection', 
          isValid: false, 
          modCount: formData.required_mods?.length || 0 
        });
      }
    }
  }, [formData.required_mods, formData.ruleset_match_type]);

  const loadChallengeData = async () => {
    setLoading(true);
    setErrors([]);

    try {
      const response = await fetch(`/api/admin/rulesets/${challengeId}`, {
        credentials: 'include'
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to load challenge data');
      }

      const responseData = data.data || data;
      setChallenge(responseData.challenge);
      setWinner(responseData.winner);

      // Initialize form with existing data (removed name and description)
      if (data.challenge.has_ruleset) {
        setFormData({
          required_mods: data.challenge.required_mods || [],
          ruleset_match_type: data.challenge.ruleset_match_type || 'at_least'  // CHANGED: Default to 'at_least'
        });
      }

    } catch (error) {
      console.error('Error loading challenge:', error);
      setErrors([error.message]);
    } finally {
      setLoading(false);
    }
  };

  const cleanupSettings = (mods) => {
    return mods.map(mod => {
      const cleanedSettings = {};
      const modInfo = OSU_MODS[mod.acronym];
      
      if (modInfo && modInfo.settings.length > 0) {
        Object.entries(mod.settings || {}).forEach(([key, value]) => {
          const config = SETTING_CONFIGS[key];
          if (config) {
            // Get the default value for this setting
            const defaultValue = typeof config.getDefault === 'function' 
              ? config.getDefault(mod.acronym) 
              : config.default;
            
            // Only include non-default values
            if (value !== defaultValue) {
              cleanedSettings[key] = value;
            }
          }
        });
      }
      
      return {
        acronym: mod.acronym,
        settings: cleanedSettings
      };
    });
  };

  const handleSave = async () => {
    setSaving(true);
    setErrors([]);

    try {
      // Clean up settings to remove default values before saving
      const cleanedMods = cleanupSettings(formData.required_mods);
      
      if (!cleanedMods || cleanedMods.length === 0) {
        throw new Error('At least one mod must be selected');
      }

      // Save ruleset with cleaned mods
      const response = await fetch(`/api/admin/rulesets/${challengeId}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        credentials: 'include',
        body: JSON.stringify({
          ...formData,
          required_mods: cleanedMods // Use cleaned mods instead of raw form data
        })
      });

      const data = await response.json();

      if (!response.ok) {
        if (data.details && Array.isArray(data.details)) {
          setErrors(data.details);
        } else {
          throw new Error(data.error || 'Failed to save ruleset');
        }
        return;
      }

      // Success
      if (onSuccess) {
        onSuccess('Ruleset saved successfully');
      }

      // Reload data to show updated winner
      await loadChallengeData();

    } catch (error) {
      console.error('Error saving ruleset:', error);
      setErrors([error.message]);
    } finally {
      setSaving(false);
    }
  };

  const handleDelete = async () => {
    if (!confirm('Are you sure you want to remove this ruleset? This action cannot be undone.')) {
      return;
    }

    setSaving(true);
    setErrors([]);

    try {
      const response = await fetch(`/api/admin/rulesets/${challengeId}`, {
        method: 'DELETE',
        credentials: 'include'
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to delete ruleset');
      }

      // Success
      if (onSuccess) {
        onSuccess('Ruleset removed successfully');
      }

      onClose();

    } catch (error) {
      console.error('Error deleting ruleset:', error);
      setErrors([error.message]);
    } finally {
      setSaving(false);
    }
  };

  if (loading) {
    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div className="bg-white rounded-xl p-6 w-96">
          <div className="flex items-center justify-center gap-3">
            <Loader2 className="w-6 h-6 animate-spin text-primary-600" />
            <span>Loading challenge data...</span>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-xl shadow-2xl w-full max-w-4xl max-h-[90vh] overflow-y-auto">
        {/* Header */}
        <div className="flex items-center justify-between p-6 border-b border-gray-200">
          <div>
            <h2 className="text-2xl font-bold text-gray-800 flex items-center gap-2">
              <Settings2 className="w-6 h-6 text-primary-600" />
              Manage Ruleset
            </h2>
            <p className="text-gray-600 mt-1">
              {challenge?.custom_name || challenge?.name} (Room {challenge?.room_id})
            </p>
          </div>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-600 transition-colors"
          >
            <X className="w-6 h-6" />
          </button>
        </div>

        {/* Current Winner Display */}
        {challenge?.has_ruleset && winner && (
          <div className="mx-6 mt-6 bg-gradient-to-r from-yellow-50 to-amber-50 border border-yellow-200 rounded-lg p-4">
            <div className="flex items-center gap-3">
              <Crown className="w-6 h-6 text-yellow-600" />
              <div>
                <h3 className="font-semibold text-yellow-900">Current Ruleset Winner</h3>
                <div className="flex items-center gap-4 mt-2 text-sm">
                  <div className="flex items-center gap-2">
                    {winner.avatar_url && (
                      <img 
                        src={winner.avatar_url} 
                        alt={`${winner.username}'s avatar`}
                        className="w-6 h-6 rounded-full"
                      />
                    )}
                    <span className="font-medium text-yellow-800">{winner.username}</span>
                  </div>
                  <div className="flex items-center gap-1 text-yellow-700">
                    <Trophy className="w-4 h-4" />
                    <span>{winner.score?.toLocaleString()}</span>
                  </div>
                  <div className="text-yellow-600">
                    Won {new Date(winner.won_at).toLocaleDateString()}
                  </div>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Name Preview Section */}
        {formData.required_mods.length > 0 && (
          <div className="mx-6 mt-6 bg-gradient-to-r from-blue-50 to-indigo-50 border border-blue-200 rounded-lg p-4">
            <div className="flex items-center gap-3 mb-3">
              <Eye className="w-5 h-5 text-blue-600" />
              <h3 className="font-semibold text-blue-900">Ruleset Preview</h3>
            </div>
            <div className="space-y-2">
              <div className="flex items-center gap-2">
                <span className="text-sm font-medium text-blue-800">Name:</span>
                <code className="bg-blue-100 text-blue-900 px-2 py-1 rounded text-sm font-mono">
                  {namePreview.name}
                </code>
                {!namePreview.isValid && (
                  <AlertCircle className="w-4 h-4 text-red-500" />
                )}
              </div>
              <div className="flex items-start gap-2">
                <span className="text-sm font-medium text-blue-800">Description:</span>
                <span className="text-sm text-blue-700">{namePreview.description}</span>
              </div>
              <div className="text-xs text-blue-600">
                {namePreview.modCount} mod{namePreview.modCount !== 1 ? 's' : ''} selected ‚Ä¢ 
                Match type: {formData.ruleset_match_type}
              </div>
            </div>
          </div>
        )}

        {/* Error Display */}
        {errors.length > 0 && (
          <div className="mx-6 mt-6 bg-red-50 border border-red-200 rounded-lg p-4">
            <div className="flex items-start gap-3">
              <AlertCircle className="w-5 h-5 text-red-600 flex-shrink-0 mt-0.5" />
              <div>
                <h4 className="font-medium text-red-900">Validation Errors</h4>
                <ul className="mt-2 text-sm text-red-700 space-y-1">
                  {errors.map((error, index) => (
                    <li key={index}>‚Ä¢ {error}</li>
                  ))}
                </ul>
              </div>
            </div>
          </div>
        )}

        <div className="p-6 space-y-6">
          {/* Rule Type */}
          <div className="space-y-4">
            <h3 className="text-lg font-semibold text-gray-800">Ruleset Configuration</h3>
            
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Rule Type *
              </label>
              <select
                value={formData.ruleset_match_type}
                onChange={(e) => setFormData(prev => ({ ...prev, ruleset_match_type: e.target.value }))}
                className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
              >
                <option value="at_least">At Least - Players must have at least these mods (extras allowed)</option>
                <option value="exact">Exact Match - Players must have exactly these mods (no extras)</option>
                <option value="any_of">Any Of - Players must have at least one of these mods (extras allowed)</option>
              </select>
            </div>
          </div>

          {/* Mod Selection */}
          <div className="space-y-4">
            <ModSelector
              selectedMods={formData.required_mods}
              onChange={(mods) => setFormData(prev => ({ ...prev, required_mods: mods }))}
              matchType={formData.ruleset_match_type}
            />
          </div>
        </div>

        {/* Footer */}
        <div className="flex items-center justify-between p-6 border-t border-gray-200 bg-gray-50">
          <div>
            {challenge?.has_ruleset && (
              <button
                onClick={handleDelete}
                disabled={saving}
                className="px-4 py-2 text-red-600 border border-red-300 rounded-lg hover:bg-red-50 transition-colors disabled:opacity-50"
              >
                Remove Ruleset
              </button>
            )}
          </div>
          
          <div className="flex items-center gap-3">
            <button
              onClick={onClose}
              disabled={saving}
              className="px-6 py-2 text-gray-600 border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors disabled:opacity-50"
            >
              Cancel
            </button>
            
            <button
              onClick={handleSave}
              disabled={saving || !hasChanges || formData.required_mods.length === 0}
              className="flex items-center gap-2 px-6 py-2 bg-primary-600 text-white rounded-lg hover:bg-primary-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {saving ? (
                <>
                  <Loader2 className="w-4 h-4 animate-spin" />
                  Saving...
                </>
              ) : (
                <>
                  <Save className="w-4 h-4" />
                  Save Ruleset
                </>
              )}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}


================================================
FILE: frontend/components/ScoreTable.js
================================================
import { Trophy, Target, ChevronDown, Users } from 'lucide-react';
import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';

// Utility function to sanitize user input
const sanitizeText = (text) => {
  if (typeof text !== 'string') return '';
  return text.replace(/[<>&"']/g, (match) => {
    const escapeMap = {
      '<': '&lt;',
      '>': '&gt;',
      '&': '&amp;',
      '"': '&quot;',
      "'": '&#x27;'
    };
    return escapeMap[match];
  });
};

// Helper function to get country flag URL from flagcdn.com
const getCountryFlagUrl = (countryCode) => {
  if (!countryCode || countryCode.length !== 2) return null;
  return `https://flagcdn.com/w20/${countryCode.toLowerCase()}.png`;
};

export default function ScoreTable({ scores = [], loading = false, challenge = null }) {
  const [sortBy, setSortBy] = useState('rank');
  const [sortOrder, setSortOrder] = useState('asc');
  const [winnerInfo, setWinnerInfo] = useState(null);
  const [showMobileView, setShowMobileView] = useState(false);
  const router = useRouter();

  // Check if mobile view should be used
  useEffect(() => {
    const checkMobile = () => {
      setShowMobileView(window.innerWidth < 768);
    };
    
    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  // Load winner information for this challenge
  useEffect(() => {
    if (challenge?.has_ruleset && challenge?.id) {
      loadWinnerInfo();
    }
  }, [challenge?.id, challenge?.has_ruleset]);

  const loadWinnerInfo = async () => {
    if (!challenge?.id) return;
    
    try {
      const response = await fetch(`/api/admin/rulesets/${challenge.id}`, {
        credentials: 'include'
      });
      
      if (response.ok) {
        const data = await response.json();
        const responseData = data.data || data;
        setWinnerInfo(responseData.winner);
      }
    } catch (error) {
      console.warn('Failed to load winner info:', error);
    }
  };

  // Check if a score is the ruleset winner
  const isRulesetWinner = (score) => {
    return winnerInfo && winnerInfo.score_id === score.id;
  };

  if (loading) {
    return (
      <div className="text-center py-8 sm:py-12">
        <div className="animate-spin rounded-full h-6 w-6 sm:h-8 sm:w-8 border-b-2 border-purple-400 mx-auto mb-3 sm:mb-4"></div>
        <span className="text-white/70 text-shadow-adaptive-sm text-sm sm:text-base">Loading scores...</span>
      </div>
    );
  }

  if (!Array.isArray(scores) || scores.length === 0) {
    return (
      <div className="text-center py-8 sm:py-12">
        <Trophy className="w-10 h-10 sm:w-12 sm:h-12 mx-auto mb-3 sm:mb-4 text-white/30 icon-shadow-adaptive" />
        <p className="text-white/70 text-shadow-adaptive-sm text-sm sm:text-base">No scores available yet.</p>
      </div>
    );
  }

  const formatScore = (score) => {
    if (typeof score !== 'number' || isNaN(score)) return '0';
    if (score >= 1000000) return (score / 1000000).toFixed(1) + 'M';
    if (score >= 1000) return (score / 1000).toFixed(1) + 'K';
    return score.toLocaleString();
  };

  const formatAccuracy = (accuracy) => {
    if (typeof accuracy !== 'number' || isNaN(accuracy)) return '0.00';
    return Math.max(0, Math.min(100, accuracy)).toFixed(2);
  };

  const formatCombo = (combo) => {
    if (typeof combo !== 'number' || isNaN(combo)) return '0';
    return Math.max(0, combo);
  };

  const handleSort = (column) => {
    if (sortBy === column) {
      setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');
    } else {
      setSortBy(column);
      setSortOrder('asc');
    }
  };

  // Handle clicking on a username to go to their profile
  const handleUsernameClick = (user) => {
    if (!user) return;
    
    const userId = user.id || user.user_id;
    
    if (userId) {
      router.push(`/profile/${userId}`);
    } else {
      console.warn('No user ID found for user:', user);
    }
  };

  // Add original rank based on score to each score object
  const scoresWithRank = scores.map((score, index) => ({
    ...score,
    originalRank: index + 1
  }));

  // Sort scores based on current sort settings
  const sortedScores = [...scoresWithRank].sort((a, b) => {
    let aVal, bVal;
    
    switch (sortBy) {
      case 'score':
        aVal = a.score || 0;
        bVal = b.score || 0;
        break;
      case 'accuracy':
        aVal = a.accuracy || 0;
        bVal = b.accuracy || 0;
        break;
      case 'combo':
        aVal = a.max_combo || 0;
        bVal = b.max_combo || 0;
        break;
      case 'player':
        aVal = (a.users?.username || '').toLowerCase();
        bVal = (b.users?.username || '').toLowerCase();
        break;
      default: // rank
        return a.originalRank - b.originalRank;
    }
    
    if (sortOrder === 'asc') {
      return aVal > bVal ? 1 : -1;
    } else {
      return aVal < bVal ? 1 : -1;
    }
  });

  const getAccuracyGradient = (accuracy) => {
    if (accuracy >= 98) return 'from-pink-500 to-purple-500';
    if (accuracy >= 95) return 'from-green-500 to-emerald-500';
    if (accuracy >= 90) return 'from-cyan-500 to-blue-500';
    if (accuracy >= 85) return 'from-yellow-500 to-orange-500';
    return 'from-pink-500 to-red-500';
  };
  
  const getAccuracyBorder = (accuracy) => {
    if (accuracy >= 98) return 'acc-badge-purple';
    if (accuracy >= 95) return 'acc-badge-green';
    if (accuracy >= 90) return 'acc-badge-blue';
    if (accuracy >= 85) return 'acc-badge-yellow';
    return 'acc-badge-red';
  };

  const getRankGradient = (rank) => {
    if (rank === 1) return 'from-blue-400 to-blue-600';      // 7‚òÖ
    if (rank === 2) return 'from-purple-400 to-purple-600';  // 6‚òÖ  
    if (rank === 3) return 'from-red-400 to-red-600';        // 5‚òÖ
    if (rank <= 10) return 'from-orange-400 to-red-500';
    return 'from-gray-400 to-gray-600';
  };

  const SortButton = ({ column, children, align = 'left' }) => (
    <button
      onClick={() => handleSort(column)}
      className={`flex items-center gap-1 hover:text-purple-300 transition-colors font-medium w-full text-shadow-adaptive-sm ${
        align === 'right' ? 'justify-end' : 
        align === 'center' ? 'justify-center' : 
        'justify-start'
      }`}
      aria-label={`Sort by ${column}`}
    >
      {children}
      {sortBy === column && (
        <span className="text-xs text-purple-300">
          {sortOrder === 'asc' ? '‚Üë' : '‚Üì'}
        </span>
      )}
    </button>
  );

  // Mobile Card View
  if (showMobileView) {
    return (
      <div className="space-y-2 sm:space-y-3">
        {sortedScores.map((score, index) => {
          const rank = score.originalRank;
          const username = sanitizeText(score.users?.username || 'Unknown');
          const country = sanitizeText(score.users?.country || '');
          const mods = sanitizeText(score.mods || 'None');
          const isWinner = isRulesetWinner(score);
          const isTop3 = rank <= 3;
          
          return (
            <div 
              key={score.id || index}
              className={`p-3 sm:p-4 transition-all rounded-lg sm:rounded-xl ${
                isTop3 ? 'glass-2 border border-white/20' : 'border border-white/10'
              } ${isTop3 ? `performance-card-${rank === 1 ? 'blue' : rank === 2 ? 'purple' : 'orange'}` : ''}`}
            >
              <div className="flex items-start gap-3">
                {/* Rank Badge */}
                <div className={`w-10 h-10 sm:w-12 sm:h-12 rounded-lg sm:rounded-xl bg-gradient-to-b ${getRankGradient(rank)} flex items-center justify-center shadow-lg flex-shrink-0`}>
                  <span className="text-white font-black text-xs sm:text-sm text-shadow-adaptive">
                    #{rank}
                  </span>
                </div>
                
                {/* Player Info */}
                <div className="flex-1 min-w-0">
                  <div className="flex items-center gap-2 mb-1.5 sm:mb-2">
                    {score.users?.avatar_url && (
                      <img 
                        src={score.users.avatar_url} 
                        alt={`${username}'s avatar`}
                        className="w-6 h-6 sm:w-8 sm:h-8 rounded-full avatar-border flex-shrink-0"
                        onError={(e) => { e.target.style.display = 'none'; }}
                      />
                    )}
                    <button 
                      className="font-bold text-white hover:text-purple-300 transition-colors text-shadow-adaptive truncate text-left text-sm sm:text-base" 
                      onClick={() => handleUsernameClick(score.users)}
                    >
                      {username}
                    </button>
                    {country && getCountryFlagUrl(country) && (
                      <img 
                        src={getCountryFlagUrl(country)} 
                        alt={`${country} flag`}
                        className="w-4 h-3 sm:w-5 sm:h-3 object-cover rounded-sm shadow-sm flex-shrink-0"
                        onError={(e) => { e.target.style.display = 'none'; }}
                      />
                    )}
                  </div>
                  
                  {/* Badges */}
                  {isWinner && (
                    <div className="mb-1.5 sm:mb-2">
                      <span className="inline-flex items-center gap-1 glass-2 text-yellow-300 text-xs font-medium px-2 py-0.5 sm:py-1 rounded-full performance-card-orange">
                        <Target className="w-3 h-3 icon-shadow-adaptive-sm" />
                        Ruleset Winner
                      </span>
                    </div>
                  )}
                  
                  {/* Score Details */}
                  <div className="grid grid-cols-2 gap-2 sm:gap-3 text-xs sm:text-sm">
                    <div>
                      <span className="text-white/70 text-shadow-adaptive-sm">Score:</span>
                      <div className="font-mono font-bold text-white text-shadow-adaptive">
                        {formatScore(score.score)}
                      </div>
                    </div>
                    <div>
                      <span className="text-white/70 text-shadow-adaptive-sm">Accuracy:</span>
                      <div className={`inline-flex px-1.5 py-0.5 sm:px-2 sm:py-1 bg-gradient-to-b ${getAccuracyGradient(score.accuracy)} ${getAccuracyBorder(score.accuracy)} text-white rounded-full font-bold text-xs shadow-md mt-0.5 sm:mt-1`}>
                        {formatAccuracy(score.accuracy)}%
                      </div>
                    </div>
                    <div>
                      <span className="text-white/70 text-shadow-adaptive-sm">Combo:</span>
                      <div className="font-mono text-white font-bold text-shadow-adaptive">
                        {formatCombo(score.max_combo)}x
                      </div>
                    </div>
                    <div>
                      <span className="text-white/70 text-shadow-adaptive-sm">Mods:</span>
                      <div className="mt-0.5 sm:mt-1">
                        {mods !== 'None' ? (
                          <span className="text-xs glass-2 text-purple-300 px-1.5 py-0.5 sm:px-2 sm:py-1 rounded-full font-medium">
                            {mods}
                          </span>
                        ) : (
                          <span className="text-xs text-white/60 text-shadow-adaptive-sm">‚Äî</span>
                        )}
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          );
        })}
      </div>
    );
  }

  // Desktop Table View - No glass wrapping, integrated into parent
  return (
    <div className="overflow-x-auto">
      <table className="w-full" role="table" aria-label="Score leaderboard">
        <thead>
          <tr className="border-b border-white/20">
            <th className="py-3 sm:py-4 px-3 sm:px-4 text-xs sm:text-sm font-semibold text-white/90 text-left text-shadow-adaptive-sm">
              Rank
            </th>
            <th className="py-3 sm:py-4 px-3 sm:px-4 text-xs sm:text-sm font-semibold text-white/90 text-left text-shadow-adaptive-sm">
              <SortButton column="player" align="left">Player</SortButton>
            </th>
            <th className="py-3 sm:py-4 px-4 sm:px-6 text-xs sm:text-sm font-semibold text-white/90 text-center text-shadow-adaptive-sm">
              <SortButton column="score" align="center">Score</SortButton>
            </th>
            <th className="py-3 sm:py-4 px-4 sm:px-6 text-xs sm:text-sm font-semibold text-white/90 text-center text-shadow-adaptive-sm">
              <SortButton column="accuracy" align="center">Accuracy</SortButton>
            </th>
            <th className="py-3 sm:py-4 px-4 sm:px-6 text-xs sm:text-sm font-semibold text-white/90 text-center text-shadow-adaptive-sm">
              <SortButton column="combo" align="center">Combo</SortButton>
            </th>
            <th className="py-3 sm:py-4 px-4 sm:px-6 text-xs sm:text-sm font-semibold text-white/90 text-center text-shadow-adaptive-sm">
              Mods
            </th>
          </tr>
        </thead>
        <tbody>
          {sortedScores.map((score, index) => {
            const rank = score.originalRank;
            const username = sanitizeText(score.users?.username || 'Unknown');
            const country = sanitizeText(score.users?.country || '');
            const mods = sanitizeText(score.mods || 'None');
            const isWinner = isRulesetWinner(score);
            const isTop3 = rank <= 3;
            
            return (
              <tr 
                key={score.id || index}
                className={`transition-all border-b border-white/10 last:border-b-0 hover:bg-white/5 ${
                  isTop3 ? 'bg-white/5' : ''
                }`}
                role="row"
              >
                <td className="py-3 sm:py-4 px-3 sm:px-4" role="cell">
                  <div className="flex items-center justify-start">
                    {isTop3 ? (
                      <div className={`w-8 h-8 sm:w-10 sm:h-10 rounded-lg sm:rounded-xl bg-gradient-to-b ${getRankGradient(rank)} flex items-center justify-center shadow-lg`}>
                        <span className="text-white font-black text-xs sm:text-sm text-shadow-adaptive">
                          #{rank}
                        </span>
                      </div>
                    ) : (
                      <span className="text-sm sm:text-lg font-bold text-white/90 text-shadow-adaptive">
                        #{rank}
                      </span>
                    )}
                  </div>
                </td>
                <td className="py-3 sm:py-4 px-3 sm:px-4" role="cell">
                  <div className="flex items-center gap-2 sm:gap-3">
                    {score.users?.avatar_url && (
                      <img 
                        src={score.users.avatar_url} 
                        alt={`${username}'s avatar`}
                        className="w-8 h-8 sm:w-10 sm:h-10 rounded-full avatar-border flex-shrink-0"
                        onError={(e) => { e.target.style.display = 'none'; }}
                      />
                    )}
                    <div className="min-w-0 flex-1">
                      <div className="flex items-center gap-2">
                        <button 
                          className="font-bold text-white hover:text-purple-300 transition-colors text-shadow-adaptive truncate text-left text-sm sm:text-base" 
                          onClick={() => handleUsernameClick(score.users)}
                        >
                          {username}
                        </button>
                        {isWinner && (
                          <span className="inline-flex items-center gap-1 glass-2 text-yellow-300 text-xs font-medium px-2 py-0.5 sm:py-1 rounded-full performance-card-orange">
                            <Target className="w-3 h-3 icon-shadow-adaptive-sm" />
                            Ruleset Winner
                          </span>
                        )}
                      </div>
                      {country && (
                        <div className="flex items-center gap-1 mt-0.5 sm:mt-1">
                          {getCountryFlagUrl(country) && (
                            <img 
                              src={getCountryFlagUrl(country)} 
                              alt={`${country} flag`}
                              className="w-4 h-3 object-cover rounded-sm shadow-sm"
                              onError={(e) => { e.target.style.display = 'none'; }}
                            />
                          )}
                          <span className="text-xs text-white/70 font-medium text-shadow-adaptive-sm">
                            {country.toUpperCase()}
                          </span>
                        </div>
                      )}
                    </div>
                  </div>
                </td>
                <td className="py-3 sm:py-4 px-4 sm:px-6 text-center" role="cell">
                  <span className="font-mono font-bold text-white text-sm sm:text-lg text-glow-blue text-shadow-adaptive">
                    {formatScore(score.score)}
                  </span>
                </td>
                <td className="py-3 sm:py-4 px-4 sm:px-6 text-center" role="cell">
                  <div className={`inline-flex px-2 py-1 sm:px-3 sm:py-1.5 bg-gradient-to-b ${getAccuracyGradient(score.accuracy)} ${getAccuracyBorder(score.accuracy)} text-white rounded-full font-bold text-xs sm:text-sm shadow-md`}>
                    {formatAccuracy(score.accuracy)}%
                  </div>
                </td>
                <td className="py-3 sm:py-4 px-4 sm:px-6 text-center" role="cell">
                  <span className="font-mono text-white font-bold text-sm sm:text-lg text-glow-green text-shadow-adaptive">
                    {formatCombo(score.max_combo)}x
                  </span>
                </td>
                <td className="py-3 sm:py-4 px-4 sm:px-6 text-center" role="cell">
                  {mods !== 'None' ? (
                    <span className="text-xs glass-2 text-purple-300 px-2 py-0.5 sm:py-1 rounded-full font-medium">
                      {mods}
                    </span>
                  ) : (
                    <span className="text-xs text-white/60 text-shadow-adaptive-sm">‚Äî</span>
                  )}
                </td>
              </tr>
            );
          })}
        </tbody>
      </table>
    </div>
  );
}


================================================
FILE: frontend/components/SeasonLeaderboard.js
================================================
import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import { Trophy, Crown, Star, Target, Users, TrendingUp, Award, Medal, Zap, Sparkles, ChevronUp, ChevronDown, Flame, User, Loader2, BarChart3, Percent } from 'lucide-react';

const SeasonLeaderboard = ({ currentUser, selectedSeason }) => {
  const [leaderboard, setLeaderboard] = useState([]);
  const [userPosition, setUserPosition] = useState(null);
  const [initialLoading, setInitialLoading] = useState(true);
  const [leaderboardLoading, setLeaderboardLoading] = useState(false);
  const [loadingMore, setLoadingMore] = useState(false);
  const [error, setError] = useState(null);
  const [viewMode, setViewMode] = useState('full');
  const [hasMore, setHasMore] = useState(false);
  const [currentOffset, setCurrentOffset] = useState(0);
  const [pageSize] = useState(50);
  const router = useRouter();

  const fetchLeaderboard = async (isLoadMore = false, newViewMode = null) => {
    const mode = newViewMode || viewMode;
    
    try {
      if (isLoadMore) {
        setLoadingMore(true);
      } else {
        setLeaderboardLoading(true);
        setError(null);
      }

      const params = new URLSearchParams();
      if (selectedSeason?.id) params.append('seasonId', selectedSeason.id);
      if (currentUser?.id) params.append('userId', currentUser.id);
      
      if (mode === 'context') {
        params.append('withUserContext', 'true');
        params.append('contextRange', '5');
      } else {
        if (isLoadMore) {
          params.append('limit', pageSize.toString());
          params.append('offset', currentOffset.toString());
        } else {
          params.append('limit', '100');
          params.append('offset', '0');
        }
      }

      const response = await fetch(`/api/seasons/leaderboard?${params}`);
      const data = await response.json();

      if (!data.success) {
        throw new Error(data.error || 'Failed to fetch leaderboard');
      }

      const responseData = data.data || data;
      if (isLoadMore) {
        setLeaderboard(prev => [...prev, ...responseData.leaderboard]);
        setCurrentOffset(prev => prev + pageSize);
      } else {
        setLeaderboard(responseData.leaderboard || []);
        setCurrentOffset(responseData.leaderboard?.length || 0);
      }

      setUserPosition(responseData.userPosition);
      setHasMore(responseData.hasMore || false);

    } catch (err) {
      console.error('Error fetching season leaderboard:', err);
      setError(err.message);
    } finally {
      setInitialLoading(false);
      setLeaderboardLoading(false);
      setLoadingMore(false);
    }
  };

  const handleLoadMore = async () => {
    if (loadingMore || !hasMore) return;
    await fetchLeaderboard(true);
  };

  const handleViewModeChange = (newMode) => {
    if (newMode === viewMode) return;
    
    setViewMode(newMode);
    setCurrentOffset(0);
    fetchLeaderboard(false, newMode);
  };

  useEffect(() => {
    setCurrentOffset(0);
    fetchLeaderboard();
  }, [selectedSeason, currentUser]);

  const formatNumber = (num) => {
    if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
    if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
    return num?.toLocaleString() || '0';
  };

  const formatWeightedScore = (score) => {
    return score?.toFixed(1) || '0.0';
  };

  // Helper function to safely calculate top percentage
  const getTopPercentage = (percentile) => {
    if (percentile === null || percentile === undefined || isNaN(percentile)) {
      return null; // Return null if percentile is not available
    }
    return Math.max(1, Math.round(100 - percentile));
  };

  const getAccuracyGradient = (accuracy) => {
    if (accuracy >= 98) return 'from-pink-500 to-purple-500';
    if (accuracy >= 95) return 'from-green-500 to-emerald-500';
    if (accuracy >= 90) return 'from-cyan-500 to-blue-500';
    if (accuracy >= 85) return 'from-yellow-500 to-orange-500';
    return 'from-pink-500 to-red-500';
  };

  const getAccuracyBorder = (accuracy) => {
    if (accuracy >= 98) return 'acc-badge-purple';
    if (accuracy >= 95) return 'acc-badge-green';
    if (accuracy >= 90) return 'acc-badge-blue';
    if (accuracy >= 85) return 'acc-badge-yellow';
    return 'acc-badge-red';
  };

  const getStreakColor = (streak) => {
    if (streak >= 10) return 'text-purple-400';
    if (streak >= 5) return 'text-orange-400';
    if (streak >= 3) return 'text-yellow-400';
    return 'text-gray-400';
  };

  const getPercentileColor = (percentile) => {
    if (percentile >= 95) return 'text-purple-400';
    if (percentile >= 85) return 'text-green-400';
    if (percentile >= 70) return 'text-blue-400';
    if (percentile >= 50) return 'text-yellow-400';
    return 'text-gray-400';
  };

  if (initialLoading) {
    return (
      <div className="space-y-4 sm:space-y-6">
        {/* User Stats Loading Skeleton */}
        <div className="glass-1 rounded-xl sm:rounded-2xl p-4 sm:p-6">
          <div className="animate-pulse">
            <div className="h-4 sm:h-6 bg-gray-200/60 rounded w-24 sm:w-32 mb-3 sm:mb-4"></div>
            <div className="grid grid-cols-2 sm:grid-cols-5 gap-2 sm:gap-4">
              {[...Array(5)].map((_, i) => (
                <div key={i} className="h-12 sm:h-20 bg-gray-200/60 rounded-lg sm:rounded-xl"></div>
              ))}
            </div>
          </div>
        </div>
        
        {/* Leaderboard Loading Skeleton */}
        <div className="glass-1 rounded-xl sm:rounded-2xl p-4 sm:p-12">
          <div className="animate-pulse space-y-3 sm:space-y-4">
            <div className="h-6 sm:h-8 bg-gray-200/60 rounded-lg w-1/2 sm:w-1/3"></div>
            {[...Array(8)].map((_, i) => (
              <div key={i} className="flex items-center space-x-3 sm:space-x-4">
                <div className="w-8 h-8 sm:w-12 sm:h-12 bg-gray-200/60 rounded-full"></div>
                <div className="flex-1 space-y-1 sm:space-y-2">
                  <div className="h-3 sm:h-4 bg-gray-200/60 rounded w-1/3 sm:w-1/4"></div>
                  <div className="h-2 sm:h-3 bg-gray-200/60 rounded w-1/4 sm:w-1/6"></div>
                </div>
                <div className="h-4 sm:h-6 bg-gray-200/60 rounded w-16 sm:w-24"></div>
              </div>
            ))}
          </div>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="glass-1 rounded-2xl sm:rounded-3xl p-6 sm:p-12 text-center">
        <Trophy className="w-8 h-8 sm:w-12 sm:h-12 text-red-500 mx-auto mb-3 sm:mb-4" />
        <p className="text-red-600 mb-3 sm:mb-4 text-sm sm:text-base">Error loading leaderboard: {error}</p>
        <button 
          onClick={() => fetchLeaderboard()}
          className="px-4 py-2 sm:px-6 sm:py-2 bg-red-500 text-white rounded-lg font-medium hover:bg-red-600 transition-colors text-sm sm:text-base"
        >
          Retry
        </button>
      </div>
    );
  }

  return (
    <div className="space-y-4 sm:space-y-6">
      {/* User Performance Panel */}
      {userPosition && (
        <div className="mb-4 sm:mb-6">
          <h3 className="text-lg sm:text-2xl font-bold text-white text-shadow-adaptive mb-3 sm:mb-4 flex items-center gap-2">
            <User className="w-5 h-5 sm:w-7 sm:h-7 icon-shadow-adaptive-sm" />
            Your Performance
          </h3>
          <div className="grid grid-cols-2 sm:grid-cols-5 gap-2 sm:gap-4">
            <div className="glass-1 rounded-lg sm:rounded-xl p-3 sm:p-4 text-center shadow-lg">
              <p className="text-xs text-white/90 font-medium mb-1 sm:mb-2 uppercase tracking-wide text-shadow-adaptive">Your Rank</p>
              <p className="text-xl sm:text-3xl font-black bg-gradient-to-r from-purple-300 to-purple-400 bg-clip-text text-transparent drop-shadow-lg tracking-tight">
                {userPosition.user_position ? `#${userPosition.user_position}` : 'N/A'}
              </p>
            </div>
            <div className="glass-1 rounded-lg sm:rounded-xl p-3 sm:p-4 text-center shadow-lg">
              <p className="text-xs text-white/90 font-medium mb-1 sm:mb-2 uppercase tracking-wide text-shadow-adaptive">Weighted Score</p>
              <p className="text-xl sm:text-3xl font-black bg-gradient-to-r from-emerald-400 to-green-400 bg-clip-text text-transparent drop-shadow-lg tracking-tight">
                {formatWeightedScore(userPosition.final_weighted_score)}
              </p>
            </div>
            <div className="glass-1 rounded-lg sm:rounded-xl p-3 sm:p-4 text-center shadow-lg">
              <p className="text-xs text-white/90 font-medium mb-1 sm:mb-2 uppercase tracking-wide text-shadow-adaptive">Max Streak</p>
              <p className={`text-xl sm:text-3xl font-black drop-shadow-lg tracking-tight ${getStreakColor(userPosition.max_streak)}`}>
                {userPosition.max_streak || 0}
              </p>
            </div>
            <div className="glass-1 rounded-lg sm:rounded-xl p-3 sm:p-4 text-center shadow-lg">
              <p className="text-xs text-white/90 font-medium mb-1 sm:mb-2 uppercase tracking-wide text-shadow-adaptive">Challenges</p>
              <p className="text-xl sm:text-3xl font-black bg-gradient-to-r from-yellow-300 to-yellow-400 bg-clip-text text-transparent drop-shadow-lg tracking-tight">
                {userPosition.challenges_participated || 0}
              </p>
            </div>
            <div className="glass-1 rounded-lg sm:rounded-xl p-3 sm:p-4 text-center shadow-lg">
              <p className="text-xs text-white/90 font-medium mb-1 sm:mb-2 uppercase tracking-wide text-shadow-adaptive">Top</p>
              <p className="text-xl sm:text-3xl font-black bg-gradient-to-r from-blue-400 to-cyan-400 bg-clip-text text-transparent drop-shadow-lg tracking-tight">
                {(() => {
                  const topPercentage = getTopPercentage(userPosition.percentile);
                  return topPercentage !== null ? `${topPercentage}%` : 'N/A';
                })()}
              </p>
            </div>
          </div>
          
          {/* Enhanced Percentile Breakdown */}
          <div className="mt-4 glass-1 rounded-lg sm:rounded-xl p-4 sm:p-6 border border-white/10">
            <div className="flex items-center justify-between mb-4">
              <h4 className="text-sm sm:text-base font-bold text-white text-shadow-adaptive flex items-center gap-2">
                <BarChart3 className="w-4 h-4 sm:w-5 sm:h-5 text-white/80" />
                Points Breakdown
              </h4>
              <div className="flex items-center gap-1 text-xs text-white/60">
                <Award className="w-3 h-3" />
                <span>Out of 100 pts</span>
              </div>
            </div>
            
            <div className="mb-3 text-xs text-white/70 text-shadow-adaptive-sm">
              See how many points you earned from each category
            </div>
            
            <div className="space-y-4">
              {/* Score Points */}
              <div className="relative">
                <div className="flex items-center justify-between mb-2">
                  <div className="flex items-center gap-2">
                    <div className="w-2 h-2 rounded-full bg-gradient-to-r from-blue-400 to-cyan-400"></div>
                    <span className="text-xs sm:text-sm font-medium text-white/90">Total Score</span>
                  </div>
                  <div className="flex items-center gap-1">
                    <span className={`text-lg sm:text-xl font-black ${getPercentileColor(userPosition.score_percentile || 0)} drop-shadow-sm`}>
                      {((userPosition.score_percentile || 0) * 0.7).toFixed(1)}
                    </span>
                    <span className="text-sm sm:text-base text-white/60 font-medium">/ 70</span>
                  </div>
                </div>
                <div className="w-full bg-white/10 rounded-full h-2">
                  <div 
                    className="bg-gradient-to-r from-blue-500 to-cyan-500 h-2 rounded-full transition-all duration-1000 ease-out"
                    style={{ width: `${((userPosition.score_percentile || 0) * 0.7 / 70) * 100}%` }}
                  ></div>
                </div>
                <div className="flex justify-between text-xs text-white/50 mt-1">
                  <span>0 pts</span>
                  <span className="text-white/70">{userPosition.score_percentile ? `${userPosition.score_percentile.toFixed(0)}% placement` : 'N/A'}</span>
                  <span>70 pts</span>
                </div>
              </div>

              {/* Accuracy Points */}
              <div className="relative">
                <div className="flex items-center justify-between mb-2">
                  <div className="flex items-center gap-2">
                    <div className="w-2 h-2 rounded-full bg-gradient-to-r from-green-400 to-emerald-400"></div>
                    <span className="text-xs sm:text-sm font-medium text-white/90">Accuracy</span>
                  </div>
                  <div className="flex items-center gap-1">
                    <span className={`text-lg sm:text-xl font-black ${getPercentileColor(userPosition.accuracy_percentile || 0)} drop-shadow-sm`}>
                      {((userPosition.accuracy_percentile || 0) * 0.15).toFixed(1)}
                    </span>
                    <span className="text-sm sm:text-base text-white/60 font-medium">/ 15</span>
                  </div>
                </div>
                <div className="w-full bg-white/10 rounded-full h-2">
                  <div 
                    className="bg-gradient-to-r from-green-500 to-emerald-500 h-2 rounded-full transition-all duration-1000 ease-out"
                    style={{ width: `${((userPosition.accuracy_percentile || 0) * 0.15 / 15) * 100}%` }}
                  ></div>
                </div>
                <div className="flex justify-between text-xs text-white/50 mt-1">
                  <span>0 pts</span>
                  <span className="text-white/70">{userPosition.accuracy_percentile ? `${userPosition.accuracy_percentile.toFixed(0)}% placement` : 'N/A'}</span>
                  <span>15 pts</span>
                </div>
              </div>

              {/* Streak Points */}
              <div className="relative">
                <div className="flex items-center justify-between mb-2">
                  <div className="flex items-center gap-2">
                    <div className="w-2 h-2 rounded-full bg-gradient-to-r from-orange-400 to-red-400"></div>
                    <span className="text-xs sm:text-sm font-medium text-white/90">Participation Streak</span>
                  </div>
                  <div className="flex items-center gap-1">
                    <span className={`text-lg sm:text-xl font-black ${getPercentileColor(userPosition.streak_percentile || 0)} drop-shadow-sm`}>
                      {((userPosition.streak_percentile || 0) * 0.15).toFixed(1)}
                    </span>
                    <span className="text-sm sm:text-base text-white/60 font-medium">/ 15</span>
                  </div>
                </div>
                <div className="w-full bg-white/10 rounded-full h-2">
                  <div 
                    className="bg-gradient-to-r from-orange-500 to-red-500 h-2 rounded-full transition-all duration-1000 ease-out"
                    style={{ width: `${((userPosition.streak_percentile || 0) * 0.15 / 15) * 100}%` }}
                  ></div>
                </div>
                <div className="flex justify-between text-xs text-white/50 mt-1">
                  <span>0 pts</span>
                  <span className="text-white/70">{userPosition.streak_percentile ? `${userPosition.streak_percentile.toFixed(0)}% placement` : 'N/A'}</span>
                  <span>15 pts</span>
                </div>
              </div>
            </div>

            {/* Overall Performance Indicator - UPDATED WITH CONSISTENT SIZING */}
            <div className="mt-4 pt-4 border-t border-white/10">
              <div className="flex items-center justify-between">
                <span className="text-sm sm:text-base text-white/70 font-medium">Total Points</span>
                <div className="flex items-center gap-2">
                  {(() => {
                    const totalPoints = ((userPosition.score_percentile || 0) * 0.7) + 
                                      ((userPosition.accuracy_percentile || 0) * 0.15) + 
                                      ((userPosition.streak_percentile || 0) * 0.15);
                    
                    let indicator, color, bgColor;
                    
                    if (totalPoints >= 90) {
                      indicator = "Exceptional";
                      color = "text-purple-300";
                      bgColor = "bg-purple-500/20";
                    } else if (totalPoints >= 75) {
                      indicator = "Strong";
                      color = "text-green-300";
                      bgColor = "bg-green-500/20";
                    } else if (totalPoints >= 50) {
                      indicator = "Good";
                      color = "text-blue-300";
                      bgColor = "bg-blue-500/20";
                    } else if (totalPoints >= 25) {
                      indicator = "Developing";
                      color = "text-yellow-300";
                      bgColor = "bg-yellow-500/20";
                    } else {
                      indicator = "Growing";
                      color = "text-orange-300";
                      bgColor = "bg-orange-500/20";
                    }
                    
                    return (
                      <>
                        <span className={`text-xl sm:text-2xl font-black ${color}`}>
                          {totalPoints.toFixed(1)}
                        </span>
                        <span className="text-sm sm:text-base text-white/60 font-medium">/ 100</span>
                        <span className={`px-2 py-1 text-xs font-medium ${color} ${bgColor} rounded-full ml-1`}>
                          {indicator}
                        </span>
                      </>
                    );
                  })()}
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Leaderboard Container */}
      <div>
        <div className="glass-1 rounded-xl sm:rounded-2xl shadow-xl overflow-hidden">
          {/* Header Card */}
          <div className="p-4 sm:p-8">
            <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
              <div>
                <h2 className="text-xl sm:text-3xl font-bold text-white flex items-center gap-2 sm:gap-3 text-shadow-adaptive">
                  <Trophy className="w-6 h-6 sm:w-8 sm:h-8 text-white icon-shadow-adaptive" />
                  Season Rankings
                  <span className="text-sm sm:text-base font-medium bg-purple-600/80 text-white px-2 py-1 rounded-full">
                    Weighted
                  </span>
                </h2>
                {selectedSeason && (
                  <p className="text-white/90 mt-1 text-shadow-adaptive-sm text-sm sm:text-base">
                    {selectedSeason.name} ‚Ä¢ {leaderboard.length} participants shown
                    {hasMore && ' (more available)'}
                  </p>
                )}
              </div>
              
              {/* View Mode Slider */}
              {currentUser && (
                <div className="view-mode-slider text-sm sm:text-base">
                  <div className="slider-track">
                    <div className={`slider-thumb-two-option ${viewMode === 'context' ? 'slider-thumb-two-option-right' : ''}`} />
                    <button
                      onClick={() => handleViewModeChange('full')}
                      className={`slider-option ${viewMode === 'full' ? 'slider-option-active' : ''}`}
                    >
                      <span className="hidden sm:inline">Full Rankings</span>
                      <span className="sm:hidden">Full</span>
                    </button>
                    <button
                      onClick={() => handleViewModeChange('context')}
                      className={`slider-option ${viewMode === 'context' ? 'slider-option-active' : ''}`}
                    >
                      <span className="hidden sm:inline">Around Me</span>
                      <span className="sm:hidden">Around Me</span>
                    </button>
                  </div>
                </div>
              )}
            </div>
          </div>

          {/* Podium Section for Top 3 */}
          {leaderboard.length >= 3 && viewMode === 'full' && !leaderboardLoading && (
            <div className="podium-glass-2-bg p-4 sm:p-8 border-t border-white/10">
              <div className="grid grid-cols-3 gap-2 sm:gap-4 max-w-3xl mx-auto">
                {/* 2nd Place */}
                {leaderboard[1] && (
                  <div className="order-1 md:order-1 flex items-center justify-center">
                    <div className="podium-bg-purple rounded-lg sm:rounded-2xl p-3 sm:p-6 text-center transform hover:scale-105 transition-all shadow-lg podium-border-purple w-full">
                      <div className="w-12 h-12 sm:w-20 sm:h-20 mx-auto mb-2 sm:mb-3 relative">
                        <img
                          src={leaderboard[1].avatar_url || '/default-avatar.png'}
                          alt={leaderboard[1].username}
                          className="w-full h-full rounded-full border-2 sm:border-4 border-white shadow-lg cursor-pointer"
                          onClick={() => router.push(`/profile/${leaderboard[1].user_id}`)}
                          onError={(e) => { e.target.src = '/default-avatar.png'; }}
                        />
                        <div className="absolute -bottom-1 sm:-bottom-2 left-1/2 transform -translate-x-1/2 bg-white text-purple-700 text-xs px-2 sm:px-3 py-0.5 sm:py-1 rounded-full font-bold shadow-lg">
                          2nd
                        </div>
                      </div>
                      <h3 className="font-bold text-white text-shadow-adaptive text-xs sm:text-base truncate cursor-pointer hover:opacity-80 transition-opacity" onClick={() => router.push(`/profile/${leaderboard[1].user_id}`)}>{leaderboard[1].username}</h3>
                      <p className="text-sm sm:text-2xl font-extrabold text-white/90 text-shadow-adaptive mt-1 sm:mt-2">{formatWeightedScore(leaderboard[1].final_weighted_score)} pts</p>
                      
                      {/* Stats Row */}
                      <div className="flex items-center justify-center gap-1 sm:gap-2 mt-2">
                        {/* Accuracy Badge */}
                        <div className={`px-1.5 py-0.5 sm:px-2 bg-gradient-to-b ${getAccuracyGradient(leaderboard[1].average_accuracy)} rounded-full ${getAccuracyBorder(leaderboard[1].average_accuracy)}`}>
                          <span className="text-white font-bold text-xs drop-shadow-md">{leaderboard[1].average_accuracy?.toFixed(1)}%</span>
                        </div>
                        
                        {/* Streak - Always displayed and always orange */}
                        <div className="flex items-center gap-0.5">
                          <Flame className="w-3 h-3 sm:w-4 sm:h-4 text-orange-400" />
                          <span className="text-xs font-bold text-orange-400">{leaderboard[1].max_streak || 0}</span>
                        </div>
                      </div>
                      
                      <p className="text-xs text-white/60 mt-1">{formatNumber(leaderboard[1].total_score)} score</p>
                    </div>
                  </div>
                )}

                {/* 1st Place */}
                {leaderboard[0] && (
                  <div className="order-2 md:order-2 flex justify-center">
                    <div className="podium-bg-blue rounded-lg sm:rounded-2xl p-3 sm:p-6 text-center transform hover:scale-105 transition-all relative shadow-xl podium-border-blue w-full">
                      <Crown className="absolute top-1 right-1 sm:top-2 sm:right-2 w-4 h-4 sm:w-6 sm:h-6 text-white icon-shadow-adaptive" />
                      <div className="w-16 h-16 sm:w-24 sm:h-24 mx-auto mb-2 sm:mb-3 relative">
                        <img
                          src={leaderboard[0].avatar_url || '/default-avatar.png'}
                          alt={leaderboard[0].username}
                          className="w-full h-full rounded-full border-2 sm:border-4 border-white shadow-xl cursor-pointer"
                          onClick={() => router.push(`/profile/${leaderboard[0].user_id}`)}
                          onError={(e) => { e.target.src = '/default-avatar.png'; }}
                        />
                        <div className="absolute -bottom-1 sm:-bottom-2 left-1/2 transform -translate-x-1/2 bg-white text-blue-700 text-xs sm:text-sm px-2 sm:px-3 py-0.5 sm:py-1 rounded-full font-bold shadow-lg">
                          1st
                        </div>
                      </div>
                      <h3 className="font-bold text-white text-shadow-adaptive text-sm sm:text-lg truncate cursor-pointer hover:opacity-80 transition-opacity" onClick={() => router.push(`/profile/${leaderboard[0].user_id}`)}>{leaderboard[0].username}</h3>
                      <p className="text-lg sm:text-3xl font-extrabold text-white/90 text-shadow-adaptive mt-1 sm:mt-2">
                        {formatWeightedScore(leaderboard[0].final_weighted_score)} pts
                      </p>
                      
                      {/* Stats Row */}
                      <div className="flex items-center justify-center gap-1 sm:gap-2 mt-2">
                        {/* Accuracy Badge */}
                        <div className={`px-2 py-0.5 sm:px-2.5 sm:py-1 bg-gradient-to-b ${getAccuracyGradient(leaderboard[0].average_accuracy)} rounded-full ${getAccuracyBorder(leaderboard[0].average_accuracy)}`}>
                          <span className="text-white font-bold text-xs sm:text-sm drop-shadow-md">{leaderboard[0].average_accuracy?.toFixed(1)}%</span>
                        </div>
                        
                        {/* Streak - Always displayed and always orange */}
                        <div className="flex items-center gap-0.5">
                          <Flame className="w-3 h-3 sm:w-4 sm:h-4 text-orange-400" />
                          <span className="text-xs sm:text-sm font-bold text-orange-400">{leaderboard[0].max_streak || 0}</span>
                        </div>
                      </div>
                      
                      <p className="text-xs text-white/60 mt-1">{formatNumber(leaderboard[0].total_score)} score</p>
                    </div>
                  </div>
                )}

                {/* 3rd Place */}
                {leaderboard[2] && (
                  <div className="order-3 md:order-3 flex items-center justify-center">
                    <div className="podium-bg-red rounded-lg sm:rounded-2xl p-3 sm:p-6 text-center transform hover:scale-105 transition-all shadow-lg podium-border-red w-full">
                      <div className="w-12 h-12 sm:w-20 sm:h-20 mx-auto mb-2 sm:mb-3 relative">
                        <img
                          src={leaderboard[2].avatar_url || '/default-avatar.png'}
                          alt={leaderboard[2].username}
                          className="w-full h-full rounded-full border-2 sm:border-4 border-white shadow-lg cursor-pointer"
                          onClick={() => router.push(`/profile/${leaderboard[2].user_id}`)}
                          onError={(e) => { e.target.src = '/default-avatar.png'; }}
                        />
                        <div className="absolute -bottom-1 sm:-bottom-2 left-1/2 transform -translate-x-1/2 bg-white text-red-700 text-xs px-2 sm:px-3 py-0.5 sm:py-1 rounded-full font-bold shadow-lg">
                          3rd
                        </div>
                      </div>
                      <h3 className="font-bold text-white text-shadow-adaptive text-xs sm:text-base truncate cursor-pointer hover:opacity-80 transition-opacity" onClick={() => router.push(`/profile/${leaderboard[2].user_id}`)}>{leaderboard[2].username}</h3>
                      <p className="text-sm sm:text-2xl font-extrabold text-white/90 text-shadow-adaptive mt-1 sm:mt-2">{formatWeightedScore(leaderboard[2].final_weighted_score)} pts</p>
                      
                      {/* Stats Row */}
                      <div className="flex items-center justify-center gap-1 sm:gap-2 mt-2">
                        {/* Accuracy Badge */}
                        <div className={`px-1.5 py-0.5 sm:px-2 bg-gradient-to-b ${getAccuracyGradient(leaderboard[2].average_accuracy)} rounded-full ${getAccuracyBorder(leaderboard[2].average_accuracy)}`}>
                          <span className="text-white font-bold text-xs drop-shadow-md">{leaderboard[2].average_accuracy?.toFixed(1)}%</span>
                        </div>
                        
                        {/* Streak - Always displayed and always orange */}
                        <div className="flex items-center gap-0.5">
                          <Flame className="w-3 h-3 sm:w-4 sm:h-4 text-orange-400" />
                          <span className="text-xs font-bold text-orange-400">{leaderboard[2].max_streak || 0}</span>
                        </div>
                      </div>
                      
                      <p className="text-xs text-white/60 mt-1">{formatNumber(leaderboard[2].total_score)} score</p>
                    </div>
                  </div>
                )}
              </div>
            </div>
          )}
          
          {/* Main Leaderboard */}
          <div className="shadow-xl overflow-hidden">
            {leaderboardLoading ? (
              <div className="p-4 sm:p-8">
                <div className="animate-pulse space-y-3 sm:space-y-4">
                  {[...Array(8)].map((_, i) => (
                    <div key={i} className="flex items-center space-x-3 sm:space-x-4">
                      <div className="w-8 h-8 sm:w-12 sm:h-12 bg-gray-200/60 rounded-full"></div>
                      <div className="flex-1 space-y-1 sm:space-y-2">
                        <div className="h-3 sm:h-4 bg-gray-200/60 rounded w-1/3 sm:w-1/4"></div>
                        <div className="h-2 sm:h-3 bg-gray-200/60 rounded w-1/4 sm:w-1/6"></div>
                      </div>
                      <div className="h-4 sm:h-6 bg-gray-200/60 rounded w-16 sm:w-24"></div>
                    </div>
                  ))}
                </div>
              </div>
            ) : leaderboard.length === 0 ? (
              <div className="text-center py-12 sm:py-16">
                <Trophy className="w-8 h-8 sm:w-12 sm:h-12 text-white/50 mx-auto mb-3 sm:mb-4" />
                <p className="text-white/70 text-shadow-adaptive-sm text-sm sm:text-base">No participants found for this season.</p>
              </div>
            ) : (
              leaderboard.slice(viewMode === 'full' ? 3 : 0).map((user, index) => {
                const position = user.rank_position || user.user_position || user.position;
                const isCurrentUser = currentUser && user.user_id === currentUser.id;
                const isTop10 = position <= 10;
                
                return (
                  <div
                    key={user.user_id}
                    className={`group px-3 sm:px-6 py-3 sm:py-4 transition-all border-b border-white/10 last:border-b-0 ${
                      isCurrentUser 
                        ? 'bg-gradient-to-r from-purple-500/20 to-pink-500/20 border-l-4 border-purple-400 -ml-1' 
                        : user.is_target_user
                        ? 'bg-yellow-500/10'
                        : 'hover:bg-white/5'
                    }`}
                  >
                    <div className="flex items-center gap-2 sm:gap-4">
                      {/* Rank */}
                      <div className={`text-center min-w-[2rem] sm:min-w-[3rem] ${isTop10 ? 'font-black text-lg sm:text-2xl' : 'font-bold text-base sm:text-lg'} text-white text-shadow-adaptive`}>
                        {position || 'N/A'}
                      </div>

                      {/* Player Info */}
                      <div className="flex items-center gap-2 sm:gap-3 flex-1 min-w-0">
                        <div className="relative">
                          <img
                            src={user.avatar_url || '/default-avatar.png'}
                            alt={user.username}
                            className={`${isTop10 ? 'w-8 h-8 sm:w-12 sm:h-12' : 'w-7 h-7 sm:w-10 sm:h-10'} rounded-full avatar-border shadow-md group-hover:shadow-lg transition-shadow cursor-pointer`}
                            onClick={() => router.push(`/profile/${user.user_id}`)}
                            onError={(e) => { e.target.src = '/default-avatar.png'; }}
                          />
                        </div>
                        
                        <div className="min-w-0 flex-1">
                          <div className="flex items-center gap-1 sm:gap-2">
                            <button
                              onClick={() => router.push(`/profile/${user.user_id}`)}
                              className="font-semibold text-white text-shadow-adaptive hover:text-purple-300 transition-colors truncate text-sm sm:text-base"
                            >
                              {user.username}
                            </button>
                            {user.country && (
                              <img 
                                src={`https://flagcdn.com/w20/${user.country.toLowerCase()}.png`}
                                alt={user.country}
                                className="w-4 h-3 sm:w-5 sm:h-3 rounded-sm shadow-sm"
                                onError={(e) => { e.target.style.display = 'none'; }}
                              />
                            )}
                            {isCurrentUser && (
                              <span className="px-1.5 py-0.5 sm:px-2 bg-purple-600/80 text-white text-xs rounded-full font-medium">
                                YOU
                              </span>
                            )}
                            {(user.max_streak || 0) >= 5 && (
                              <Flame className={`w-3 h-3 sm:w-4 sm:h-4 ${getStreakColor(user.max_streak || 0)}`} />
                            )}
                          </div>
                          <div className="flex items-center gap-2 sm:gap-4 text-xs sm:text-sm text-white/90 mt-0.5 text-shadow-adaptive-sm">
                            <span>{user.challenges_participated || 0} challenges</span>
                            {(user.max_streak || 0) > 0 && (
                              <span className={`font-medium ${getStreakColor(user.max_streak || 0)}`}>
                                {user.max_streak} streak
                              </span>
                            )}
                            {user.percentile >= 95 && (
                              <span className="text-purple-300 font-medium hidden sm:inline">
                                Top {Math.max(1, Math.round(100 - Math.floor(user.percentile)))}%
                              </span>
                            )}
                          </div>
                        </div>
                      </div>

                      {/* Stats */}
                      <div className="flex flex-col sm:flex-row items-end sm:items-center gap-2 sm:gap-6">
                        {/* Accuracy Badge */}
                        <div className={`hidden sm:flex w-[60px] sm:w-[72px] py-1 sm:py-1.5 bg-gradient-to-b ${getAccuracyGradient(user.average_accuracy)} ${getAccuracyBorder(user.average_accuracy)} text-white rounded-full font-bold text-xs sm:text-sm shadow-md items-center justify-center`}>
                          <span className="drop-shadow-md">{user.average_accuracy?.toFixed(1) || '0.0'}%</span>
                        </div>

                        {/* Weighted Score */}
                        <div className="text-right min-w-[80px] sm:min-w-[120px]">
                          <p className={`${isTop10 ? 'text-lg sm:text-2xl' : 'text-base sm:text-xl'} font-black text-white text-shadow-adaptive`}>
                            {formatWeightedScore(user.final_weighted_score)} pts
                          </p>
                          {/* Show accuracy on mobile below score and raw score */}
                          <div className="text-xs text-white/70 sm:hidden">
                            {user.average_accuracy?.toFixed(1) || '0.0'}% ‚Ä¢ {formatNumber(user.total_score)}
                          </div>
                          <p className="text-xs text-white/50 hidden sm:block">
                            {formatNumber(user.total_score)} score
                          </p>
                        </div>
                      </div>
                    </div>
                  </div>
                );
              })
            )}
          </div>

          {/* Load More Button */}
          {viewMode === 'full' && hasMore && !leaderboardLoading && (
            <div className="p-4 sm:p-6 text-center border-t border-white/20">
              <button
                onClick={handleLoadMore}
                disabled={loadingMore}
                className={`px-6 sm:px-8 py-2.5 sm:py-3 rounded-xl font-semibold transform transition-all text-sm sm:text-base ${
                  loadingMore
                    ? 'glass-2 text-white/50 cursor-not-allowed'
                    : 'btn-secondary hover:scale-105'
                }`}
              >
                {loadingMore ? (
                  <div className="flex items-center gap-2">
                    <Loader2 className="w-4 h-4 animate-spin" />
                    <span className="text-shadow-adaptive-sm">Loading...</span>
                  </div>
                ) : (
                  <span className="text-shadow-adaptive-sm">
                    <span className="hidden sm:inline">Load More Players (+{pageSize})</span>
                    <span className="sm:hidden">Load More (+{pageSize})</span>
                  </span>
                )}
              </button>
            </div>
          )}

          {/* End of results indicator */}
          {viewMode === 'full' && !hasMore && leaderboard.length > 50 && !leaderboardLoading && (
            <div className="p-4 sm:p-6 text-center border-t border-white/20">
              <div className="flex items-center justify-center gap-2 text-white/90">
                <Trophy className="w-4 h-4 icon-shadow-adaptive-sm" />
                <span className="text-xs sm:text-sm font-medium text-shadow-adaptive-sm">You've reached the end!</span>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default SeasonLeaderboard;


================================================
FILE: frontend/components/SeasonSelector.js
================================================
import { useState, useEffect } from 'react';
import { ChevronDown, Calendar, Clock, X } from 'lucide-react';

export default function SeasonSelector({ onSeasonChange, currentSeasonId }) {
  const [seasons, setSeasons] = useState([]);
  const [selectedSeason, setSelectedSeason] = useState(null);
  const [isOpen, setIsOpen] = useState(false);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchSeasons();
  }, []);

  useEffect(() => {
    if (currentSeasonId && seasons.length > 0) {
      const season = seasons.find(s => s.id === currentSeasonId);
      setSelectedSeason(season || seasons[0]);
    } else if (seasons.length > 0) {
      const currentSeason = seasons.find(s => s.is_current) || seasons[0];
      setSelectedSeason(currentSeason);
    }
  }, [currentSeasonId, seasons]);

  const fetchSeasons = async () => {
    try {
      const response = await fetch('/api/seasons');
      const data = await response.json();
      
      if (data.success) {
        setSeasons(data.data?.seasons || data.seasons || []); // Handle both formats
      }
    } catch (error) {
      console.error('Error fetching seasons:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleSeasonSelect = (season) => {
    setSelectedSeason(season);
    setIsOpen(false);
    if (onSeasonChange) {
      onSeasonChange(season);
    }
  };

  const formatDateRange = (season) => {
    if (!season.start_date || !season.end_date) return '';
    
    const start = new Date(season.start_date).toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric' 
    });
    const end = new Date(season.end_date).toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric',
      year: 'numeric'
    });
    
    return `${start} - ${end}`;
  };

  if (loading) {
    return (
      <div className="w-64 h-12 glass-2 animate-pulse rounded-full"></div>
    );
  }

  if (seasons.length === 0) {
    return null;
  }

  return (
    <div className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="season-selector-btn flex items-center justify-between w-64 px-5 py-3 backdrop-blur-md bg-white/15 rounded-2xl transition-all duration-300 hover:bg-white/20"
      >
        <div className="flex items-center gap-3">
          <Calendar className="w-4 h-4 text-white" />
          <div className="text-left">
            <p className="font-medium text-white text-sm">
              {selectedSeason?.name || 'Select Season'}
            </p>
            {selectedSeason && (
              <p className="text-xs text-white/70">
                {formatDateRange(selectedSeason)}
              </p>
            )}
          </div>
        </div>
        <ChevronDown className={`w-4 h-4 text-white/70 transition-transform ${isOpen ? 'rotate-180' : ''}`} />
      </button>

      {isOpen && (
        <div className="absolute top-full left-0 w-full max-w-64 mt-2 season-dropdown rounded-2xl shadow-lg z-50 max-h-64 overflow-y-auto backdrop-blur-lg">
          {seasons.map((season) => (
            <button
              key={season.id}
              onClick={() => handleSeasonSelect(season)}
              className={`w-full px-5 py-3 text-left hover:bg-white/10 transition-colors border-b border-white/10 last:border-b-0 first:rounded-t-2xl last:rounded-b-2xl ${
                selectedSeason?.id === season.id ? 'bg-white/15 text-white' : 'text-white/90'
              }`}
            >
              <div className="flex items-center justify-between">
                <div>
                  <p className="font-medium flex items-center gap-2 text-sm text-shadow-adaptive-lg">
                    {season.name}
                  </p>
                  <p className="text-xs text-white/60 mt-1 text-shadow-adaptive-lg">
                    {formatDateRange(season)}
                  </p>
                </div>
              </div>
            </button>
          ))}
        </div>
      )}

      {/* Backdrop to close dropdown */}
      {isOpen && (
        <div 
          className="fixed inset-0 z-40" 
          onClick={() => setIsOpen(false)}
        />
      )}
    </div>
  );
}


================================================
FILE: frontend/components/SubscriptionManager.js
================================================
import { useState, useEffect } from 'react';
import { 
  CreditCard, Calendar, DollarSign, AlertCircle, 
  CheckCircle, XCircle, Loader2, X 
} from 'lucide-react';

export default function SubscriptionManager({ user }) {
  const [subscriptions, setSubscriptions] = useState([]);
  const [loading, setLoading] = useState(true);
  const [cancellingId, setCancellingId] = useState(null);
  const [showCancelModal, setShowCancelModal] = useState(false);
  const [selectedSubscription, setSelectedSubscription] = useState(null);

  useEffect(() => {
    fetchSubscriptions();
  }, []);

  const fetchSubscriptions = async () => {
    try {
      const response = await fetch('/api/subscriptions', {
        credentials: 'include'
      });

      if (!response.ok) {
        throw new Error('Failed to fetch subscriptions');
      }

      const data = await response.json();
      setSubscriptions(data.subscriptions || []);
    } catch (err) {
      console.error('Error fetching subscriptions:', err);
      // Silently fail - just don't show subscriptions section
    } finally {
      setLoading(false);
    }
  };

  const handleCancelClick = (subscription) => {
    setSelectedSubscription(subscription);
    setShowCancelModal(true);
  };

  const handleCancelConfirm = async () => {
    if (!selectedSubscription) return;

    try {
      setCancellingId(selectedSubscription.id);
      
      const response = await fetch('/api/subscriptions/cancel', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({
          subscriptionId: selectedSubscription.id
        })
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to cancel subscription');
      }

      // Refresh subscriptions list
      await fetchSubscriptions();
      
      setShowCancelModal(false);
      setSelectedSubscription(null);
      
      alert(`Subscription cancelled successfully. It will remain active until ${new Date(data.cancelsAt).toLocaleDateString()}`);
    } catch (err) {
      console.error('Error cancelling subscription:', err);
      alert(err.message);
    } finally {
      setCancellingId(null);
    }
  };

  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
  };

  const formatAmount = (amount, currency) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: currency || 'USD'
    }).format(amount);
  };

  // Don't render anything while loading or if no subscriptions
  if (loading || subscriptions.length === 0) {
    return null;
  }

  return (
    <>
      <div className="space-y-4">
        <h3 className="text-xl font-bold text-white text-shadow-adaptive flex items-center gap-2">
          <CreditCard className="w-5 h-5 icon-shadow-adaptive" />
          Your Subscriptions
        </h3>

        {subscriptions.map((subscription) => (
          <div 
            key={subscription.id} 
            className="glass-2 rounded-xl p-6 border-2 border-white/10"
          >
            {/* Status Badge */}
            <div className="flex items-center justify-between mb-4">
              <div className="flex items-center gap-2">
                {subscription.cancel_at_period_end ? (
                  <div className="flex items-center gap-2 px-3 py-1 bg-yellow-500/20 border border-yellow-500/40 rounded-full">
                    <AlertCircle className="w-4 h-4 text-yellow-400" />
                    <span className="text-sm font-semibold text-yellow-400">
                      Cancelling
                    </span>
                  </div>
                ) : subscription.status === 'active' ? (
                  <div className="flex items-center gap-2 px-3 py-1 bg-green-500/20 border border-green-500/40 rounded-full">
                    <CheckCircle className="w-4 h-4 text-green-400" />
                    <span className="text-sm font-semibold text-green-400">
                      Active
                    </span>
                  </div>
                ) : (
                  <div className="flex items-center gap-2 px-3 py-1 bg-gray-500/20 border border-gray-500/40 rounded-full">
                    <span className="text-sm font-semibold text-gray-400">
                      {subscription.status}
                    </span>
                  </div>
                )}
              </div>

              {/* Cancel Button */}
              {!subscription.cancel_at_period_end && subscription.status === 'active' && (
                <button
                  onClick={() => handleCancelClick(subscription)}
                  disabled={cancellingId === subscription.id}
                  className="px-4 py-2 rounded-lg bg-red-500/20 hover:bg-red-500/30 border border-red-500/40 text-red-300 font-semibold transition-all disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  {cancellingId === subscription.id ? (
                    <span className="flex items-center gap-2">
                      <Loader2 className="w-4 h-4 animate-spin" />
                      Cancelling...
                    </span>
                  ) : (
                    'Cancel Subscription'
                  )}
                </button>
              )}
            </div>

            {/* Subscription Details */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {/* Amount */}
              <div className="flex items-center gap-3">
                <div className="p-2 bg-blue-500/20 rounded-lg">
                  <DollarSign className="w-5 h-5 text-blue-400" />
                </div>
                <div>
                  <p className="text-sm text-white/60 text-shadow-adaptive-sm">
                    Monthly Amount
                  </p>
                  <p className="text-lg font-bold text-white text-shadow-adaptive">
                    {formatAmount(subscription.amount, subscription.currency)}
                  </p>
                </div>
              </div>

              {/* Next Billing Date */}
              <div className="flex items-center gap-3">
                <div className="p-2 bg-purple-500/20 rounded-lg">
                  <Calendar className="w-5 h-5 text-purple-400" />
                </div>
                <div>
                  <p className="text-sm text-white/60 text-shadow-adaptive-sm">
                    {subscription.cancel_at_period_end ? 'Ends On' : 'Next Billing'}
                  </p>
                  <p className="text-lg font-bold text-white text-shadow-adaptive">
                    {formatDate(subscription.current_period_end)}
                  </p>
                </div>
              </div>
            </div>

            {/* Started Date */}
            <div className="mt-4 pt-4 border-t border-white/10">
              <p className="text-sm text-white/60 text-shadow-adaptive-sm">
                Started: {formatDate(subscription.created)}
              </p>
            </div>

            {/* Cancellation Notice */}
            {subscription.cancel_at_period_end && (
              <div className="mt-4 p-4 bg-yellow-500/10 border border-yellow-500/30 rounded-lg">
                <p className="text-sm text-yellow-300 text-shadow-adaptive-sm">
                  Your subscription will remain active until{' '}
                  <strong>{formatDate(subscription.current_period_end)}</strong>.
                  You'll continue to have access to all donor perks until then.
                </p>
              </div>
            )}
          </div>
        ))}
      </div>

      {/* Cancel Confirmation Modal */}
      {showCancelModal && selectedSubscription && (
        <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 p-4">
          <div className="glass-2 rounded-2xl p-6 max-w-md w-full border-2 border-white/20">
            <div className="flex items-center justify-between mb-4">
              <h3 className="text-xl font-bold text-white text-shadow-adaptive">
                Cancel Subscription?
              </h3>
              <button
                onClick={() => setShowCancelModal(false)}
                className="p-2 hover:bg-white/10 rounded-lg transition-colors"
              >
                <X className="w-5 h-5 text-white/70" />
              </button>
            </div>

            <div className="space-y-4">
              <p className="text-white/80 text-shadow-adaptive-sm">
                Are you sure you want to cancel your monthly subscription of{' '}
                <strong>{formatAmount(selectedSubscription.amount, selectedSubscription.currency)}</strong>?
              </p>

              <div className="glass-1 rounded-lg p-4 space-y-2">
                <div className="flex items-start gap-2">
                  <CheckCircle className="w-5 h-5 text-green-400 mt-0.5 flex-shrink-0" />
                  <p className="text-sm text-white/90 text-shadow-adaptive-sm">
                    Your subscription will remain active until{' '}
                    <strong>{formatDate(selectedSubscription.current_period_end)}</strong>
                  </p>
                </div>
                <div className="flex items-start gap-2">
                  <CheckCircle className="w-5 h-5 text-green-400 mt-0.5 flex-shrink-0" />
                  <p className="text-sm text-white/90 text-shadow-adaptive-sm">
                    You'll keep all your donor perks based on your total donations
                  </p>
                </div>
                <div className="flex items-start gap-2">
                  <XCircle className="w-5 h-5 text-red-400 mt-0.5 flex-shrink-0" />
                  <p className="text-sm text-white/90 text-shadow-adaptive-sm">
                    No more charges after the current period ends
                  </p>
                </div>
              </div>

              <div className="flex gap-3">
                <button
                  onClick={() => setShowCancelModal(false)}
                  className="flex-1 px-4 py-3 rounded-xl bg-white/10 hover:bg-white/20 border border-white/20 text-white font-semibold transition-all"
                >
                  Keep Subscription
                </button>
                <button
                  onClick={handleCancelConfirm}
                  disabled={cancellingId === selectedSubscription.id}
                  className="flex-1 px-4 py-3 rounded-xl bg-red-500/20 hover:bg-red-500/30 border border-red-500/40 text-red-300 font-semibold transition-all disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  {cancellingId === selectedSubscription.id ? (
                    <span className="flex items-center justify-center gap-2">
                      <Loader2 className="w-4 h-4 animate-spin" />
                      Cancelling...
                    </span>
                  ) : (
                    'Cancel Subscription'
                  )}
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </>
  );
}


================================================
FILE: frontend/components/TeamCard.js
================================================
// frontend/components/TeamCard.js - Optimized version
import { Github, Twitter, ExternalLink, User } from 'lucide-react';
import { memo, useMemo } from 'react';

const TeamCard = memo(function TeamCard({ 
  member, 
  size = 'medium', 
  onClick = null,
  isExpanded = false,
  cardRef = null 
}) {
  const sizeConfig = {
    small: {
      avatarSize: 'w-16 h-16',
      textSize: 'text-sm',
      roleTextSize: 'text-xs',
      padding: 'p-3',
      gap: 'gap-2'
    },
    medium: {
      avatarSize: 'w-20 h-20',
      textSize: 'text-base',
      roleTextSize: 'text-sm',
      padding: 'p-4',
      gap: 'gap-3'
    },
    large: {
      avatarSize: 'w-24 h-24',
      textSize: 'text-lg',
      roleTextSize: 'text-base',
      padding: 'p-6',
      gap: 'gap-4'
    }
  };

  const config = sizeConfig[size];

  // Memoize expensive computations
  const avatarUrl = useMemo(() => 
    member.avatar_url || 
    `https://ui-avatars.com/api/?name=${encodeURIComponent(member.name)}&background=9333ea&color=fff&size=256`,
    [member.avatar_url, member.name]
  );

  const roleBadgeClass = useMemo(() => {
    const roleLower = member.role.toLowerCase();
    if (roleLower.includes('lead') || roleLower.includes('project')) {
      return 'staff-badge staff-badge-lead';
    } else if (roleLower.includes('develop') || roleLower.includes('engineer')) {
      return 'staff-badge staff-badge-developer';
    } else if (roleLower.includes('design') || roleLower.includes('ui') || roleLower.includes('ux')) {
      return 'staff-badge staff-badge-designer';
    } else if (roleLower.includes('map') || roleLower.includes('beat')) {
      return 'staff-badge staff-badge-mapper';
    } else if (roleLower.includes('community') || roleLower.includes('manager')) {
      return 'staff-badge staff-badge-strategist';
    } else if (roleLower.includes('qa') || roleLower.includes('test')) {
      return 'staff-badge staff-badge-qa';
    } else if (roleLower.includes('artist') || roleLower.includes('art')) {
      return 'staff-badge staff-badge-artist';
    } else {
      return 'staff-badge staff-badge-strategist';
    }
  }, [member.role]);

  // Optimize social links rendering
  const socialLinks = useMemo(() => {
    if (!member.social_links || Object.keys(member.social_links).length === 0) {
      return null;
    }

    return (
      <div className="flex items-center gap-1 mt-2">
        {member.social_links.github && (
          <a 
            href={`https://github.com/${member.social_links.github}`}
            target="_blank"
            rel="noopener noreferrer"
            className="p-1 glass-1 rounded-lg hover:glass-2 transition-all duration-200"
            onClick={(e) => e.stopPropagation()}
          >
            <Github className="w-3 h-3 text-white/80" />
          </a>
        )}
        {member.social_links.twitter && (
          <a 
            href={`https://twitter.com/${member.social_links.twitter}`}
            target="_blank"
            rel="noopener noreferrer"
            className="p-1 glass-1 rounded-lg hover:glass-2 transition-all duration-200"
            onClick={(e) => e.stopPropagation()}
          >
            <Twitter className="w-3 h-3 text-white/80" />
          </a>
        )}
        {member.social_links.discord && (
          <div className="p-1 glass-1 rounded-lg">
            <span className="text-xs text-white/60" title={`Discord: ${member.social_links.discord}`}>
              üí¨
            </span>
          </div>
        )}
        {member.osu_username && (
          <a 
            href={`https://osu.ppy.sh/users/${member.osu_username}`}
            target="_blank"
            rel="noopener noreferrer"
            className="p-1 glass-1 rounded-lg hover:glass-2 transition-all duration-200"
            onClick={(e) => e.stopPropagation()}
          >
            <ExternalLink className="w-3 h-3 text-white/80" />
          </a>
        )}
      </div>
    );
  }, [member.social_links, member.osu_username]);

  const handleImageError = useMemo(() => (e) => {
    e.target.onerror = null;
    e.target.src = `https://ui-avatars.com/api/?name=${encodeURIComponent(member.name)}&background=9333ea&color=fff&size=256`;
  }, [member.name]);

  return (
    <div
      ref={cardRef}
      onClick={() => onClick && onClick(member)}
      className={`
        group cursor-pointer transition-all duration-300 ease-out will-change-transform
        ${isExpanded ? 'opacity-0 pointer-events-none' : 'hover:scale-[1.02]'}
        ${onClick ? 'cursor-pointer' : 'cursor-default'}
      `}
    >
      <div className="relative overflow-hidden rounded-2xl transition-all duration-300 hover:scale-[1.02] hover:shadow-2xl glass-2">
        
        {/* Content */}
        <div className={`relative z-10 ${config.padding} flex flex-col items-center ${config.gap}`}>
          {/* Avatar */}
          <div className={`${config.avatarSize} rounded-2xl overflow-hidden bg-white shadow-md transition-all duration-300 group-hover:shadow-xl group-hover:scale-110 group-hover:rounded-xl avatar-border`}>
            <img
              src={avatarUrl}
              alt={member.name}
              className="w-full h-full object-cover"
              onError={handleImageError}
              loading="lazy"
            />
          </div>
          
          {/* Member info */}
          <div className="text-center">
            <h3 className={`${config.textSize} font-semibold text-white group-hover:text-white transition-colors duration-300 text-shadow-adaptive mb-1`}>
              {member.name}
            </h3>
            
            {/* Role badge */}
            <div className={roleBadgeClass}>
              {member.role}
            </div>

            {/* Social links - only show if not clicking for modal */}
            {!onClick && size !== 'small' && socialLinks}
            
            {/* Bio preview (if available and not small size) - Hidden when morphing is enabled */}
            {member.bio && size !== 'small' && !onClick && (
              <p className="text-xs text-white/70 mt-2 line-clamp-2 max-w-[150px] text-shadow-adaptive-sm">
                {member.bio}
              </p>
            )}
          </div>
          
          {/* Click indicator */}
          {onClick && (
            <div className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity duration-300">
              <User className="w-4 h-4 text-white/80" />
            </div>
          )}
        </div>
      </div>
    </div>
  );
});

export default TeamCard;


================================================
FILE: frontend/components/UserStats.js
================================================
import { Activity, Star, TrendingUp, Award } from 'lucide-react';

export default function UserStats({ stats }) {
  const statCards = [
    {
      title: 'Total Challenges',
      value: stats.totalChallenges,
      icon: Activity,
      color: 'text-purple-700',
      bgColor: 'from-purple-50 to-purple-100',
      borderColor: 'border-purple-200',
      hoverBorder: 'hover:border-purple-300',
    },
    {
      title: 'Best Rank',
      value: stats.bestRank ? `#${stats.bestRank}` : 'N/A',
      icon: Star,
      color: 'text-yellow-700',
      bgColor: 'from-yellow-50 to-orange-100',
      borderColor: 'border-yellow-200',
      hoverBorder: 'hover:border-yellow-300',
    },
    {
      title: 'Avg Accuracy',
      value: `${stats.avgAccuracy}%`,
      icon: TrendingUp,
      color: 'text-green-700',
      bgColor: 'from-green-50 to-emerald-100',
      borderColor: 'border-green-200',
      hoverBorder: 'hover:border-green-300',
    },
  ];

  return (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
      {statCards.map((stat, index) => (
        <div
          key={index}
          className={`bg-gradient-to-br ${stat.bgColor} border ${stat.borderColor} rounded-xl p-6 ${stat.hoverBorder} transition-all shadow-sm hover:shadow-md`}
        >
          <div className="flex items-center justify-between mb-2">
            <h3 className="text-lg font-semibold text-neutral-800">{stat.title}</h3>
            <stat.icon className={`w-5 h-5 ${stat.color}`} />
          </div>
          <p className={`text-3xl font-bold ${stat.color}`}>
            {stat.value}
          </p>
        </div>
      ))}
    </div>
  );
}


================================================
FILE: frontend/components/settings/AppearanceTab.js
================================================
import { useState, useEffect } from 'react';
import { useSettings } from '../../lib/SettingsContext';
import ColorPicker from './ColorPicker';
import { Palette, Sliders, RotateCcw } from 'lucide-react';

export default function AppearanceTab() {
  const { settings, updateSettings, resetSettings } = useSettings();
  const [localSettings, setLocalSettings] = useState({
    background_type: settings.background_type,
    background_gradient_type: settings.background_gradient_type || 'linear',
    background_gradient_angle: settings.background_gradient_angle || 135,
    background_color: settings.background_color,
    background_gradient_end: settings.background_gradient_end,
    background_blur: settings.background_blur,
    background_dimming: settings.background_dimming,
    background_saturation: settings.background_saturation
  });

  useEffect(() => {
    setLocalSettings({
      background_type: settings.background_type,
      background_gradient_type: settings.background_gradient_type || 'linear',
      background_gradient_angle: settings.background_gradient_angle || 135,
      background_color: settings.background_color,
      background_gradient_end: settings.background_gradient_end,
      background_blur: settings.background_blur,
      background_dimming: settings.background_dimming,
      background_saturation: settings.background_saturation
    });
  }, [settings]);

  const handleChange = (key, value) => {
    const newSettings = { ...localSettings, [key]: value };
    setLocalSettings(newSettings);
    updateSettings(newSettings, true); 
  };

  const handleReset = async () => {
    await resetSettings('appearance');
  };

  // Enhanced preset themes with different gradient types
  const presets = [
    { name: 'Ice & Fire', type: 'gradient', gradientType: 'linear', angle: 135, color: '#FF5714', gradientEnd: '#1056F9' },
    { name: 'Ocean Breeze', type: 'gradient', gradientType: 'linear', angle: 135, color: '#1E90FF', gradientEnd: '#00BFFF' },
    { name: 'Purple Dream', type: 'gradient', gradientType: 'linear', angle: 135, color: '#9370DB', gradientEnd: '#BA55D3' },
    { name: 'Sunset Glow', type: 'gradient', gradientType: 'radial', color: '#FF6B35', gradientEnd: '#004E89' },
    { name: 'Magenta Burst', type: 'gradient', gradientType: 'radial', color: '#E535AB', gradientEnd: '#6366F1' },
    { name: 'Neon Spin', type: 'gradient', gradientType: 'conic', color: '#FF00FF', gradientEnd: '#00FFFF' },
    { name: 'Rose Gold', type: 'gradient', gradientType: 'linear', angle: 45, color: '#E91E63', gradientEnd: '#FF9800' },
    { name: 'Dark Theme', type: 'gradient', gradientType: 'linear', angle: 135, color: '#121212', gradientEnd: '#563E3E' }
  ];

  const applyPreset = (preset) => {
    const newSettings = {
      background_type: preset.type,
      background_gradient_type: preset.gradientType || 'linear',
      background_gradient_angle: preset.angle || 135,
      background_color: preset.color,
      background_gradient_end: preset.gradientEnd || preset.color
    };
    
    setLocalSettings(prev => ({ ...prev, ...newSettings }));
    updateSettings(newSettings, true);
  };

  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-xl sm:text-2xl font-bold text-white mb-4 flex items-center gap-2 text-shadow-adaptive">
          <Palette className="w-5 h-5 sm:w-6 sm:h-6 icon-shadow-adaptive" />
          Background Appearance
        </h2>
        <p className="text-white/80 text-sm sm:text-base text-shadow-adaptive-sm">
          Customize how your background looks across the entire site
        </p>
      </div>

      <>
        {/* Background Type */}
        <div className="space-y-4">
          <h3 className="text-lg font-semibold text-white text-shadow-adaptive">Background Type</h3>
          <div className="flex gap-3">
            <button
              onClick={() => handleChange('background_type', 'solid')}
              className={`px-4 py-2 rounded-lg font-medium transition-all ${
                localSettings.background_type === 'solid'
                  ? 'glass-2 text-white shadow-lg'
                  : 'glass-1 text-white/80 hover:text-white'
              }`}
            >
              Solid Color
            </button>
            <button
              onClick={() => handleChange('background_type', 'gradient')}
              className={`px-4 py-2 rounded-lg font-medium transition-all ${
                localSettings.background_type === 'gradient'
                  ? 'glass-2 text-white shadow-lg'
                  : 'glass-1 text-white/80 hover:text-white'
              }`}
            >
              Gradient
            </button>
          </div>
        </div>

        {/* Gradient Type Selection */}
        {localSettings.background_type === 'gradient' && (
          <div className="space-y-4">
            <h3 className="text-lg font-semibold text-white text-shadow-adaptive">Gradient Style</h3>
            <div className="grid grid-cols-3 gap-3">
              <button
                onClick={() => handleChange('background_gradient_type', 'linear')}
                className={`px-4 py-2 rounded-lg font-medium transition-all ${
                  localSettings.background_gradient_type === 'linear'
                    ? 'glass-2 text-white shadow-lg'
                    : 'glass-1 text-white/80 hover:text-white'
                }`}
              >
                Linear
              </button>
              <button
                onClick={() => handleChange('background_gradient_type', 'radial')}
                className={`px-4 py-2 rounded-lg font-medium transition-all ${
                  localSettings.background_gradient_type === 'radial'
                    ? 'glass-2 text-white shadow-lg'
                    : 'glass-1 text-white/80 hover:text-white'
                }`}
              >
                Radial
              </button>
              <button
                onClick={() => handleChange('background_gradient_type', 'conic')}
                className={`px-4 py-2 rounded-lg font-medium transition-all ${
                  localSettings.background_gradient_type === 'conic'
                    ? 'glass-2 text-white shadow-lg'
                    : 'glass-1 text-white/80 hover:text-white'
                }`}
              >
                Conic
              </button>
            </div>
          </div>
        )}

        {/* Gradient Angle (only for linear gradients) */}
        {localSettings.background_type === 'gradient' && localSettings.background_gradient_type === 'linear' && (
          <div className="space-y-4">
            <div className="flex justify-between mb-2">
              <label className="text-sm font-medium text-white/90 text-shadow-adaptive-sm">Gradient Angle</label>
              <span className="text-sm text-white/70 text-shadow-adaptive-sm">{localSettings.background_gradient_angle ?? 135}¬∞</span>
            </div>
            <input
              type="range"
              min="1"
              max="360"
              step="1"
              value={localSettings.background_gradient_angle ?? 135}
              onChange={(e) => handleChange('background_gradient_angle', Number(e.target.value))}
              className="w-full h-2 bg-white/20 rounded-lg appearance-none cursor-pointer slider"
            />
            <div className="flex justify-between mt-1">
              <span className="text-xs text-white/50">1¬∞</span>
              <span className="text-xs text-white/50">180¬∞</span>
              <span className="text-xs text-white/50">360¬∞</span>
            </div>
          </div>
        )}

        {/* Preset Themes */}
        <div className="space-y-4">
          <h3 className="text-lg font-semibold text-white text-shadow-adaptive">Quick Presets</h3>
          <div className="grid grid-cols-2 sm:grid-cols-4 gap-3">
            {presets.map((preset) => (
              <button
                key={preset.name}
                onClick={() => applyPreset(preset)}
                className="glass-1 hover:glass-2 rounded-lg p-3 transition-all group"
              >
                <div 
                  className="w-full h-12 rounded-lg mb-2 shadow-inner"
                  style={{
                    background: preset.type === 'gradient' 
                      ? preset.gradientType === 'linear'
                        ? `linear-gradient(${preset.angle || 135}deg, ${preset.color} 0%, ${preset.gradientEnd} 100%)`
                        : preset.gradientType === 'radial'
                        ? `radial-gradient(circle at center, ${preset.color} 0%, ${preset.gradientEnd} 100%)`
                        : `conic-gradient(from 0deg at center, ${preset.color} 0%, ${preset.gradientEnd} 50%, ${preset.color} 100%)`
                      : preset.color
                  }}
                />
                <span className="text-xs text-white/80 group-hover:text-white text-shadow-adaptive-sm">
                  {preset.name}
                </span>
              </button>
            ))}
          </div>
        </div>

        {/* Color Selection */}
        <div className="space-y-6">
          <div>
            <h3 className="text-lg font-semibold text-white mb-4 text-shadow-adaptive">Colors</h3>
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-6">
              <div>
                <label className="block text-sm font-medium text-white/90 mb-2 text-shadow-adaptive-sm">
                  {localSettings.background_type === 'gradient' ? 'Start Color' : 'Background Color'}
                </label>
                <ColorPicker
                  color={localSettings.background_color}
                  onChange={(color) => handleChange('background_color', color)}
                />
              </div>
              
              {localSettings.background_type === 'gradient' && (
                <div>
                  <label className="block text-sm font-medium text-white/90 mb-2 text-shadow-adaptive-sm">
                    End Color
                  </label>
                  <ColorPicker
                    color={localSettings.background_gradient_end}
                    onChange={(color) => handleChange('background_gradient_end', color)}
                  />
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Adjustment Sliders */}
        <div className="space-y-6">
          <h3 className="text-lg font-semibold text-white text-shadow-adaptive flex items-center gap-2">
            <Sliders className="w-5 h-5 icon-shadow-adaptive" />
            Adjustments
          </h3>
          
          {/* Blur */}
          <div>
            <div className="flex justify-between mb-2">
              <label className="text-sm font-medium text-white/90 text-shadow-adaptive-sm">Blur</label>
              <span className="text-sm text-white/70 text-shadow-adaptive-sm">{localSettings.background_blur}%</span>
            </div>
            <input
              type="range"
              min="0"
              max="12"
              value={localSettings.background_blur}
              onChange={(e) => handleChange('background_blur', parseInt(e.target.value))}
              className="w-full h-2 bg-white/20 rounded-lg appearance-none cursor-pointer slider"
            />
            <div className="flex justify-between mt-1">
              <span className="text-xs text-white/50">0%</span>
              <span className="text-xs text-white/50">12%</span>
            </div>
          </div>

          {/* Dimming */}
          <div>
            <div className="flex justify-between mb-2">
              <label className="text-sm font-medium text-white/90 text-shadow-adaptive-sm">Dimming</label>
              <span className="text-sm text-white/70 text-shadow-adaptive-sm">{localSettings.background_dimming}%</span>
            </div>
            <input
              type="range"
              min="20"
              max="70"
              value={localSettings.background_dimming}
              onChange={(e) => handleChange('background_dimming', parseInt(e.target.value))}
              className="w-full h-2 bg-white/20 rounded-lg appearance-none cursor-pointer slider"
            />
            <div className="flex justify-between mt-1">
              <span className="text-xs text-white/50">20%</span>
              <span className="text-xs text-white/50">70%</span>
            </div>
          </div>

          {/* Saturation */}
          <div>
            <div className="flex justify-between mb-2">
              <label className="text-sm font-medium text-white/90 text-shadow-adaptive-sm">Saturation</label>
              <span className="text-sm text-white/70 text-shadow-adaptive-sm">
                {localSettings.background_saturation > 0 ? '+' : ''}{localSettings.background_saturation}%
              </span>
            </div>
            <input
              type="range"
              min="-15"
              max="15"
              value={localSettings.background_saturation}
              onChange={(e) => handleChange('background_saturation', parseInt(e.target.value))}
              className="w-full h-2 bg-white/20 rounded-lg appearance-none cursor-pointer slider"
            />
            <div className="flex justify-between mt-1">
              <span className="text-xs text-white/50">-15%</span>
              <span className="text-xs text-white/50">0%</span>
              <span className="text-xs text-white/50">+15%</span>
            </div>
          </div>
        </div>
      </>

      {/* Reset Button */}
      <div className="pt-4 border-t border-white/10">
        <button
          onClick={handleReset}
          className="flex items-center gap-2 px-4 py-2 glass-1 hover:glass-2 text-white/80 hover:text-white rounded-lg transition-all"
        >
          <RotateCcw className="w-4 h-4" />
          Reset to Defaults
        </button>
      </div>
    </div>
  );
}


================================================
FILE: frontend/components/settings/ColorPicker.js
================================================
import { useState, useRef, useEffect } from 'react';
import { Pipette } from 'lucide-react';

// Move utility functions outside component to avoid hoisting issues
const hexToHsl = (hex) => {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  if (!result) return { h: 0, s: 100, l: 50 };
  
  let r = parseInt(result[1], 16) / 255;
  let g = parseInt(result[2], 16) / 255;
  let b = parseInt(result[3], 16) / 255;
  
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h, s, l = (max + min) / 2;
  
  if (max === min) {
    h = s = 0;
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    
    switch (max) {
      case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
      case g: h = ((b - r) / d + 2) / 6; break;
      case b: h = ((r - g) / d + 4) / 6; break;
    }
  }
  
  return {
    h: Math.round(h * 360),
    s: Math.round(s * 100),
    l: Math.round(l * 100)
  };
};

const hslToHex = (h, s, l) => {
  h = h / 360;
  s = s / 100;
  l = l / 100;
  
  let r, g, b;
  
  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  
  const toHex = x => {
    const hex = Math.round(x * 255).toString(16);
    return hex.length === 1 ? '0' + hex : hex;
  };
  
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
};

const isValidHex = (hex) => {
  return /^#?([a-f\d]{6})$/i.test(hex);
};

export default function ColorPicker({ color, onChange }) {
  const [isOpen, setIsOpen] = useState(false);
  const [hexInput, setHexInput] = useState('');
  const [hexError, setHexError] = useState(false);
  const pickerRef = useRef(null);
  
  // Initialize HSL from prop only once and manage state independently
  const getInitialHSL = (hexColor) => {
    const hsl = hexToHsl(hexColor);
    return {
      h: hsl.h,
      s: hsl.s,
      l: hsl.l
    };
  };

  const [hslState, setHslState] = useState(() => getInitialHSL(color));

  // Close picker when clicking outside
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (pickerRef.current && !pickerRef.current.contains(event.target)) {
        setIsOpen(false);
      }
    };

    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside);
      return () => document.removeEventListener('mousedown', handleClickOutside);
    }
  }, [isOpen]);

  // Only sync from prop when picker is closed (not during user interaction)
  useEffect(() => {
    if (!isOpen) {
      const newHSL = getInitialHSL(color);
      setHslState(newHSL);
      setHexInput('');
      setHexError(false);
    }
  }, [color, isOpen]);

  const handleHueChange = (e) => {
    const newHue = parseInt(e.target.value);
    const newHSL = { ...hslState, h: newHue };
    setHslState(newHSL);
    onChange(hslToHex(newHSL.h, newHSL.s, newHSL.l));
  };

  const handleSaturationChange = (e) => {
    const newSat = parseInt(e.target.value);
    const newHSL = { ...hslState, s: newSat };
    setHslState(newHSL);
    onChange(hslToHex(newHSL.h, newHSL.s, newHSL.l));
  };

  const handleLightnessChange = (e) => {
    const newLight = parseInt(e.target.value);
    const newHSL = { ...hslState, l: newLight };
    setHslState(newHSL);
    onChange(hslToHex(newHSL.h, newHSL.s, newHSL.l));
  };

  const handleHexInputChange = (e) => {
    const value = e.target.value.toUpperCase().replace('#', '');
    setHexInput(value);
    
    // Only validate and apply if there's a value
    if (value.length === 0) {
      setHexError(false);
      return;
    }
    
    // Add # for validation
    const hexValue = '#' + value;
    
    // Validate and apply if valid (6 characters)
    if (value.length === 6 && isValidHex(hexValue)) {
      setHexError(false);
      const newHSL = hexToHsl(hexValue);
      setHslState(newHSL);
      onChange(hexValue); // Send the actual hex value typed, not the converted one
    } else if (value.length >= 6) {
      setHexError(true);
    } else {
      setHexError(false);
    }
  };

  const handleHexInputBlur = () => {
    // Reset to current color if invalid
    if (hexError || (hexInput && !isValidHex('#' + hexInput.replace('#', '')))) {
      setHexInput('');
      setHexError(false);
    }
  };

  // Get current color for display (use prop when closed, state when open)
  const displayColor = isOpen ? hslToHex(hslState.h, hslState.s, hslState.l) : color;

  return (
    <div className="relative" ref={pickerRef}>
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="w-full glass-1 rounded-lg p-3 flex items-center gap-3 hover:glass-2 transition-all"
      >
        <div 
          className="w-10 h-10 rounded-lg shadow-inner border-2 border-white/20"
          style={{ backgroundColor: displayColor }}
        />
        <div className="flex-1 text-left">
          <span className="text-white font-mono text-shadow-adaptive">{displayColor.toUpperCase()}</span>
        </div>
        <Pipette className="w-5 h-5 text-white/70 icon-shadow-adaptive-sm" />
      </button>

      {isOpen && (
        <div className="absolute top-full mt-2 w-full rounded-xl p-4 shadow-2xl z-50 space-y-4" style={{
          backdropFilter: 'blur(24px) brightness(0.7)',
          WebkitBackdropFilter: 'blur(24px) brightness(0.7)',
          backgroundColor: 'rgba(0, 0, 0, 0.3)',
          border: '3px solid rgba(255, 255, 255, 0.3)',
          boxShadow: '0 8px 32px 0 rgba(0, 0, 0, 0.3), 0 0 10px rgba(255, 255, 255, 0.15)'
        }}>
          {/* Color Preview */}
          <div 
            className="w-full h-20 rounded-lg shadow-inner border-2 border-white/20"
            style={{ backgroundColor: hslToHex(hslState.h, hslState.s, hslState.l) }}
          />

          {/* Hex Input */}
          <div>
            <label className="text-sm font-medium text-white/90 text-shadow-adaptive-sm mb-2 block">
              Hex Code
            </label>
            <input
              type="text"
              value={hexInput}
              onChange={handleHexInputChange}
              onBlur={handleHexInputBlur}
              onFocus={() => setHexInput(hslToHex(hslState.h, hslState.s, hslState.l).replace('#', ''))}
              placeholder="FFFFFF"
              maxLength={6}
              className={`w-full px-3 py-2 rounded-lg font-mono text-base transition-all ${
                hexError 
                  ? 'glass-1 border-2 border-red-500 text-red-300 placeholder-red-300/50' 
                  : 'glass-1 border-2 border-white/20 text-white placeholder-white/40'
              } focus:outline-none focus:border-white/40`}
              style={{ 
                letterSpacing: '0.05em',
                textTransform: 'uppercase'
              }}
            />
            {hexError && (
              <p className="text-xs text-red-300 mt-1 text-shadow-adaptive-sm">
                Invalid hex code (use format: FFFFFF or #FFFFFF)
              </p>
            )}
          </div>

          {/* Hue Slider */}
          <div>
            <label className="text-sm font-medium text-white/90 text-shadow-adaptive-sm">Hue</label>
            <input
              type="range"
              min="0"
              max="360"
              value={hslState.h}
              onChange={handleHueChange}
              className="w-full h-4 rounded-lg appearance-none cursor-pointer mt-2"
              style={{
                background: `linear-gradient(to right, 
                  hsl(0, 100%, 50%), 
                  hsl(60, 100%, 50%), 
                  hsl(120, 100%, 50%), 
                  hsl(180, 100%, 50%), 
                  hsl(240, 100%, 50%), 
                  hsl(300, 100%, 50%), 
                  hsl(360, 100%, 50%))`
              }}
            />
          </div>

          {/* Saturation Slider */}
          <div>
            <label className="text-sm font-medium text-white/90 text-shadow-adaptive-sm">Saturation</label>
            <input
              type="range"
              min="0"
              max="100"
              value={hslState.s}
              onChange={handleSaturationChange}
              className="w-full h-4 rounded-lg appearance-none cursor-pointer mt-2"
              style={{
                background: `linear-gradient(to right, 
                  hsl(${hslState.h}, 0%, ${hslState.l}%), 
                  hsl(${hslState.h}, 100%, ${hslState.l}%))`
              }}
            />
          </div>

          {/* Lightness Slider */}
          <div>
            <label className="text-sm font-medium text-white/90 text-shadow-adaptive-sm">Lightness</label>
            <input
              type="range"
              min="0"
              max="100"
              value={hslState.l}
              onChange={handleLightnessChange}
              className="w-full h-4 rounded-lg appearance-none cursor-pointer mt-2"
              style={{
                background: `linear-gradient(to right, 
                  hsl(${hslState.h}, ${hslState.s}%, 0%), 
                  hsl(${hslState.h}, ${hslState.s}%, 50%), 
                  hsl(${hslState.h}, ${hslState.s}%, 100%))`
              }}
            />
          </div>
        </div>
      )}
    </div>
  );
}


================================================
FILE: frontend/components/settings/DonorPerksTab.js
================================================
// components/settings/DonorPerksTab.js
import { useState, useEffect } from 'react';
import { useSettings } from '../../lib/SettingsContext';
import { Gift, Heart, Star, Lock, Check, ChevronRight, Sparkles, Palette } from 'lucide-react';
import Link from 'next/link';

export default function DonorPerksTab() {
  const { settings, donorStatus, availableBackgrounds, updateSettings } = useSettings();
  const [selectedBackground, setSelectedBackground] = useState(settings.background_id); // Updated field name

  const handleBackgroundSelect = (backgroundId) => {
    setSelectedBackground(backgroundId);
    updateSettings({ background_id: backgroundId }, true); // Preview mode, updated field name
  };

  const formatAmount = (amount) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 0
    }).format(amount);
  };

  // Get selected style based on background category
  const getSelectedStyle = (bg) => {
    const baseStyle = 'backdrop-blur-md border-2 shadow-lg';
    
    if (bg?.category === 'premium') {
      return `${baseStyle} bg-purple-400/20 border-purple-400/40 shadow-purple-400/20`;
    }
    if (bg?.category === 'donor') {
      return `${baseStyle} bg-blue-400/20 border-blue-400/40 shadow-blue-400/20`;
    }
    // Public backgrounds and default
    return `${baseStyle} bg-white/20 border-white/30 shadow-white/10`;
  };

  // Updated donor tiers with new pricing
  const donorTiers = [
    {
      name: 'Supporter',
      minAmount: 1, // Any amount (but $1 minimum for Stripe)
      color: 'from-blue-500 to-cyan-500',
      borderColor: 'border-blue-400',
      perks: [
        'Supporter badge on profile',
        'Access to donor-exclusive backgrounds',
        'Priority sync for scores',
        'Early access to new features'
      ]
    },
    {
      name: 'Premium Supporter',
      minAmount: 10, // Changed from $25 to $10
      color: 'from-purple-500 to-pink-500',
      borderColor: 'border-purple-400',
      perks: [
        'All Supporter perks',
        'Exclusive premium backgrounds',
        'Custom profile effects',
        'Special username gradient',
        'Beta feature access'
      ]
    }
  ];

  const currentTier = donorStatus?.tier;
  const totalDonations = donorStatus?.totalDonations || 0;

  // Separate backgrounds by category for display
  const publicBackgrounds = availableBackgrounds.filter(bg => bg.category === 'public');
  const donorBackgrounds = availableBackgrounds.filter(bg => bg.category === 'donor');
  const premiumBackgrounds = availableBackgrounds.filter(bg => bg.category === 'premium');

  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-xl sm:text-2xl font-bold text-white mb-4 flex items-center gap-2 text-shadow-adaptive">
          <Gift className="w-5 h-5 sm:w-6 sm:h-6 icon-shadow-adaptive" />
          Backgrounds & Donor Perks
        </h2>
        <p className="text-white/80 text-sm sm:text-base text-shadow-adaptive-sm">
          {donorStatus?.isDonor 
            ? "Thank you for supporting osu!Challengers! üíñ" 
            : "Customize your experience with beautiful backgrounds and support the community!"
          }
        </p>
      </div>

      {/* Community Artist Backgrounds - Available to Everyone */}
      {publicBackgrounds.length > 0 && (
        <div className="space-y-4">
          <h3 className="text-lg font-semibold text-white text-shadow-adaptive flex items-center gap-2">
            <Palette className="w-5 h-5 icon-shadow-adaptive" />
            Artist Backgrounds
          </h3>
          <p className="text-white/80 text-sm text-shadow-adaptive-sm">
            Beautiful backgrounds created by community artists - free for everyone!
          </p>
          
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
            {/* Default option */}
            <button
              onClick={() => handleBackgroundSelect(null)}
              className={`rounded-xl p-4 transition-all duration-300 ${
                selectedBackground === null
                  ? getSelectedStyle()
                  : 'glass-1 hover:glass-2 border-2 border-transparent'
              }`}
            >
              <div className="aspect-video rounded-lg bg-gradient-to-br from-[#FF5714] to-[#1056F9] mb-3" />
              <h4 className="font-semibold text-white text-shadow-adaptive">Default Theme</h4>
              <p className="text-sm text-white/70 text-shadow-adaptive-sm">Use color settings</p>
            </button>

            {/* Public backgrounds */}
            {publicBackgrounds.map((bg) => (
              <button
                key={bg.id}
                onClick={() => handleBackgroundSelect(bg.id)}
                className={`rounded-xl p-4 transition-colors duration-300 ${
                  selectedBackground === bg.id 
                    ? getSelectedStyle(bg) 
                    : 'glass-1 hover:glass-2 border-2 border-transparent'
                }`}
              >
                <div 
                  className="aspect-video rounded-lg mb-3 bg-cover bg-center"
                  style={{ backgroundImage: `url(${bg.preview_url || bg.image_url})` }}
                />
                <h4 className="font-semibold text-white text-shadow-adaptive">{bg.name}</h4>
                {bg.description && (
                  <p className="text-sm text-white/70 text-shadow-adaptive-sm">{bg.description}</p>
                )}
                <div className="mt-2 flex items-center gap-1 text-xs text-green-400 text-shadow-sm">
                  <Check className="w-3 h-3" />
                  Free for everyone
                </div>
              </button>
            ))}
          </div>
        </div>
      )}

      {/* Donor Status Section */}
      {donorStatus?.isDonor ? (
        <div className="glass-2 rounded-xl p-4 sm:p-6">
          <div className="flex items-center justify-between mb-4">
            <div>
              <h3 className="text-lg font-semibold text-white text-shadow-adaptive">Your Donor Status</h3>
              <p className="text-sm text-white/70 text-shadow-adaptive-sm">
                Total donated: {formatAmount(totalDonations)}
              </p>
            </div>
            <div className={`px-4 py-2 bg-gradient-to-r ${
              currentTier === 'premium' ? 'from-purple-500 to-pink-500' : 'from-blue-500 to-cyan-500'
            } text-white rounded-full font-bold shadow-lg`}>
              {currentTier === 'premium' ? 'Premium Supporter' : 'Supporter'}
            </div>
          </div>

          {/* Progress to next tier */}
          {currentTier !== 'premium' && totalDonations < 10 && (
            <div className="space-y-2">
              <div className="flex justify-between text-sm">
                <span className="text-white/70 text-shadow-adaptive-sm">Progress to Premium</span>
                <span className="text-white/90 font-medium text-shadow-adaptive-sm">
                  {formatAmount(10 - totalDonations)} to go
                </span>
              </div>
              <div className="w-full bg-white/20 rounded-full h-2">
                <div 
                  className="bg-gradient-to-r from-purple-500 to-pink-500 h-2 rounded-full transition-all"
                  style={{ width: `${Math.min((totalDonations / 10) * 100, 100)}%` }}
                />
              </div>
            </div>
          )}
        </div>
      ) : (
        /* Become a Donor CTA */
        <div className="glass-2 rounded-xl sm:rounded-2xl p-6 sm:p-8 text-center">
          <Heart className="w-12 h-12 sm:w-16 sm:h-16 text-pink-400 mx-auto mb-4 icon-shadow-adaptive" />
          <h3 className="text-xl sm:text-2xl font-bold text-white mb-3 text-shadow-adaptive">
            Become a Supporter
          </h3>
          <p className="text-white/80 mb-6 max-w-md mx-auto text-shadow-adaptive-sm">
            Your donations help keep osu!Challengers running and allow us to add new features for the community!
          </p>
          
          {/* Tier Preview */}
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6">
            {donorTiers.map((tier) => (
              <div key={tier.name} className={`glass-1 rounded-xl p-4 border-2 ${tier.borderColor}`}>
                <div className={`inline-flex px-3 py-1 bg-gradient-to-r ${tier.color} text-white rounded-full text-sm font-bold mb-3`}>
                  {tier.name}
                </div>
                <p className="text-lg font-bold text-white mb-3 text-shadow-adaptive">
                  {formatAmount(tier.minAmount)}+
                </p>
                <ul className="space-y-2 text-left">
                  {tier.perks.slice(0, 3).map((perk, i) => (
                    <li key={i} className="flex items-start gap-2 text-sm text-white/80">
                      <Check className="w-4 h-4 text-green-400 mt-0.5 flex-shrink-0" />
                      <span className="text-shadow-adaptive-sm">{perk}</span>
                    </li>
                  ))}
                </ul>
              </div>
            ))}
          </div>
          
          <Link href="/donate" className="btn-primary inline-flex items-center gap-2">
            <Heart className="w-4 h-4" />
            Donate Now
          </Link>
        </div>
      )}

      {/* Donor Backgrounds Section */}
      {donorStatus?.isDonor && (donorBackgrounds.length > 0 || premiumBackgrounds.length > 0) && (
        <div className="space-y-4">
          <h3 className="text-lg font-semibold text-white text-shadow-adaptive flex items-center gap-2">
            <Sparkles className="w-5 h-5 icon-shadow-adaptive" />
            Donor Exclusive Backgrounds
          </h3>
          
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
            {/* Donor backgrounds (any amount) */}
            {donorBackgrounds.map((bg) => (
              <button
                key={bg.id}
                onClick={() => handleBackgroundSelect(bg.id)}
                className={`rounded-xl p-4 transition-colors duration-300 ${
                  selectedBackground === bg.id 
                    ? getSelectedStyle(bg) 
                    : 'glass-1 hover:glass-2 border-2 border-transparent'
                }`}
              >
                <div 
                  className="aspect-video rounded-lg mb-3 bg-cover bg-center"
                  style={{ backgroundImage: `url(${bg.preview_url || bg.image_url})` }}
                />
                <h4 className="font-semibold text-white text-shadow-adaptive">{bg.name}</h4>
                {bg.description && (
                  <p className="text-sm text-white/70 text-shadow-adaptive-sm">{bg.description}</p>
                )}
                <div className="mt-2 flex items-center gap-1 text-xs text-blue-400">
                  <Star className="w-3 h-3" />
                  Supporter exclusive
                </div>
              </button>
            ))}

            {/* Premium backgrounds ($10+) */}
            {premiumBackgrounds.map((bg) => {
              const hasAccess = totalDonations >= bg.min_donation_total;
              return (
                <button
                  key={bg.id}
                  onClick={() => hasAccess && handleBackgroundSelect(bg.id)}
                  disabled={!hasAccess}
                  className={`rounded-xl p-4 transition-all duration-300 ${
                    hasAccess 
                      ? `${selectedBackground === bg.id ? getSelectedStyle(bg) : 'glass-1 hover:glass-2 border-2 border-transparent'}` 
                      : 'glass-1 opacity-60 cursor-not-allowed border-2 border-transparent'
                  }`}
                >
                  <div 
                    className="aspect-video rounded-lg mb-3 bg-cover bg-center"
                    style={{ backgroundImage: `url(${bg.preview_url || bg.image_url})` }}
                  />
                  <h4 className="font-semibold text-white text-shadow-adaptive">{bg.name}</h4>
                  {bg.description && (
                    <p className="text-sm text-white/70 text-shadow-adaptive-sm">{bg.description}</p>
                  )}
                  {hasAccess ? (
                    <div className="mt-2 flex items-center gap-1 text-xs text-purple-400">
                      <Star className="w-3 h-3" />
                      Premium exclusive
                    </div>
                  ) : (
                    <div className="mt-2 flex items-center gap-1 text-xs text-yellow-400">
                      <Lock className="w-3 h-3" />
                      Requires {formatAmount(bg.min_donation_total)}+
                    </div>
                  )}
                </button>
              );
            })}
          </div>

          {/* More backgrounds coming soon */}
          <div className="glass-1 rounded-xl p-6 text-center">
            <p className="text-white/70 text-shadow-adaptive-sm">
              More exclusive backgrounds coming soon! üé®
            </p>
          </div>
        </div>
      )}

      {/* Active Perks for Donors */}
      {donorStatus?.isDonor && (
        <div className="glass-1 rounded-xl p-4 sm:p-6">
          <h3 className="text-lg font-semibold text-white mb-4 text-shadow-adaptive">Active Perks</h3>
          <ul className="space-y-3">
            {donorTiers
              .find(tier => tier.name.toLowerCase().includes(currentTier))
              ?.perks.map((perk, i) => (
                <li key={i} className="flex items-center gap-3 text-white/90">
                  <div className="p-1 rounded-full bg-green-500/20">
                    <Check className="w-4 h-4 text-green-400" />
                  </div>
                  <span className="text-shadow-adaptive-sm">{perk}</span>
                </li>
              ))}
          </ul>
        </div>
      )}

      {/* Donate More / Thank You Section */}
      <div className="text-center pt-4 border-t border-white/10">
        {donorStatus?.isDonor ? (
          <Link 
            href="/donate" 
            className="inline-flex items-center gap-2 text-white/80 hover:text-white transition-colors"
          >
            <Heart className="w-4 h-4" />
            <span className="text-shadow-adaptive-sm">Donate more to support us</span>
            <ChevronRight className="w-4 h-4" />
          </Link>
        ) : (
          <p className="text-white/70 text-sm text-shadow-adaptive-sm">
            Support the community and unlock exclusive features!
          </p>
        )}
      </div>
    </div>
  );
}


================================================
FILE: frontend/hooks/useAPI.js
================================================
import useSWR from 'swr';
import { useState, useCallback } from 'react';

const fetcher = async (url) => {
  const res = await fetch(url);
  if (!res.ok) {
    const error = new Error('API request failed');
    error.status = res.status;
    try {
      const data = await res.json();
      error.message = data.error?.message || 'An error occurred';
    } catch (e) {
      error.message = res.statusText || 'An error occurred';
    }
    throw error;
  }
  const data = await res.json();
  return data.data || data;
};

export function useAPI(endpoint, options = {}) {
  const {
    refreshInterval = null,
    revalidateOnFocus = false,
    initialData = null,
    enabled = true
  } = options;

  const { data, error, mutate, isValidating } = useSWR(
    enabled ? endpoint : null,
    fetcher,
    {
      refreshInterval,
      revalidateOnFocus,
      fallbackData: initialData,
      dedupingInterval: 60000,
      focusThrottleInterval: 60000,
      errorRetryInterval: 30000,
    }
  );

  const refresh = useCallback(() => mutate(), [mutate]);

  return {
    data,
    error,
    loading: !error && !data && enabled,
    isValidating,
    refresh
  };
}

// Simple hook for challenges - no sync logic
export function useChallenge(roomId) {
  return useAPI(roomId ? `/api/challenges/${roomId}` : null, {
    refreshInterval: 300000 // Refresh every 5 minutes
  });
}

// Simple hook for challenges list - no sync logic
export function useChallenges(filters = {}) {
  const params = new URLSearchParams();
  Object.entries(filters).forEach(([key, value]) => {
    if (value !== null && value !== undefined) {
      params.append(key, value.toString());
    }
  });
  
  const endpoint = `/api/challenges?${params.toString()}`;
  
  return useAPI(endpoint, {
    refreshInterval: 300000 // Refresh every 5 minutes
  });
}


================================================
FILE: frontend/lib/api-tracker.js
================================================
class SimpleAPITracker {
  constructor() {
    this.stats = {
      internal: 0,
      external: 0,
      total: 0
    };
  }

  // Minimal tracking without database syncing
  async trackInternal() {
    this.stats.internal++;
    this.stats.total++;
    return this.stats.internal;
  }

  async trackExternal() {
    this.stats.external++;
    this.stats.total++;
    return this.stats.external;
  }

  checkLimits() {
    return 'ok'; // Always OK for now
  }

  getUsageStats() {
    return {
      monthly: this.stats,
      usage: {
        functions: {
          current: this.stats.total,
          percentage: '0',
          remaining: 100000
        }
      }
    };
  }

  // No-op methods to prevent errors
  trackMiddleware() {}
  trackEdgeFunction() {}
  trackImageOptimization() {}
  generateRecommendations() { return []; }
  destroy() {}
}

// Simple singleton with proper cleanup
function createOrGetTracker() {
  if (typeof global !== 'undefined' && global.apiTrackerInstance) {
    return global.apiTrackerInstance;
  }

  const instance = new SimpleAPITracker();
  
  if (typeof global !== 'undefined') {
    global.apiTrackerInstance = instance;
  }
  
  return instance;
}

// Enhanced fetch wrapper with proper error handling
export function trackedFetch(url, options = {}, apiName = 'external') {
  const startTime = Date.now();
  const method = options.method || 'GET';
  const endpoint = new URL(url).pathname;
  
  return fetch(url, options)
    .then(async response => {
      const duration = Date.now() - startTime;
      const success = response.ok;
      
      let responseSize = 0;
      try {
        const contentLength = response.headers.get('content-length');
        if (contentLength) {
          responseSize = parseInt(contentLength, 10);
        }
      } catch (e) {
        // Ignore if we can't get the size
      }
      
      apiTracker.trackExternal(apiName, endpoint, method, duration, success, responseSize);
      
      if (!success) {
        console.warn(`‚ùå External API failed: ${method} ${url} (${response.status})`);
      }
      
      return response;
    })
    .catch(error => {
      const duration = Date.now() - startTime;
      apiTracker.trackExternal(apiName, endpoint, method, duration, false, 0);
      
      console.error(`üö® External API error: ${method} ${url}`, error);
      throw error;
    });
}

// Create singleton instance
const apiTracker = createOrGetTracker();

export default apiTracker;


================================================
FILE: frontend/lib/api-utils.js
================================================
import crypto from 'crypto';

export class APIError extends Error {
  constructor(message, status, code) {
    super(message);
    this.status = status;
    this.code = code;
    this.name = 'APIError';
  }
}

// Generate ETag for data (doesn't need req)
export function generateETag(data) {
  const hash = crypto
    .createHash('md5')
    .update(JSON.stringify(data))
    .digest('hex');
  return `"${hash}"`;
}

// Check if client has cached version
export function checkETag(req, etag) {
  const clientETag = req.headers['if-none-match'];
  return clientETag === etag;
}

// Enhanced response handler with caching
export function handleAPIResponse(res, data, options = {}) {
  const { 
    status = 200, 
    cache = false,
    cacheTime = 60,
    enableETag = false,
    req = null // Add req as optional parameter
  } = options;

  // Set security headers
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');

  // Generate and check ETag if enabled AND req is provided
  if (enableETag && req) {
    const etag = generateETag(data);
    res.setHeader('ETag', etag);
    
    // If client has this version, return 304
    if (checkETag(req, etag)) {
      return res.status(304).end();
    }
  }

  // Set cache headers if enabled
  if (cache) {
  res.setHeader(
    'Cache-Control',
    `public, max-age=0, s-maxage=${cacheTime}, stale-while-revalidate=${Math.floor(cacheTime / 2)}, must-revalidate`
    );
    res.setHeader('CDN-Cache-Control', `max-age=${cacheTime}`);
  } else {
    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate, max-age=0');
  }

  return res.status(status).json({
    success: true,
    data,
    timestamp: new Date().toISOString()
  });
}

// Standard error response handler
export function handleAPIError(res, error) {
  console.error('API Error:', {
    message: error.message,
    stack: error.stack,
    timestamp: new Date().toISOString()
  });

  // Determine status code
  let status = 500;
  let message = 'Internal server error';
  let code = 'INTERNAL_ERROR';

  if (error instanceof APIError) {
    status = error.status;
    message = error.message;
    code = error.code;
  } else if (error.message?.includes('not found')) {
    status = 404;
    message = 'Resource not found';
    code = 'NOT_FOUND';
  } else if (error.message?.includes('unauthorized')) {
    status = 401;
    message = 'Unauthorized';
    code = 'UNAUTHORIZED';
  } else if (error.message?.includes('forbidden')) {
    status = 403;
    message = 'Forbidden';
    code = 'FORBIDDEN';
  } else if (error.code === 'PGRST301' || error.message?.includes('JWT')) {
    status = 401;
    message = 'Authentication required';
    code = 'AUTH_REQUIRED';
  }

  // Set security headers
  res.setHeader('X-Content-Type-Options', 'nosniff');

  return res.status(status).json({
    success: false,
    error: {
      message,
      code,
      ...(process.env.NODE_ENV === 'development' && { 
        stack: error.stack,
        details: error.details 
      })
    },
    timestamp: new Date().toISOString()
  });
}

// Improved rate limiting with memory management
class RateLimitStore {
  constructor(cleanupInterval = 300000) { // 5 minutes
    this.store = new Map();
    this.maxEntries = 10000; // Prevent memory bloat
    
    // Cleanup expired entries periodically
    this.cleanupTimer = setInterval(() => {
      this.cleanup();
    }, cleanupInterval);
  }

  cleanup() {
    const now = Date.now();
    let removed = 0;
    
    for (const [key, value] of this.store.entries()) {
      if (now > value.resetTime) {
        this.store.delete(key);
        removed++;
      }
    }
    
    // If still too many entries, remove oldest
    if (this.store.size > this.maxEntries) {
      const entries = Array.from(this.store.entries())
        .sort((a, b) => a[1].resetTime - b[1].resetTime);
      
      const toRemove = this.store.size - this.maxEntries;
      for (let i = 0; i < toRemove; i++) {
        this.store.delete(entries[i][0]);
        removed++;
      }
    }
    
    if (removed > 0) {
      console.log(`Rate limit cleanup: removed ${removed} expired entries`);
    }
  }

  get(key) {
    return this.store.get(key);
  }

  set(key, value) {
    this.store.set(key, value);
  }

  destroy() {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
    }
    this.store.clear();
  }
}

const rateLimitStore = new RateLimitStore();

export function checkRateLimit(identifier, maxRequests = 100, windowMs = 60000) {
  if (!identifier) {
    throw new APIError('Rate limit identifier required', 400, 'INVALID_IDENTIFIER');
  }

  const now = Date.now();
  const userLimits = rateLimitStore.get(identifier) || { 
    count: 0, 
    resetTime: now + windowMs,
    firstRequest: now
  };

  // Reset if window has passed
  if (now > userLimits.resetTime) {
    userLimits.count = 0;
    userLimits.resetTime = now + windowMs;
    userLimits.firstRequest = now;
  }

  userLimits.count++;
  rateLimitStore.set(identifier, userLimits);

  const remaining = Math.max(0, maxRequests - userLimits.count);
  const resetTime = new Date(userLimits.resetTime).toISOString();

  if (userLimits.count > maxRequests) {
    const error = new APIError('Rate limit exceeded', 429, 'RATE_LIMIT_EXCEEDED');
    error.headers = {
      'X-RateLimit-Limit': maxRequests,
      'X-RateLimit-Remaining': 0,
      'X-RateLimit-Reset': resetTime,
      'Retry-After': Math.ceil((userLimits.resetTime - now) / 1000)
    };
    throw error;
  }

  return {
    remaining,
    reset: resetTime,
    headers: {
      'X-RateLimit-Limit': maxRequests,
      'X-RateLimit-Remaining': remaining,
      'X-RateLimit-Reset': resetTime
    }
  };
}

// Request validation helper with improved security
export function validateRequest(req, schema) {
  const errors = [];

  // Validate method
  if (schema.method && req.method !== schema.method) {
    errors.push(`Method ${req.method} not allowed. Expected: ${schema.method}`);
  }

  // Validate required query params
  if (schema.query) {
    for (const [param, rules] of Object.entries(schema.query)) {
      const value = req.query[param];

      if (rules.required && (value === undefined || value === null || value === '')) {
        errors.push(`Query parameter '${param}' is required`);
        continue;
      }

      if (value !== undefined && value !== null && value !== '') {
        // Type validation
        if (rules.type === 'number') {
          const numValue = Number(value);
          if (isNaN(numValue) || !isFinite(numValue)) {
            errors.push(`Query parameter '${param}' must be a valid number`);
            continue;
          }
        }
        
        if (rules.type === 'boolean' && !['true', 'false', '1', '0'].includes(String(value).toLowerCase())) {
          errors.push(`Query parameter '${param}' must be a boolean (true/false)`);
          continue;
        }

        if (rules.type === 'string' && typeof value !== 'string') {
          errors.push(`Query parameter '${param}' must be a string`);
          continue;
        }

        // Range validation
        const numValue = Number(value);
        if (rules.min !== undefined && !isNaN(numValue) && numValue < rules.min) {
          errors.push(`Query parameter '${param}' must be at least ${rules.min}`);
        }

        if (rules.max !== undefined && !isNaN(numValue) && numValue > rules.max) {
          errors.push(`Query parameter '${param}' must be at most ${rules.max}`);
        }

        // String length validation
        if (rules.minLength && String(value).length < rules.minLength) {
          errors.push(`Query parameter '${param}' must be at least ${rules.minLength} characters`);
        }

        if (rules.maxLength && String(value).length > rules.maxLength) {
          errors.push(`Query parameter '${param}' must be at most ${rules.maxLength} characters`);
        }

        // Pattern validation
        if (rules.pattern && !rules.pattern.test(String(value))) {
          errors.push(`Query parameter '${param}' format is invalid`);
        }

        // Enum validation
        if (rules.enum && !rules.enum.includes(value)) {
          errors.push(`Query parameter '${param}' must be one of: ${rules.enum.join(', ')}`);
        }
      }
    }
  }

  // Validate required body fields
  if (schema.body && req.body) {
    if (typeof req.body !== 'object' || Array.isArray(req.body)) {
      errors.push('Request body must be a valid JSON object');
    } else {
      for (const [field, rules] of Object.entries(schema.body)) {
        const value = req.body[field];

        if (rules.required && (value === undefined || value === null || value === '')) {
          errors.push(`Field '${field}' is required`);
          continue;
        }

        if (value !== undefined && value !== null && value !== '') {
          // ‚úÖ FIXED: Proper array type validation
          if (rules.type === 'array') {
            if (!Array.isArray(value)) {
              errors.push(`Field '${field}' must be of type array`);
              continue;
            }
            
            // Array-specific validations
            if (rules.minItems && value.length < rules.minItems) {
              errors.push(`Field '${field}' must have at least ${rules.minItems} items`);
            }
            if (rules.maxItems && value.length > rules.maxItems) {
              errors.push(`Field '${field}' must have at most ${rules.maxItems} items`);
            }
            
            // Validate array item types if specified
            if (rules.itemType) {
              const invalidItems = value.filter(item => {
                if (rules.itemType === 'number') {
                  return typeof item !== 'number' || !Number.isFinite(item);
                }
                return typeof item !== rules.itemType;
              });
              
              if (invalidItems.length > 0) {
                errors.push(`Field '${field}' array items must be of type ${rules.itemType}`);
              }
            }
          } else if (rules.type && typeof value !== rules.type) {
            // ‚úÖ FIXED: Regular type validation (excluding arrays which are handled above)
            errors.push(`Field '${field}' must be of type ${rules.type}`);
            continue;
          }

          // String validations
          if (rules.type === 'string') {
            if (rules.minLength && value.length < rules.minLength) {
              errors.push(`Field '${field}' must be at least ${rules.minLength} characters`);
            }
            if (rules.maxLength && value.length > rules.maxLength) {
              errors.push(`Field '${field}' must be at most ${rules.maxLength} characters`);
            }
            if (rules.pattern && !rules.pattern.test(value)) {
              errors.push(`Field '${field}' format is invalid`);
            }
          }

          // Number validations
          if (rules.type === 'number') {
            if (rules.min !== undefined && value < rules.min) {
              errors.push(`Field '${field}' must be at least ${rules.min}`);
            }
            if (rules.max !== undefined && value > rules.max) {
              errors.push(`Field '${field}' must be at most ${rules.max}`);
            }
          }
        }
      }
    }
  }

  if (errors.length > 0) {
    throw new APIError(errors.join(', '), 400, 'VALIDATION_ERROR');
  }
}

// Pagination helper with improved validation
export function getPaginationParams(req, maxLimit = 100, defaultLimit = 20) {
  let limit = defaultLimit;
  let page = 1;

  // Parse and validate limit
  if (req.query.limit) {
    const parsedLimit = parseInt(req.query.limit, 10);
    if (isNaN(parsedLimit) || parsedLimit < 1) {
      throw new APIError('Limit must be a positive integer', 400, 'INVALID_LIMIT');
    }
    limit = Math.min(parsedLimit, maxLimit);
  }

  // Parse and validate page
  if (req.query.page) {
    const parsedPage = parseInt(req.query.page, 10);
    if (isNaN(parsedPage) || parsedPage < 1) {
      throw new APIError('Page must be a positive integer', 400, 'INVALID_PAGE');
    }
    page = parsedPage;
  }

  const offset = (page - 1) * limit;

  return { limit, offset, page };
}

// Response with pagination metadata
export function paginatedResponse(res, data, total, params, options = {}) {
  const { limit, page } = params;
  const totalPages = Math.ceil(total / limit);

  return res.status(200).json({
    success: true,
    data,
    pagination: {
      page,
      limit,
      total,
      totalPages,
      hasNext: page < totalPages,
      hasPrev: page > 1,
      nextPage: page < totalPages ? page + 1 : null,
      prevPage: page > 1 ? page - 1 : null
    },
    timestamp: new Date().toISOString()
  });
}

// Graceful shutdown helper
export function setupGracefulShutdown() {
  const cleanup = () => {
    console.log('Cleaning up rate limit store...');
    rateLimitStore.destroy();
  };

  process.on('SIGTERM', cleanup);
  process.on('SIGINT', cleanup);
  process.on('exit', cleanup);
}

// Input sanitization helper
export function sanitizeInput(input, type = 'string') {
  if (input === null || input === undefined) {
    return input;
  }

  switch (type) {
    case 'string':
      return String(input).trim().slice(0, 1000); // Limit length
    case 'number':
      const num = Number(input);
      return isNaN(num) ? 0 : num;
    case 'boolean':
      return Boolean(input);
    case 'email':
      const email = String(input).trim().toLowerCase();
      return email.length > 320 ? '' : email; // RFC 5321 limit
    default:
      return input;
  }
}


================================================
FILE: frontend/lib/auth-middleware.js
================================================
import { withSecureAuth, withOptionalAuth as secureOptionalAuth } from './secure-auth';

// Replace the old insecure functions with secure ones
export const withAuth = withSecureAuth;
export const withOptionalAuth = secureOptionalAuth;

// Admin middleware using secure auth
export function withAdminAuth(handler) {
  return withSecureAuth(handler, { requireAdmin: true });
}

// Keep this function as-is for client-side checks
export async function checkAdminStatus(userId) {
  try {
    const { data: user, error } = await supabase
      .from('users')
      .select('admin')
      .eq('id', userId)
      .single();

    if (error || !user) {
      return false;
    }

    return user.admin || false;
  } catch (error) {
    console.error('Admin status check error:', error);
    return false;
  }
}


================================================
FILE: frontend/lib/AuthContext.js
================================================
import { createContext, useContext, useState, useEffect, useCallback, useRef } from 'react';
import { useRouter } from 'next/router';

const AuthContext = createContext();

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [isAdmin, setIsAdmin] = useState(false);
  const [mounted, setMounted] = useState(false);
  const router = useRouter();

  // Add refs to prevent loops and rate limit checks
  const checkingUserRef = useRef(false);
  const lastUserCheckRef = useRef(0);
  const userCheckTimeoutRef = useRef(null);
  const isInitialCheckRef = useRef(true);

  useEffect(() => {
    setMounted(true);
    checkUser();

    // Listen for auth changes in other tabs
    const handleStorageChange = (e) => {
      if (e.key === 'auth_state_changed' && e.newValue) {
        console.log('üîÑ AuthContext: Cross-tab auth change detected');
        const authData = JSON.parse(e.newValue);
        
        if (authData.user) {
          console.log('‚úÖ AuthContext: User synced from other tab:', authData.user.username);
          setUser(authData.user);
          setIsAdmin(authData.user.admin || false);
        } else {
          console.log('‚ùå AuthContext: User cleared from other tab');
          setUser(null);
          setIsAdmin(false);
        }
        setLoading(false);
      }
    };

    window.addEventListener('storage', handleStorageChange);
    return () => {
      window.removeEventListener('storage', handleStorageChange);
      if (userCheckTimeoutRef.current) {
        clearTimeout(userCheckTimeoutRef.current);
      }
    };
  }, []);

  // SIMPLIFIED: Only refresh on route changes for OAuth redirects
  useEffect(() => {
    if (mounted && router.pathname.startsWith('/profile/') && !user && !loading) {
      console.log('üîÑ AuthContext: OAuth redirect detected, refreshing...');
      // Use debounced check
      debouncedCheckUser();
    }
  }, [router.pathname, user, loading, mounted]);

  // Handle logout success parameter
  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('logout') === 'success') {
      console.log('üîÑ AuthContext: Logout success detected');
      
      // Clean up the URL immediately to prevent loops
      const newUrl = window.location.pathname;
      window.history.replaceState({}, '', newUrl);
      
      // Use debounced check instead of immediate
      debouncedCheckUser();
    }
  }, [router.asPath]);

  // FIXED: Add debounced user check to prevent rapid successive calls
  const debouncedCheckUser = useCallback(() => {
    if (userCheckTimeoutRef.current) {
      clearTimeout(userCheckTimeoutRef.current);
    }
    
    userCheckTimeoutRef.current = setTimeout(() => {
      checkUser();
    }, 100); // 100ms debounce
  }, []);

  const checkUser = useCallback(async () => {
    if (typeof window === 'undefined') return;
    
    // FIXED: Prevent concurrent checks and rate limiting
    if (checkingUserRef.current) {
      console.log('üîÑ AuthContext: User check already in progress, skipping...');
      return;
    }

    // FIXED: Rate limit checks (max once per 2 seconds, except initial)
    const now = Date.now();
    if (!isInitialCheckRef.current && now - lastUserCheckRef.current < 2000) {
      console.log('üîÑ AuthContext: Rate limiting user check, skipping...');
      return;
    }

    try {
      checkingUserRef.current = true;
      lastUserCheckRef.current = now;
      isInitialCheckRef.current = false;
      
      console.log('üîç AuthContext: Checking user...');
      
      const timestamp = Date.now();
      const response = await fetch(`/api/auth/status?_t=${timestamp}`, {
        method: 'GET',
        credentials: 'include',
        cache: 'no-store',
        headers: {
          'Cache-Control': 'no-cache, no-store, must-revalidate',
          'Pragma': 'no-cache'
        }
      });

      if (response.ok) {
        const data = await response.json();
        
        // Handle both old and new API response formats
        const responseData = data.data || data;
        
        if (responseData.authenticated && responseData.user) {
          console.log('‚úÖ AuthContext: User found:', responseData.user.username);
          setUser(responseData.user);
          setIsAdmin(responseData.user.admin || false);
          
          // FIXED: Only notify other tabs about actual state changes
          // Store the actual auth state instead of just a timestamp
          if (typeof window !== 'undefined') {
            const authState = {
              user: responseData.user,
              admin: responseData.user.admin || false,
              timestamp: Date.now()
            };
            localStorage.setItem('auth_state_changed', JSON.stringify(authState));
            // Remove after a short delay to trigger the event
            setTimeout(() => {
              localStorage.removeItem('auth_state_changed');
            }, 50);
          }
        } else {
          console.log('‚ùå AuthContext: No user found');
          setUser(null);
          setIsAdmin(false);
          
          // FIXED: Notify other tabs about logout
          if (typeof window !== 'undefined') {
            const authState = {
              user: null,
              admin: false,
              timestamp: Date.now()
            };
            localStorage.setItem('auth_state_changed', JSON.stringify(authState));
            setTimeout(() => {
              localStorage.removeItem('auth_state_changed');
            }, 50);
          }
        }
      }
    } catch (error) {
      console.error('üö® AuthContext: Auth check error:', error);
      setUser(null);
      setIsAdmin(false);
    } finally {
      setLoading(false);
      checkingUserRef.current = false;
    }
  }, []);

  const signOut = useCallback(async () => {
    try {
      console.log('üö™ AuthContext: Signing out...');
      
      // CRITICAL: Set loading first to prevent flickering
      setLoading(true);
      
      const response = await fetch('/api/auth/logout', {
        method: 'POST',
        credentials: 'include'
      });
      
      if (!response.ok) {
        console.error('‚ùå Logout API failed:', response.status);
      }
      
      // SMOOTH: Update all auth state in one batch
      setUser(null);
      setIsAdmin(false);
      
      // FIXED: Notify other tabs about logout with actual state
      if (typeof window !== 'undefined') {
        const authState = {
          user: null,
          admin: false,
          timestamp: Date.now()
        };
        localStorage.setItem('auth_state_changed', JSON.stringify(authState));
        setTimeout(() => {
          localStorage.removeItem('auth_state_changed');
        }, 50);
      }
      
      console.log('‚úÖ AuthContext: Signed out successfully');
      return true;
      
    } catch (error) {
      console.error('üö® AuthContext: Logout error:', error);
      // Clear state even if API fails
      setUser(null);
      setIsAdmin(false);
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  const refreshUser = useCallback(() => {
    setLoading(true);
    // Use debounced check for manual refreshes too
    debouncedCheckUser();
  }, [debouncedCheckUser]);

  const value = {
    user,
    loading,
    isAdmin,
    checkUser: refreshUser,
    signOut
  };

  // Prevent hydration mismatch
  if (!mounted) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-white">Loading...</div>
      </div>
    );
  }

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  
  // SSR safety
  if (typeof window === 'undefined') {
    return {
      user: null,
      loading: true,
      isAdmin: false,
      checkUser: () => Promise.resolve(),
      signOut: () => Promise.resolve()
    };
  }
  
  return context;
}


================================================
FILE: frontend/lib/cache-invalidation.js
================================================
import { memoryCache } from './memory-cache';

export class CacheInvalidator {
  constructor() {
    this.patterns = new Map();
  }

  // Register cache patterns that should be invalidated together
  registerPattern(pattern, keys) {
    this.patterns.set(pattern, keys);
  }

  // Invalidate caches by pattern
  invalidate(pattern) {
    const keys = this.patterns.get(pattern) || [];
    
    keys.forEach(key => {
      // Support wildcards
      if (key.includes('*')) {
        const prefix = key.replace('*', '');
        const cacheStats = memoryCache.getStats();
        cacheStats.keys.forEach(cacheKey => {
          if (cacheKey.startsWith(prefix)) {
            memoryCache.delete(cacheKey);
            console.log(`üóëÔ∏è Invalidated cache: ${cacheKey}`);
          }
        });
      } else {
        memoryCache.delete(key);
        console.log(`üóëÔ∏è Invalidated cache: ${key}`);
      }
    });

    // Also clear relevant localStorage
    if (typeof window !== 'undefined') {
      keys.forEach(key => {
        if (key.includes('*')) {
          const prefix = `cache_/api/${key.replace('*', '')}`;
          Object.keys(localStorage).forEach(storageKey => {
            if (storageKey.startsWith(prefix)) {
              localStorage.removeItem(storageKey);
            }
          });
        } else if (key.includes('settings')) {
          // Clear settings cache from localStorage
          localStorage.removeItem('user_settings_cache');
        }
      });
    }
  }
}

// Export singleton
export const cacheInvalidator = new CacheInvalidator();

// Register common patterns
cacheInvalidator.registerPattern('challenges', [
  'challenges_list_*',
  'challenge_*'
]);

cacheInvalidator.registerPattern('leaderboard', [
  'leaderboard_*'
]);

cacheInvalidator.registerPattern('partners', [
  'partners_*'
]);

cacheInvalidator.registerPattern('team', [
  'team_*'
]);

cacheInvalidator.registerPattern('seasons', [
  'current_season_*',
  'seasons_*'
]);

cacheInvalidator.registerPattern('stats', [
  'stats_*'
]);

// Settings invalidation pattern
cacheInvalidator.registerPattern('settings', [
  'settings_*'
]);

// User-specific invalidation (for when user data changes)
cacheInvalidator.registerPattern('user_data', [
  'settings_*',
  'user_profile_*'
]);

// Helper function to invalidate after updates
export function invalidateAfterUpdate(type, id = null) {
  switch (type) {
    case 'challenge':
      cacheInvalidator.invalidate('challenges');
      cacheInvalidator.invalidate('leaderboard');
      cacheInvalidator.invalidate('stats');
      break;
    case 'partner':
      cacheInvalidator.invalidate('partners');
      break;
    case 'team':
      cacheInvalidator.invalidate('team');
      break;
    case 'season':
      cacheInvalidator.invalidate('seasons');
      break;
    case 'settings':
      cacheInvalidator.invalidate('settings');
      break;
    case 'user':
      cacheInvalidator.invalidate('user_data');
      break;
    default:
      console.log(`No invalidation pattern for type: ${type}`);
  }
}

// Helper to invalidate user-specific settings
export function invalidateUserSettings(userId) {
  if (userId) {
    memoryCache.delete(`settings_${userId}`);
    console.log(`üóëÔ∏è Invalidated settings cache for user ${userId}`);
    
    // Clear localStorage cache if on client
    if (typeof window !== 'undefined') {
      localStorage.removeItem('user_settings_cache');
    }
  }
}


================================================
FILE: frontend/lib/date-utils.js
================================================
// Date formatting and utility functions

// Helper to ensure UTC interpretation
function ensureUTC(date) {
  if (!date) return null;
  
  // If it's already a Date object, return it
  if (date instanceof Date) return date;
  
  // If it's a string, ensure it's interpreted as UTC
  const dateString = date.toString();
  
  // If it already has timezone info (Z, +, or ends with timezone), use as-is
  if (dateString.includes('Z') || dateString.includes('+') || dateString.includes('-', 10)) {
    return new Date(dateString);
  }
  
  // Otherwise, treat as UTC by appending 'Z'
  return new Date(dateString + 'Z');
}

export function formatDate(date, format = 'short') {
    if (!date) return 'N/A';
    
    const d = ensureUTC(date);
    
    switch (format) {
      case 'short':
        return d.toLocaleDateString('en-US', {
          month: 'short',
          day: 'numeric',
          year: 'numeric'
        });
      
      case 'long':
        return d.toLocaleDateString('en-US', {
          weekday: 'long',
          month: 'long',
          day: 'numeric',
          year: 'numeric'
        });
      
      case 'time':
        return d.toLocaleTimeString('en-US', {
          hour: '2-digit',
          minute: '2-digit'
        });
      
      case 'datetime':
        return d.toLocaleString('en-US', {
          month: 'short',
          day: 'numeric',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
      
      case 'relative':
        return getRelativeTime(d);
      
      default:
        return d.toLocaleDateString();
    }
  }
  
  export function getRelativeTime(date) {
    const now = new Date();
    const then = ensureUTC(date);
    const seconds = Math.floor((now - then) / 1000);
    
    if (seconds < 60) return 'just now';
    
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) return `${minutes}m ago`;
    
    const hours = Math.floor(minutes / 60);
    if (hours < 24) return `${hours}h ago`;
    
    const days = Math.floor(hours / 24);
    if (days < 7) return `${days}d ago`;
    
    const weeks = Math.floor(days / 7);
    if (weeks < 4) return `${weeks}w ago`;
    
    const months = Math.floor(days / 30);
    if (months < 12) return `${months}mo ago`;
    
    const years = Math.floor(days / 365);
    return `${years}y ago`;
  }
  
  export function getDaysRemaining(endDate) {
    if (!endDate) return null;
    
    const end = ensureUTC(endDate);
    const now = new Date();
    const diff = end - now;
    
    if (diff <= 0) return 0;
    
    return Math.ceil(diff / (1000 * 60 * 60 * 24));
  }
  
  export function getTimeRemaining(endDate) {
    if (!endDate) return null;
    
    const end = ensureUTC(endDate);
    const now = new Date();
    const diff = end - now;
    
    if (diff <= 0) return { expired: true };
    
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
    
    return { days, hours, minutes, expired: false };
  }
  
  export function formatDuration(seconds) {
    if (!seconds || seconds < 0) return '0:00';
    
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    
    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    
    return `${minutes}:${secs.toString().padStart(2, '0')}`;
  }
  
  export function isToday(date) {
    const today = new Date();
    const d = ensureUTC(date);
    
    return d.getDate() === today.getDate() &&
      d.getMonth() === today.getMonth() &&
      d.getFullYear() === today.getFullYear();
  }
  
  export function isThisWeek(date) {
    const now = new Date();
    const d = ensureUTC(date);
    const weekStart = new Date(now.setDate(now.getDate() - now.getDay()));
    const weekEnd = new Date(now.setDate(now.getDate() - now.getDay() + 6));
    
    return d >= weekStart && d <= weekEnd;
  }
  
  export function getDateRange(start, end) {
    if (!start || !end) return 'N/A';
    
    const startDate = formatDate(start, 'short');
    const endDate = formatDate(end, 'short');
    
    return `${startDate} - ${endDate}`;
  }
  
  // Format timestamps for display
  export function formatTimestamp(timestamp) {
    const date = ensureUTC(timestamp);
    const now = new Date();
    const diffMs = now - date;
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    
    if (diffDays === 0) {
      return `Today at ${formatDate(date, 'time')}`;
    } else if (diffDays === 1) {
      return `Yesterday at ${formatDate(date, 'time')}`;
    } else if (diffDays < 7) {
      return formatDate(date, 'datetime');
    } else {
      return formatDate(date, 'short');
    }
  }


================================================
FILE: frontend/lib/memory-cache.js
================================================
class MemoryCache {
  constructor() {
    this.cache = new Map();
    this.timers = new Map();
    this.maxSize = 1000;
  }

  set(key, value, ttl = 600000) { // Default 10 minutes
    // Clear existing timer
    if (this.timers.has(key)) {
      clearTimeout(this.timers.get(key));
    }

    // Remove oldest entries if at capacity
    if (this.cache.size >= this.maxSize && !this.cache.has(key)) {
      const firstKey = this.cache.keys().next().value;
      this.delete(firstKey);
    }

    // Set value with metadata
    this.cache.set(key, {
      value,
      timestamp: Date.now(),
      ttl,
      accessCount: 0
    });

    // Set expiration timer
    const timer = setTimeout(() => {
      this.delete(key);
    }, ttl);

    this.timers.set(key, timer);
  }

  get(key) {
    const item = this.cache.get(key);
    if (!item) return null;

    if (Date.now() - item.timestamp > item.ttl) {
      this.delete(key);
      return null;
    }

    // Track access for analytics
    item.accessCount++;
    return item.value;
  }

  delete(key) {
    if (this.timers.has(key)) {
      clearTimeout(this.timers.get(key));
      this.timers.delete(key);
    }
    this.cache.delete(key);
  }

  clear() {
    this.timers.forEach(timer => clearTimeout(timer));
    this.cache.clear();
    this.timers.clear();
  }

  getStats() {
    return {
      size: this.cache.size,
      maxSize: this.maxSize,
      keys: Array.from(this.cache.keys())
    };
  }
}

export const memoryCache = new MemoryCache();

// Cache duration constants (milliseconds)
export const CACHE_DURATIONS = {
  SEASONS: 3600000,           // 1 hour (rarely changes)
  PARTNERS: 1800000,          // 30 minutes
  TEAM: 1800000,              // 30 minutes
  CHALLENGES_LIST: 240000,    // 4 minutes (just under cron interval)
  CHALLENGE_DETAIL: 240000,   // 4 minutes (just under cron interval)
  LEADERBOARD: 240000,        // 4 minutes
  USER_PROFILE: 300000,       // 5 minutes
  SETTINGS: 300000,           // 5 minutes
  STATS: 180000,              // 3 minutes
  HEALTH: 60000,              // 1 minute
  AUTH_STATUS: 30000,         // 30 seconds
  ADMIN_DATA: 300000          // 5 minutes
};

export function invalidateChallengeCache(roomId = null) {
  if (roomId) {
    // Invalidate specific challenge
    memoryCache.delete(`challenge_detail_${roomId}`);
    console.log(`üóëÔ∏è Invalidated cache for challenge ${roomId}`);
  }
  // Always invalidate list cache when any challenge updates
  const stats = memoryCache.getStats();
  stats.keys.forEach(key => {
    if (key.startsWith('challenges_list_')) {
      memoryCache.delete(key);
    }
  });
  console.log(`üóëÔ∏è Invalidated challenges list cache`);
}

// Helper function to create cache keys
export function createCacheKey(type, id, params = {}) {
  const paramsStr = Object.keys(params).length > 0 
    ? '_' + Object.entries(params)
        .sort(([a], [b]) => a.localeCompare(b))
        .map(([k,v]) => `${k}=${v}`)
        .join('&')
    : '';
  return `${type}_${id}${paramsStr}`;
}

// Settings-specific cache helpers
export function createSettingsCacheKey(userId) {
  return createCacheKey('settings', userId);
}

export function cacheUserSettings(userId, settings, donorStatus, availableBackgrounds) {
  const cacheKey = createSettingsCacheKey(userId);
  const cacheData = {
    settings,
    donorStatus,
    availableBackgrounds,
    timestamp: Date.now()
  };
  
  memoryCache.set(cacheKey, cacheData, CACHE_DURATIONS.SETTINGS);
  console.log(`üì± Cached settings for user ${userId}`);
  return cacheKey;
}

export function getCachedUserSettings(userId) {
  const cacheKey = createSettingsCacheKey(userId);
  const cached = memoryCache.get(cacheKey);
  
  if (cached) {
    console.log(`üì± Retrieved cached settings for user ${userId}`);
    return cached;
  }
  
  return null;
}


================================================
FILE: frontend/lib/osu-api.js
================================================
import apiTracker, { trackedFetch } from './api-tracker';

class TrackedOsuAPI {
  constructor() {
    this.baseURL = 'https://osu.ppy.sh/api/v2';
    this.token = null;
    
    this.getToken = this.getToken.bind(this);
    this.getUser = this.getUser.bind(this);
    this.getRoom = this.getRoom.bind(this);
    this.getRoomScores = this.getRoomScores.bind(this);
    this.getAllRoomScores = this.getAllRoomScores.bind(this);
    this.getBeatmap = this.getBeatmap.bind(this);
    this.getUsers = this.getUsers.bind(this);
  }

  // Get OAuth token
  async getToken() {
    if (this.token && this.token.expires > Date.now()) {
      return this.token.access_token;
    }

    console.log('üîë Authenticating with osu! API...');
    
    const response = await trackedFetch('https://osu.ppy.sh/oauth/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        client_id: process.env.OSU_CLIENT_ID,
        client_secret: process.env.OSU_CLIENT_SECRET,
        grant_type: 'client_credentials',
        scope: 'public'
      })
    }, 'osu-auth');

    if (!response.ok) {
      throw new Error(`Failed to get osu! token: ${response.status}`);
    }

    const tokenData = await response.json();
    this.token = {
      access_token: tokenData.access_token,
      expires: Date.now() + (tokenData.expires_in * 1000) - 60000 // 1 min buffer
    };

    console.log('‚úÖ osu! API authentication successful');
    return this.token.access_token;
  }

  // Get user data 
  async getUser(userId) {
    const token = await this.getToken();
    
    console.log(`üì° osu! API: GET /users/${userId}`);
    
    const response = await trackedFetch(`${this.baseURL}/users/${userId}`, {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    }, 'osu-api');

    if (!response.ok) {
      console.error(`‚ùå osu! API failed: GET /users/${userId} (${response.status})`);
      throw new Error(`Failed to get user ${userId}: ${response.status}`);
    }

    console.log(`‚úÖ osu! API: /users/${userId} success`);
    return response.json();
  }

  // Get multiplayer room 
  async getRoom(roomId) {
    const startTime = Date.now();
    
    try {
      const token = await this.getToken();
      
      console.log(`üì° osu! API: GET /rooms/${roomId}`);
      
      const response = await trackedFetch(`${this.baseURL}/rooms/${roomId}`, {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      }, 'osu-api');

      if (!response.ok) {
        throw new Error(`Failed to get room ${roomId}: ${response.status}`);
      }

      const data = await response.json();
      const duration = Date.now() - startTime;
      
      console.log(`‚úÖ osu! API: /rooms/${roomId} success (${duration}ms)`);
      return data;
      
    } catch (error) {
      const duration = Date.now() - startTime;
      console.error(`‚ùå osu! API: GET /rooms/${roomId} failed (${duration}ms):`, error.message);
      throw error;
    }
  }

  // Get room scores
  async getRoomScores(roomId, playlistId, limit = 50, cursor = null) {
    const token = await this.getToken();
    
    let url = `${this.baseURL}/rooms/${roomId}/playlist/${playlistId}/scores?limit=${limit}&sort=score_desc`;
    if (cursor) {
      url += `&cursor_string=${cursor}`;
    }
    
    console.log(`üì° osu! API: GET /rooms/${roomId}/playlist/${playlistId}/scores (limit=${limit})`);
    
    const response = await trackedFetch(url, {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    }, 'osu-api');

    if (!response.ok) {
      console.error(`‚ùå osu! API failed: GET /rooms/${roomId}/playlist/${playlistId}/scores (${response.status})`);
      throw new Error(`Failed to get scores for room ${roomId}, playlist ${playlistId}: ${response.status}`);
    }

    const data = await response.json();
    console.log(`‚úÖ osu! API: Fetched ${data.scores?.length || 0} scores`);
    
    return data;
  }

  // Get all scores for a playlist (handles pagination)
  async getAllRoomScores(roomId, playlistId) {
    const startTime = Date.now();
    
    let allScores = [];
    let cursor = null;
    let apiCallCount = 0;
    const maxPages = 20; // Safety limit
    
    try {
      console.log(`üìä Starting score fetch for room ${roomId}, playlist ${playlistId}`);
      
      do {
        try {
          const response = await this.getRoomScores(roomId, playlistId, 50, cursor);
          const scores = response.scores || [];
          
          allScores.push(...scores);
          cursor = response.cursor_string;
          apiCallCount++;
          
          console.log(`  Page ${apiCallCount}: +${scores.length} scores (total: ${allScores.length})`);
          
        } catch (pageError) {
          console.error(`‚ùå Failed to fetch scores page ${apiCallCount + 1}:`, pageError.message);
          break;
        }
        
        if (apiCallCount >= maxPages) {
          console.warn(`‚ö†Ô∏è Reached max pages (${maxPages}), stopping pagination`);
          break;
        }
        
      } while (cursor);

      const duration = Date.now() - startTime;
      console.log(`‚úÖ Score fetch complete: ${allScores.length} scores, ${apiCallCount} API calls, ${duration}ms`);
      
      return allScores;
      
    } catch (error) {
      const duration = Date.now() - startTime;
      console.error(`‚ùå getAllRoomScores failed for room ${roomId}, playlist ${playlistId} (${duration}ms):`, error.message);
      throw error;
    }
  }

  // Get beatmap data 
  async getBeatmap(beatmapId) {
    const token = await this.getToken();
    
    console.log(`üì° osu! API: GET /beatmaps/${beatmapId}`);
    
    const response = await trackedFetch(`${this.baseURL}/beatmaps/${beatmapId}`, {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    }, 'osu-api');

    if (!response.ok) {
      console.error(`‚ùå osu! API failed: GET /beatmaps/${beatmapId} (${response.status})`);
      throw new Error(`Failed to get beatmap ${beatmapId}: ${response.status}`);
    }

    console.log(`‚úÖ osu! API: /beatmaps/${beatmapId} success`);
    return response.json();
  }

  // Batch get users
  async getUsers(userIds) {
    const startTime = Date.now();
    const users = [];
    
    console.log(`üìä Fetching ${userIds.length} users in batches...`);
    
    // Process in batches to avoid rate limits
    const batchSize = 5;
    for (let i = 0; i < userIds.length; i += batchSize) {
      const batch = userIds.slice(i, i + batchSize);
      const batchPromises = batch.map(id => this.getUser(id).catch(err => {
        console.warn(`‚ö†Ô∏è Failed to get user ${id}:`, err.message);
        return null;
      }));
      
      const batchResults = await Promise.all(batchPromises);
      const validUsers = batchResults.filter(user => user !== null);
      users.push(...validUsers);
      
      console.log(`  Batch ${Math.floor(i / batchSize) + 1}: ${validUsers.length}/${batch.length} users fetched`);
      
      // Small delay between batches
      if (i + batchSize < userIds.length) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
    
    const duration = Date.now() - startTime;
    console.log(`‚úÖ User fetch complete: ${users.length}/${userIds.length} users (${duration}ms)`);
    
    return users;
  }

  // Helper method to get current API usage stats
  getCurrentUsage() {
    const stats = apiTracker.getUsageStats();
    return {
      percentage: stats.usage?.functions?.percentage || '0',
      current: stats.usage?.functions?.current || 0,
      limit: stats.usage?.functions?.limit || 100000,
      external: stats.breakdown?.external?.total || 0
    };
  }

  // Log current usage with context
  logUsage(context = '') {
    const usage = this.getCurrentUsage();
    console.log(`üìä ${context ? context + ' - ' : ''}API Usage: ${usage.percentage}% (${usage.current}/${usage.limit}), External: ${usage.external}`);
  }

  /**
   * Refresh a user's osu! token using their refresh token
   * @param {string} refreshToken - User's refresh token
   * @returns {Promise<Object>} { access_token, expires_in, refresh_token }
   */
  async refreshUserToken(refreshToken) {
    console.log('üîÑ Refreshing user token...');
    
    const response = await trackedFetch('https://osu.ppy.sh/oauth/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        client_id: process.env.OSU_CLIENT_ID,
        client_secret: process.env.OSU_CLIENT_SECRET,
        grant_type: 'refresh_token',
        refresh_token: refreshToken,
        scope: '*'
      })
    }, 'osu-user-token-refresh');

    if (!response.ok) {
      const errorText = await response.text();
      console.error('‚ùå Token refresh failed:', response.status, errorText);
      throw new Error(`Failed to refresh user token: ${response.status}`);
    }

    const tokenData = await response.json();
    console.log('‚úÖ User token refreshed successfully');
    
    return {
      access_token: tokenData.access_token,
      expires_in: tokenData.expires_in,
      refresh_token: tokenData.refresh_token
    };
  }

  /**
   * Create a multiplayer room using a user's access token
   * @param {Object} roomData - Room configuration object
   * @param {string} userAccessToken - User's access token (not client credentials)
   * @returns {Promise<Object>} Created room object
   */
  async createRoomWithUserToken(roomData, userAccessToken) {
    const startTime = Date.now();
    
    try {
      console.log('üéÆ Creating multiplayer room with user token:', {
        name: roomData.name,
        type: roomData.type,
        playlist_items: roomData.playlist?.length || 0
      });
      
      const response = await trackedFetch(`${this.baseURL}/rooms`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${userAccessToken}`,
          'Content-Type': 'application/json',
          'User-Agent': 'osu!'
        },
        body: JSON.stringify(roomData)
      }, 'osu-api-create-room');

      if (!response.ok) {
        const errorText = await response.text();
        console.error('‚ùå Room creation failed:', response.status, errorText);
        throw new Error(`Failed to create room: ${response.status} - ${errorText}`);
      }

      const room = await response.json();
      const duration = Date.now() - startTime;
      
      console.log('‚úÖ Room created successfully:', {
        room_id: room.id,
        name: room.name,
        duration: `${duration}ms`
      });
      
      return room;
      
    } catch (error) {
      const duration = Date.now() - startTime;
      console.error(`‚ùå createRoomWithUserToken failed (${duration}ms):`, error.message);
      throw error;
    }
  }

  /**
   * Send chat messages to a multiplayer room
   * Temporarily adds the user to the room, sends messages, then removes them
   * @param {number} roomId - osu! room ID
   * @param {number} userId - osu! user ID (the bot user)
   * @param {string[]} messages - Array of message strings to send
   * @param {string} userAccessToken - User's access token
   */
  async sendChatToRoom(roomId, userId, messages, userAccessToken) {
    const startTime = Date.now();
    
    if (!messages || messages.length === 0) {
      console.log('‚ÑπÔ∏è No chat messages to send');
      return;
    }

    console.log(`üí¨ Sending ${messages.length} chat messages to room ${roomId}`);

    try {
      // Step 1: Put user in the room
      console.log(`Adding user ${userId} to room ${roomId}...`);
      const joinResponse = await trackedFetch(
        `${this.baseURL}/rooms/${roomId}/users/${userId}`,
        {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${userAccessToken}`,
            'User-Agent': 'osu!'
          }
        },
        'osu-api-join-room'
      );

      if (!joinResponse.ok) {
        throw new Error(`Failed to join room: ${joinResponse.status}`);
      }

      const roomInfo = await joinResponse.json();
      const channelId = roomInfo.channel_id;

      if (!channelId) {
        throw new Error('Room has no channel_id');
      }

      console.log(`‚úÖ User joined room, channel_id: ${channelId}`);

      // Step 2: Send messages (with retry logic)
      try {
        for (let i = 0; i < messages.length; i++) {
          const message = messages[i];
          console.log(`Sending message ${i + 1}/${messages.length}: "${message.substring(0, 50)}..."`);

          let sent = false;
          let lastError = null;

          // Retry up to 3 times per message
          for (let attempt = 1; attempt <= 3; attempt++) {
            try {
              const msgResponse = await trackedFetch(
                `${this.baseURL}/chat/channels/${channelId}/messages`,
                {
                  method: 'POST',
                  headers: {
                    'Authorization': `Bearer ${userAccessToken}`,
                    'Content-Type': 'application/json',
                    'User-Agent': 'osu!'
                  },
                  body: JSON.stringify({
                    message: message,
                    is_action: false
                  })
                },
                'osu-api-send-message'
              );

              if (msgResponse.ok) {
                console.log(`‚úÖ Message ${i + 1} sent successfully`);
                sent = true;
                break;
              } else {
                const errorText = await msgResponse.text();
                lastError = new Error(`HTTP ${msgResponse.status}: ${errorText}`);
                console.warn(`‚ö†Ô∏è Attempt ${attempt}/3 failed:`, lastError.message);
              }
            } catch (err) {
              lastError = err;
              console.warn(`‚ö†Ô∏è Attempt ${attempt}/3 failed:`, err.message);
            }

            // Wait before retry (exponential backoff)
            if (attempt < 3) {
              const delay = Math.pow(2, attempt) * 500; // 1s, 2s
              console.log(`Waiting ${delay}ms before retry...`);
              await new Promise(resolve => setTimeout(resolve, delay));
            }
          }

          if (!sent) {
            console.error(`‚ùå Failed to send message ${i + 1} after 3 attempts`);
            throw lastError || new Error('Failed to send message');
          }

          // Small delay between messages to avoid rate limiting
          if (i < messages.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 500));
          }
        }

        console.log('‚úÖ All messages sent successfully');

      } finally {
        // Step 3: Remove user from room (always try this, even if sending failed)
        console.log(`3Ô∏è‚É£ Removing user ${userId} from room ${roomId}...`);
        
        let removed = false;
        for (let attempt = 1; attempt <= 3; attempt++) {
          try {
            const leaveResponse = await trackedFetch(
              `${this.baseURL}/rooms/${roomId}/users/${userId}`,
              {
                method: 'DELETE',
                headers: {
                  'Authorization': `Bearer ${userAccessToken}`,
                  'User-Agent': 'osu!'
                }
              },
              'osu-api-leave-room'
            );

            if (leaveResponse.ok || leaveResponse.status === 404) {
              console.log('‚úÖ User removed from room');
              removed = true;
              break;
            } else {
              console.warn(`‚ö†Ô∏è Leave attempt ${attempt}/3 failed: ${leaveResponse.status}`);
            }
          } catch (err) {
            console.warn(`‚ö†Ô∏è Leave attempt ${attempt}/3 failed:`, err.message);
          }

          if (attempt < 3) {
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
        }

        if (!removed) {
          console.error('‚ö†Ô∏è Failed to remove user from room after 3 attempts (non-critical)');
          // Don't throw - user being stuck in room is not critical
        }
      }

      const duration = Date.now() - startTime;
      console.log(`‚úÖ Chat operations complete (${duration}ms)`);

    } catch (error) {
      const duration = Date.now() - startTime;
      console.error(`‚ùå sendChatToRoom failed (${duration}ms):`, error.message);
      throw error;
    }
  }

  /**
   * Helper: Get user info with user token (for verification)
   * @param {string} userAccessToken 
   * @returns {Promise<Object>} User object
   */
  async getUserWithToken(userAccessToken) {
    console.log('üë§ Getting user info with provided token...');
    
    const response = await trackedFetch(`${this.baseURL}/me`, {
      headers: {
        'Authorization': `Bearer ${userAccessToken}`,
        'User-Agent': 'osu!'
      }
    }, 'osu-api-get-me');

    if (!response.ok) {
      throw new Error(`Failed to get user info: ${response.status}`);
    }

    const user = await response.json();
    console.log('‚úÖ User info retrieved:', {
      id: user.id,
      username: user.username
    });
    
    return user;
  }
}

// Export singleton instance
export const trackedOsuAPI = new TrackedOsuAPI();


================================================
FILE: frontend/lib/osu-mods-reference.js
================================================
const OSU_MODS = {
  // Difficulty Reduction
  'EZ': { name: 'Easy', category: 'Difficulty Reduction', settings: [] },
  'NF': { name: 'No Fail', category: 'Difficulty Reduction', settings: [] },
  'HT': { name: 'Half Time', category: 'Difficulty Reduction', settings: ['speed_change', 'adjust_pitch'] },
  'DC': { name: 'Daycore', category: 'Difficulty Reduction', settings: ['speed_change'] },

  // Difficulty Increase
  'HR': { name: 'Hard Rock', category: 'Difficulty Increase', settings: [] },
  'SD': { name: 'Sudden Death', category: 'Difficulty Increase', settings: ['restart', 'fail_on_slider_tail'] },
  'PF': { name: 'Perfect', category: 'Difficulty Increase', settings: ['restart'] },
  'DT': { name: 'Double Time', category: 'Difficulty Increase', settings: ['speed_change', 'adjust_pitch'] },
  'NC': { name: 'Nightcore', category: 'Difficulty Increase', settings: ['speed_change'] },
  'HD': { name: 'Hidden', category: 'Difficulty Increase', settings: ['only_fade_approach_circles'] },
  'FL': { name: 'Flashlight', category: 'Difficulty Increase', settings: ['size_multiplier', 'combo_based_size', 'follow_delay'] },
  'AC': { name: 'Accuracy Challenge', category: 'Difficulty Increase', settings: ['minimum_accuracy', 'accuracy_judge_mode', 'restart'] },
  'BL': { name: 'Blinds', category: 'Difficulty Increase', settings: [] },

  // Automation
  'AT': { name: 'Autoplay', category: 'Automation', settings: [] },
  'CN': { name: 'Cinema', category: 'Automation', settings: [] },
  'RL': { name: 'Relax', category: 'Automation', settings: [] },
  'RX': { name: 'Relax', category: 'Automation', settings: [] },
  'AP': { name: 'Autopilot', category: 'Automation', settings: [] },
  'SO': { name: 'Spun Out', category: 'Automation', settings: [] },

  // Conversion
  'MR': { name: 'Mirror', category: 'Conversion', settings: ['reflection'] },
  'DA': { name: 'Difficulty Adjust', category: 'Conversion', settings: ['circle_size', 'drain_rate', 'overall_difficulty', 'approach_rate', 'scroll_speed'] },
  'CL': { name: 'Classic', category: 'Conversion', settings: ['no_slider_head_accuracy', 'classic_note_lock', 'always_play_tail_sample', 'fade_hit_circle_early', 'classic_health'] },
  'RD': { name: 'Random', category: 'Conversion', settings: ['seed', 'angle_sharpness'] },
  'TP': { name: 'Target Practice', category: 'Conversion', settings: ['seed', 'metronome'] },
  'FR': { name: 'Freeze Frame', category: 'Conversion', settings: [] },
  'ST': { name: 'Strict Tracking', category: 'Conversion', settings: [] },

  // Fun & Visual
  'WU': { name: 'Wind Up', category: 'Fun', settings: ['initial_rate', 'final_rate', 'adjust_pitch'] },
  'WD': { name: 'Wind Down', category: 'Fun', settings: ['initial_rate', 'final_rate', 'adjust_pitch'] },
  'AS': { name: 'Adaptive Speed', category: 'Fun', settings: ['initial_rate', 'adjust_pitch'] },
  'AD': { name: 'Approach Different', category: 'Fun', settings: ['initial_size', 'style'] },
  'MU': { name: 'Muted', category: 'Fun', settings: ['start_muted', 'enable_metronome', 'final_volume_combo_count', 'mute_hit_sounds'] },
  'DF': { name: 'Deflate', category: 'Fun', settings: ['start_scale'] },
  'GR': { name: 'Grow', category: 'Fun', settings: ['start_scale'] },
  'SI': { name: 'Spin In', category: 'Fun', settings: [] },
  'TC': { name: 'Traceable', category: 'Fun', settings: [] },
  'BR': { name: 'Barrel Roll', category: 'Fun', settings: ['roll_speed', 'direction'] },
  'DP': { name: 'Depth', category: 'Fun', settings: ['max_depth', 'show_approach_circles'] },
  'TR': { name: 'Transform', category: 'Fun', settings: [] },
  'WG': { name: 'Wiggle', category: 'Fun', settings: ['strength'] },
  'MG': { name: 'Magnetised', category: 'Fun', settings: ['attraction_strength'] },
  'RP': { name: 'Repel', category: 'Fun', settings: ['repulsion_strength'] },
  'BU': { name: 'Bubbles', category: 'Fun', settings: [] },
  'SY': { name: 'Synesthesia', category: 'Fun', settings: [] },
  'BM': { name: 'Bloom', category: 'Fun', settings: ['max_size_combo_count', 'max_cursor_size'] },
  'NS': { name: 'No Scope', category: 'Fun', settings: ['hidden_combo_count'] },
  'AL': { name: 'Alternate', category: 'Fun', settings: [] },
  'SG': { name: 'Single Tap', category: 'Fun', settings: [] },

  // System
  'TD': { name: 'Touch Device', category: 'System', settings: [] },
  'SV2': { name: 'Score V2', category: 'System', settings: [] },

  // osu!mania Key Mods
  '1K': { name: '1 Key', category: 'osu!mania', settings: [] },
  '2K': { name: '2 Keys', category: 'osu!mania', settings: [] },
  '3K': { name: '3 Keys', category: 'osu!mania', settings: [] },
  '4K': { name: '4 Keys', category: 'osu!mania', settings: [] },
  '5K': { name: '5 Keys', category: 'osu!mania', settings: [] },
  '6K': { name: '6 Keys', category: 'osu!mania', settings: [] },
  '7K': { name: '7 Keys', category: 'osu!mania', settings: [] },
  '8K': { name: '8 Keys', category: 'osu!mania', settings: [] },
  '9K': { name: '9 Keys', category: 'osu!mania', settings: [] },

  // osu!mania Specific
  'DS': { name: 'Dual Stages', category: 'osu!mania', settings: [] },
  'IN': { name: 'Invert', category: 'osu!mania', settings: [] },
  'CS': { name: 'Constant Speed', category: 'osu!mania', settings: ['scroll_speed'] },
  'HO': { name: 'Hold Off', category: 'osu!mania', settings: [] },
  'NR': { name: 'No Release', category: 'osu!mania', settings: [] },
  'FI': { name: 'Fade In', category: 'osu!mania', settings: [] },

  // Mode Specific
  'SW': { name: 'Swap', category: 'Mode Specific', settings: [] },
  'FF': { name: 'Floating Fruits', category: 'Mode Specific', settings: [] },
};

const SETTING_CONFIGS = {
  // Speed/Rate settings
  speed_change: { 
    type: 'range', 
    getMin: (mod) => (['HT', 'DC'].includes(mod) ? 0.5 : 1.01),
    getMax: (mod) => (['HT', 'DC'].includes(mod) ? 0.99 : 2.0),
    step: 0.01, 
    getDefault: (mod) => (['HT', 'DC'].includes(mod) ? 0.75 : 1.5),
    label: 'Speed Change',
    format: (val) => `${val}x`
  },
  adjust_pitch: { 
    type: 'boolean', 
    default: false,
    label: 'Adjust Pitch'
  },

  // Wind Up/Down
  initial_rate: { 
    type: 'range', 
    getMin: (mod) => (mod === 'WU' ? 0.5 : 0.51),
    getMax: (mod) => (mod === 'WU' ? 1.99 : 2.0),
    step: 0.01, 
    getDefault: (mod) => (mod === 'WU' ? 1.0 : 1.0),
    label: 'Initial Rate',
    format: (val) => `${val}x`
  },
  final_rate: { 
    type: 'range', 
    getMin: (mod) => (mod === 'WU' ? 0.51 : 0.5),
    getMax: (mod) => (mod === 'WU' ? 2.0 : 1.99),
    step: 0.01, 
    getDefault: (mod) => (mod === 'WU' ? 1.5 : 0.75),
    label: 'Final Rate',
    format: (val) => `${val}x`
  },

  // Fail condition settings
  restart: { 
    type: 'boolean', 
    default: false,
    label: 'Auto Restart on Fail'
  },
  fail_on_slider_tail: { 
    type: 'boolean', 
    default: false,
    label: 'Fail on Slider Tail Miss'
  },

  // Accuracy Challenge
  minimum_accuracy: { 
    type: 'range', 
    min: 0.6, 
    max: 0.99, 
    step: 0.01, 
    default: 0.9,
    label: 'Minimum Accuracy',
    format: (val) => `${(val * 100).toFixed(0)}%`
  },
  accuracy_judge_mode: { 
    type: 'select', 
    options: [
      { value: 'Standard', label: 'Standard' },
      { value: 'MaximumAchievable', label: 'Maximum Achievable' }
    ],
    default: 'Standard',
    label: 'Accuracy Mode'
  },

  // Hidden settings
  only_fade_approach_circles: { 
    type: 'boolean', 
    default: false,
    label: 'Only Fade Approach Circles'
  },

  // Flashlight settings
  size_multiplier: { 
    type: 'range', 
    min: 0.5, 
    max: 2.0, 
    step: 0.1, 
    default: 1.0,
    label: 'Size Multiplier',
    format: (val) => `${val}x`
  },
  combo_based_size: { 
    type: 'boolean', 
    default: true,
    label: 'Combo Based Size'
  },
  follow_delay: { 
    type: 'range', 
    min: 120, 
    max: 1200, 
    step: 10, 
    default: 120,
    label: 'Follow Delay',
    format: (val) => `${val}ms`
  },

  // Mirror settings
  reflection: { 
    type: 'select', 
    options: [
      { value: 0, label: 'Horizontal' },
      { value: 1, label: 'Vertical' },
      { value: 2, label: 'Both' }
    ],
    default: 0,
    label: 'Reflection Type'
  },

  // Difficulty Adjust settings
  circle_size: { 
    type: 'range', 
    min: 0.0, 
    max: 11.0, 
    step: 0.1, 
    default: 5.0,
    label: 'Circle Size'
  },
  drain_rate: { 
    type: 'range', 
    min: 0.0, 
    max: 11.0, 
    step: 0.1, 
    default: 5.0,
    label: 'Drain Rate'
  },
  overall_difficulty: { 
    type: 'range', 
    min: 0.0, 
    max: 11.0, 
    step: 0.1, 
    default: 5.0,
    label: 'Overall Difficulty'
  },
  approach_rate: { 
    type: 'range', 
    min: -10.0, 
    max: 11.0, 
    step: 0.1, 
    default: 9.0,
    label: 'Approach Rate'
  },
  scroll_speed: { 
    type: 'range', 
    min: 0.01, 
    max: 4.0, 
    step: 0.01, 
    default: 1.5,
    label: 'Scroll Speed',
    format: (val) => `${val}x`
  },

  // Classic settings
  no_slider_head_accuracy: { 
    type: 'boolean', 
    default: true,
    label: 'No Slider Head Accuracy'
  },
  classic_note_lock: { 
    type: 'boolean', 
    default: true,
    label: 'Classic Note Lock'
  },
  always_play_tail_sample: { 
    type: 'boolean', 
    default: true,
    label: 'Always Play Tail Sample'
  },
  fade_hit_circle_early: { 
    type: 'boolean', 
    default: true,
    label: 'Fade Hit Circle Early'
  },
  classic_health: { 
    type: 'boolean', 
    default: true,
    label: 'Classic Health'
  },

  // Random settings
  seed: { 
    type: 'number', 
    default: 0,
    label: 'Random Seed'
  },
  angle_sharpness: { 
    type: 'range', 
    min: 1.0, 
    max: 10.0, 
    step: 0.1, 
    default: 7.0,
    label: 'Angle Sharpness'
  },

  // Target Practice settings
  metronome: { 
    type: 'boolean', 
    default: true,
    label: 'Enable Metronome'
  },

  // Approach Different
  initial_size: { 
    type: 'range', 
    min: 1.5, 
    max: 10.0, 
    step: 0.1, 
    default: 4.0,
    label: 'Initial Size',
    format: (val) => `${val}x`
  },
  style: { 
    type: 'select', 
    options: [
      { value: 0, label: 'Linear' },
      { value: 1, label: 'Gravity' },
      { value: 2, label: 'InOut1' },
      { value: 3, label: 'InOut2' },
      { value: 4, label: 'Accelerate1' },
      { value: 5, label: 'Accelerate2' },
      { value: 6, label: 'Accelerate3' },
      { value: 7, label: 'Decelerate1' },
      { value: 8, label: 'Decelerate2' },
      { value: 9, label: 'Decelerate3' }
    ],
    default: 0,
    label: 'Animation Style'
  },

  // Muted
  start_muted: { 
    type: 'boolean', 
    default: false,
    label: 'Start Muted'
  },
  enable_metronome: { 
    type: 'boolean', 
    default: true,
    label: 'Enable Metronome'
  },
  final_volume_combo_count: { 
    type: 'range', 
    min: 0, 
    max: 500, 
    step: 1, 
    default: 100,
    label: 'Final Volume at Combo Count'
  },
  mute_hit_sounds: { 
    type: 'boolean', 
    default: true,
    label: 'Mute Hit Sounds'
  },

  // Scale modification settings
  start_scale: { 
    type: 'range', 
    getMin: (mod) => (mod === 'GR' ? 0.0 : 1.0),
    getMax: (mod) => (mod === 'GR' ? 0.99 : 25.0),
    getStep: (mod) => (mod === 'GR' ? 0.01 : 0.1),
    getDefault: (mod) => (mod === 'GR' ? 0.5 : 2.0),
    label: 'Start Scale',
    format: (val) => `${val}x`
  },

  // Barrel Roll (corrected name)
  spin_speed: { 
    type: 'range', 
    min: 0.02, 
    max: 12.0, 
    step: 0.01, 
    default: 0.5,
    label: 'Spin Speed',
    format: (val) => `${val}`
  },
  direction: { 
    type: 'select', 
    options: [
      { value: 'Clockwise', label: 'Clockwise' },
      { value: 'Counterclockwise', label: 'Counterclockwise' }
    ],
    default: 'Clockwise',
    label: 'Direction of Rotation'
  },

  // Depth settings
  max_depth: { 
    type: 'range', 
    min: 50, 
    max: 200, 
    step: 5, 
    default: 100,
    label: 'Max Depth'
  },
  show_approach_circles: { 
    type: 'boolean', 
    default: true,
    label: 'Show Approach Circles'
  },

  // Wiggle settings
  strength: { 
    type: 'range', 
    min: 0.1, 
    max: 2.0, 
    step: 0.1, 
    default: 1.0,
    label: 'Wiggle Strength',
    format: (val) => `${val}x`
  },

  // Attraction/Repulsion settings
  attraction_strength: { 
    type: 'range', 
    min: 0.05, 
    max: 1.0, 
    step: 0.05, 
    default: 0.5,
    label: 'Attraction Strength',
    format: (val) => `${(val * 100).toFixed(0)}%`
  },
  repulsion_strength: { 
    type: 'range', 
    min: 0.05, 
    max: 1.0, 
    step: 0.05, 
    default: 0.5,
    label: 'Repulsion Strength',
    format: (val) => `${(val * 100).toFixed(0)}%`
  },

  // Bloom settings
  max_size_combo_count: { 
    type: 'range', 
    min: 5, 
    max: 100, 
    step: 5, 
    default: 50,
    label: 'Max Size Combo Count'
  },
  max_cursor_size: { 
    type: 'range', 
    min: 5.0, 
    max: 15.0, 
    step: 0.1, 
    default: 10.0,
    label: 'Max Cursor Size',
    format: (val) => `${val}x`
  },

  // No Scope settings
  hidden_combo_count: { 
    type: 'range', 
    min: 0, 
    max: 50, 
    step: 1, 
    default: 10,
    label: 'Hidden Combo Count'
  }
};

const CONFLICTING_MODS = [
  ['HT', 'DC', 'DT', 'NC', 'WU', 'WD', 'AS'], // Speed/Rate mods
  ['EZ', 'HR'], // Difficulty adjustment
  ['NF', 'SD', 'PF', 'AC', 'CN'], // Fail conditions
  ['AT', 'CN', 'RL', 'RX', 'AP', 'SO'], // Automation
  ['AL', 'SG'], // Input modification
  ['MG', 'RP'], // Position modification
  ['FI', 'HD', 'FL'], // Visual conflicts (mania)
  ['HO', 'NR'], // Hold note mods (mania)
  ['TR', 'WG', 'MG', 'RP', 'BU', 'DP'], // Transformation mods
  ['ST', 'TP', 'SD', 'SO'], // Target practice conflicts (restored)
];

const SETTING_RANGES = {
  // Speed/Rate settings
  speed_change: { 
    min: function(modAcronym) {
      if (['HT', 'DC'].includes(modAcronym)) return 0.5;
      if (['DT', 'NC'].includes(modAcronym)) return 1.01;
      return 0.5;
    },
    max: function(modAcronym) {
      if (['HT', 'DC'].includes(modAcronym)) return 0.99;
      if (['DT', 'NC'].includes(modAcronym)) return 2.0;
      return 2.0;
    },
    type: 'number', 
    precision: 0.01 
  },
  adjust_pitch: { type: 'boolean' },
  
  // Wind Up/Down
  initial_rate: { 
    min: function(modAcronym) {
      if (modAcronym === 'WU') return 0.5;
      if (modAcronym === 'WD') return 0.51;
      return 0.5;
    },
    max: function(modAcronym) {
      if (modAcronym === 'WU') return 1.99;
      if (modAcronym === 'WD') return 2.0;
      return 2.0;
    },
    type: 'number', 
    precision: 0.01 
  },
  final_rate: { 
    min: function(modAcronym) {
      if (modAcronym === 'WU') return 0.51;
      if (modAcronym === 'WD') return 0.5;
      return 0.5;
    },
    max: function(modAcronym) {
      if (modAcronym === 'WU') return 2.0;
      if (modAcronym === 'WD') return 1.99;
      return 2.0;
    },
    type: 'number', 
    precision: 0.01 
  },
  
  // Fail condition settings
  restart: { type: 'boolean' },
  fail_on_slider_tail: { type: 'boolean' },
  
  // Accuracy Challenge
  minimum_accuracy: { min: 0.6, max: 0.99, type: 'number', precision: 0.01 },
  accuracy_judge_mode: { 
    type: 'select', 
    options: ['Standard', 'Maximum Achievable'] 
  },
  
  // Hidden settings
  only_fade_approach_circles: { type: 'boolean' },
  
  // Flashlight settings
  size_multiplier: { min: 0.5, max: 2.0, type: 'number', precision: 0.1 },
  combo_based_size: { type: 'boolean' },
  follow_delay: { min: 120.0, max: 1200.0, type: 'number', precision: 1.0 },
  
  // Mirror settings
  reflection: { min: 0, max: 2, type: 'integer' },
  
  // Difficulty Adjust settings
  circle_size: { min: 0.0, max: 11.0, type: 'number', precision: 0.1 },
  drain_rate: { min: 0.0, max: 11.0, type: 'number', precision: 0.1 },
  overall_difficulty: { min: 0.0, max: 11.0, type: 'number', precision: 0.1 },
  approach_rate: { min: -10.0, max: 11.0, type: 'number', precision: 0.1 },
  scroll_speed: { min: 0.01, max: 4.0, type: 'number', precision: 0.01 },
  
  // Classic settings
  no_slider_head_accuracy: { type: 'boolean' },
  classic_note_lock: { type: 'boolean' },
  always_play_tail_sample: { type: 'boolean' },
  fade_hit_circle_early: { type: 'boolean' },
  classic_health: { type: 'boolean' },
  
  // Random settings
  seed: { type: 'integer' },
  angle_sharpness: { min: 1.0, max: 10.0, type: 'number', precision: 0.1 },
  
  // Target Practice settings
  metronome: { type: 'boolean' },
  
  // Approach Different
  initial_size: { min: 1.5, max: 10.0, type: 'number', precision: 0.1 },
  style: { 
    type: 'select', 
    options: ['Linear', 'Gravity', 'InOut1', 'InOut2', 'Accelerate1', 'Accelerate2', 'Accelerate3', 'Decelerate1', 'Decelerate2', 'Decelerate3'] 
  },
  
  // Muted
  start_muted: { type: 'boolean' },
  enable_metronome: { type: 'boolean' },
  final_volume_combo_count: { min: 0, max: 500, type: 'integer' },
  mute_hit_sounds: { type: 'boolean' },
  
  // Scale modification settings
  start_scale: { 
    min: function(modAcronym) {
      if (modAcronym === 'GR') return 0.0;
      if (modAcronym === 'DF') return 1.0;
      return 0.0;
    },
    max: function(modAcronym) {
      if (modAcronym === 'GR') return 0.99;
      if (modAcronym === 'DF') return 25.0;
      return 25.0;
    },
    type: 'number', 
    precision: function(modAcronym) {
      if (modAcronym === 'GR') return 0.01;
      if (modAcronym === 'DF') return 0.1;
      return 0.1;
    }
  },
  
  // Barrel Roll (corrected name)
  spin_speed: { min: 0.02, max: 12.0, type: 'number', precision: 0.01 },
  direction: { 
    type: 'select', 
    options: ['Clockwise', 'Counterclockwise'] 
  },
  
  // Depth settings
  max_depth: { min: 50, max: 200, type: 'integer' },
  show_approach_circles: { type: 'boolean' },
  
  // Wiggle settings
  strength: { min: 0.1, max: 2.0, type: 'number', precision: 0.1 },
  
  // Attraction/Repulsion settings
  attraction_strength: { min: 0.05, max: 1.0, type: 'number', precision: 0.05 },
  repulsion_strength: { min: 0.05, max: 1.0, type: 'number', precision: 0.05 },
  
  // Bloom settings
  max_size_combo_count: { min: 5, max: 100, type: 'integer' },
  max_cursor_size: { min: 5.0, max: 15.0, type: 'number', precision: 0.1 },
  
  // No Scope settings
  hidden_combo_count: { min: 0, max: 50, type: 'integer' },
};

// Mode-specific mods for filtering
const MODE_SPECIFIC_MODS = {
  'osu': ['BL', 'AP', 'SO', 'TP', 'FR', 'ST', 'AD', 'DF', 'GR', 'SI', 'TC', 'DP', 'TR', 'WG', 'MG', 'RP', 'BU', 'BM', 'AL', 'SG', 'TD'],
  'taiko': ['SW'],
  'catch': ['FF'],
  'mania': ['1K', '2K', '3K', '4K', '5K', '6K', '7K', '8K', '9K', 'DS', 'IN', 'CS', 'HO', 'NR', 'FI']
};

module.exports = {
  OSU_MODS,
  CONFLICTING_MODS,
  SETTING_RANGES,
  SETTING_CONFIGS,
  MODE_SPECIFIC_MODS
};


================================================
FILE: frontend/lib/ruleset-name-generator.js
================================================
// lib/ruleset-name-generator.js
// Utility for auto-generating ruleset names from mod data

// Default values for mod settings (only show in name if different)
const MOD_DEFAULT_VALUES = {
  // Speed/Rate settings
  speed_change: 1.5, // For DT/NC
  adjust_pitch: false,
  initial_rate: 1.0,
  final_rate: 1.5,
  
  // Fail condition settings
  restart: false,
  fail_on_slider_tail: false,
  minimum_accuracy: 0.8,
  
  // Visual settings
  only_fade_approach_circles: false,
  
  // Flashlight settings
  size_multiplier: 1.0,
  combo_based_size: true,
  follow_delay: 120,
  
  // Mirror settings
  reflection: 0, // Horizontal
  
  // Difficulty Adjust (use null to indicate "not specified")
  circle_size: null,
  drain_rate: null,
  overall_difficulty: null,
  approach_rate: null,
  scroll_speed: 1.5,
  
  // Classic settings (all true by default)
  no_slider_head_accuracy: true,
  classic_note_lock: true,
  always_play_tail_sample: true,
  fade_hit_circle_early: true,
  classic_health: true,
  
  // Random settings
  seed: 0,
  angle_sharpness: 7.0,
  
  // Target Practice
  metronome: true,
  
  // Approach Different
  scale: 4.0,
  style: 0, // Linear
  
  // Muted settings
  inverse_muting: false,
  enable_metronome: false,
  mute_combo_count: 25,
  
  // Scale modification
  start_scale: 2.0,
  
  // Barrel Roll
  spin_speed: 1.0,
  spin_speed: 1.0,
  
  // Depth
  max_depth: 100,
  show_approach_circles: true,
  
  // Wiggle
  strength: 1.0,
  
  // Attraction/Repulsion
  attraction_strength: 0.5,
  repulsion_strength: 0.5,
  
  // Bloom
  max_size_combo_count: 50,
  max_cursor_size: 10.0,
  
  // No Scope
  hidden_combo_count: 10
};

// Format functions for different setting types
const SETTING_FORMATTERS = {
  // Multipliers with 'x' suffix
  speed_change: (val, defaultVal) => val !== defaultVal ? `${val}x` : null,
  initial_rate: (val, defaultVal) => val !== defaultVal ? `${val}x` : null,
  final_rate: (val, defaultVal) => val !== defaultVal ? `${val}x` : null,
  size_multiplier: (val, defaultVal) => val !== defaultVal ? `${val}x` : null,
  scroll_speed: (val, defaultVal) => val !== defaultVal ? `${val}x` : null,
  start_scale: (val, defaultVal) => val !== defaultVal ? `${val}x` : null,
  roll_speed: (val, defaultVal) => val !== defaultVal ? `${val}x` : null,
  spin_speed: (val, defaultVal) => val !== defaultVal ? `${val}x` : null,
  strength: (val, defaultVal) => val !== defaultVal ? `${val}x` : null,
  max_cursor_size: (val, defaultVal) => val !== defaultVal ? `${val}x` : null,
  
  // Percentages
  minimum_accuracy: (val, defaultVal) => val !== defaultVal ? `${Math.round(val * 100)}%` : null,
  attraction_strength: (val, defaultVal) => val !== defaultVal ? `${Math.round(val * 100)}%` : null,
  repulsion_strength: (val, defaultVal) => val !== defaultVal ? `${Math.round(val * 100)}%` : null,
  
  // Time values
  follow_delay: (val, defaultVal) => val !== defaultVal ? `${val}ms` : null,
  
  // Reflection type
  reflection: (val, defaultVal) => {
    if (val === defaultVal) return null;
    const types = ['H', 'V', 'HV'];
    return types[val] || 'H';
  },
  
  // Style enum
  style: (val, defaultVal) => {
    if (val === defaultVal) return null;
    const styles = ['Lin', 'Grav', 'IO1', 'IO2', 'A1', 'A2', 'A3', 'D1', 'D2', 'D3'];
    return styles[val] || 'Lin';
  },
  
  // Difficulty Adjust - special handling for null defaults
  circle_size: (val, defaultVal) => val != null ? `CS${val}` : null,
  drain_rate: (val, defaultVal) => val != null ? `HP${val}` : null,
  overall_difficulty: (val, defaultVal) => val != null ? `OD${val}` : null,
  approach_rate: (val, defaultVal) => val != null ? `AR${val}` : null,
  
  // Simple numeric values
  scale: (val, defaultVal) => val !== defaultVal ? val.toString() : null,
  max_depth: (val, defaultVal) => val !== defaultVal ? val.toString() : null,
  angle_sharpness: (val, defaultVal) => val !== defaultVal ? val.toString() : null,
  mute_combo_count: (val, defaultVal) => val !== defaultVal ? val.toString() : null,
  max_size_combo_count: (val, defaultVal) => val !== defaultVal ? val.toString() : null,
  hidden_combo_count: (val, defaultVal) => val !== defaultVal ? val.toString() : null,
  seed: (val, defaultVal) => val !== defaultVal ? val.toString() : null,
  
  // Boolean flags - only show if true and different from default
  adjust_pitch: (val, defaultVal) => val !== defaultVal && val ? 'Pitch' : null,
  restart: (val, defaultVal) => val !== defaultVal && val ? 'Restart' : null,
  fail_on_slider_tail: (val, defaultVal) => val !== defaultVal && val ? 'FailTail' : null,
  only_fade_approach_circles: (val, defaultVal) => val !== defaultVal && val ? 'FadeAC' : null,
  combo_based_size: (val, defaultVal) => val !== defaultVal ? (val ? 'ComboSize' : 'NoComboSize') : null,
  metronome: (val, defaultVal) => val !== defaultVal ? (val ? 'Metro' : 'NoMetro') : null,
  inverse_muting: (val, defaultVal) => val !== defaultVal && val ? 'InvMute' : null,
  enable_metronome: (val, defaultVal) => val !== defaultVal && val ? 'Metro' : null,
  show_approach_circles: (val, defaultVal) => val !== defaultVal ? (val ? 'ShowAC' : 'HideAC') : null,
  
  // Classic mod settings - only show if different from default (all true)
  no_slider_head_accuracy: (val, defaultVal) => val !== defaultVal ? (val ? null : 'SliderHead') : null,
  classic_note_lock: (val, defaultVal) => val !== defaultVal ? (val ? null : 'ModernLock') : null,
  always_play_tail_sample: (val, defaultVal) => val !== defaultVal ? (val ? null : 'NoTailSample') : null,
  fade_hit_circle_early: (val, defaultVal) => val !== defaultVal ? (val ? null : 'NoEarlyFade') : null,
  classic_health: (val, defaultVal) => val !== defaultVal ? (val ? null : 'ModernHealth') : null
};

/**
 * Generate a formatted string for a single mod with its settings
 * @param {Object} mod - Mod object with acronym and settings
 * @returns {string} - Formatted mod string (e.g., "DT(1.8x)", "HR", "DA(CS4OD8)")
 */
function formatSingleMod(mod) {
  const { acronym, settings = {} } = mod;
  
  // Get all non-default settings for this mod
  const formattedSettings = [];
  
  for (const [settingKey, settingValue] of Object.entries(settings)) {
    const defaultValue = MOD_DEFAULT_VALUES[settingKey];
    const formatter = SETTING_FORMATTERS[settingKey];
    
    if (formatter) {
      const formatted = formatter(settingValue, defaultValue);
      if (formatted) {
        formattedSettings.push(formatted);
      }
    }
  }
  
  // Return acronym with settings in parentheses if any
  if (formattedSettings.length > 0) {
    return `${acronym}(${formattedSettings.join('')})`;
  }
  
  return acronym;
}

/**
 * Generate a ruleset name from mod array and match type
 * @param {Array} requiredMods - Array of mod objects
 * @param {string} matchType - 'exact', 'at_least', or 'any_of'
 * @returns {string} - Generated ruleset name
 */
function generateRulesetName(requiredMods, matchType = 'at_least') {
  if (!requiredMods || requiredMods.length === 0) {
    return 'NoMod';
  }
  
  // Format each mod
  const formattedMods = requiredMods.map(formatSingleMod);
  
  // Join mods without separators (standard osu! convention)
  let modString = formattedMods.join('');
  
  // Add prefix for non-exact match types
  switch (matchType) {
    case 'at_least':
      modString = `AtLeast:${modString}`;
      break;
    case 'any_of':
      modString = `Any:${modString}`;
      break;
    case 'exact':
    default:
      // No prefix for exact match
      break;
  }
  
  return modString;
}

/**
 * Generate a human-readable description of the ruleset
 * @param {Array} requiredMods - Array of mod objects
 * @param {string} matchType - 'exact', 'at_least', or 'any_of'
 * @returns {string} - Human-readable description
 */
function generateRulesetDescription(requiredMods, matchType = 'at_least') {
  if (!requiredMods || requiredMods.length === 0) {
    return 'No mods required';
  }
  
  const modNames = requiredMods.map(mod => mod.acronym).join(', ');
  
  switch (matchType) {
    case 'exact':
      return `Must use exactly: ${modNames}`;
    case 'at_least':
      return `Must include all of: ${modNames} (extras allowed)`;
    case 'any_of':
      return `Must include at least one of: ${modNames} (extras allowed)`;
    default:
      return `Invalid match type: ${matchType}`;
  }
}

/**
 * Validate if a generated name would be unique
 * @param {string} generatedName - The generated name to check
 * @param {Array} existingNames - Array of existing ruleset names to check against
 * @returns {boolean} - True if unique, false if duplicate
 */
function isRulesetNameUnique(generatedName, existingNames = []) {
  return !existingNames.includes(generatedName);
}

/**
 * Get a preview of what the ruleset name will look like
 * @param {Array} requiredMods - Array of mod objects
 * @param {string} matchType - 'exact', 'at_least', or 'any_of'
 * @returns {Object} - Object with name, description, and validation info
 */
function previewRulesetName(requiredMods, matchType = 'at_least') {
  const name = generateRulesetName(requiredMods, matchType);
  const description = generateRulesetDescription(requiredMods, matchType);
  
  return {
    name,
    description,
    isValid: name.length > 0 && name.length <= 100, // Reasonable length limit
    modCount: requiredMods ? requiredMods.length : 0
  };
}

// Export for ES6 modules
export {
  generateRulesetName,
  generateRulesetDescription,
  previewRulesetName,
  isRulesetNameUnique,
  formatSingleMod,
  MOD_DEFAULT_VALUES,
  SETTING_FORMATTERS
};

// Also export as default for convenience
export default {
  generateRulesetName,
  generateRulesetDescription,
  previewRulesetName,
  isRulesetNameUnique,
  formatSingleMod,
  MOD_DEFAULT_VALUES,
  SETTING_FORMATTERS
};

// Backward compatibility
if (typeof window !== 'undefined') {
  window.RulesetNameGenerator = {
    generateRulesetName,
    generateRulesetDescription,
    previewRulesetName,
    isRulesetNameUnique,
    formatSingleMod
  };
}


================================================
FILE: frontend/lib/seasons.js
================================================
// frontend/lib/seasons.js
import { supabase } from './supabase';

// Season utility functions
export const seasonUtils = {
  // Check if we need to rotate seasons (6-month rotation)
  shouldRotateSeason: (currentSeason) => {
    if (!currentSeason) return true;
    
    const now = new Date();
    const seasonEnd = new Date(currentSeason.end_date);
    
    return now > seasonEnd;
  },

  // Generate season name based on current date (6-month seasons)
  generateSeasonName: async (date = new Date(), supabaseInstance = null) => {
    try {
      // Use provided instance or default to client supabase
      const supabaseToUse = supabaseInstance || supabase;
      
      // Get all existing seasons to determine next number
      const { data: seasons, error } = await supabaseToUse
        .from('seasons')
        .select('name')
        .order('id', { ascending: false });
      
      if (error) {
        console.error('Error fetching seasons for name generation:', error);
        return 'Season 1'; // Default fallback
      }
      
      // Find the highest season number
      let nextSeasonNumber = 1;
      if (seasons && seasons.length > 0) {
        const seasonNumbers = seasons
          .map(season => {
            const match = season.name.match(/^Season (\d+)$/);
            return match ? parseInt(match[1]) : 0;
          })
          .filter(num => num > 0);
        
        if (seasonNumbers.length > 0) {
          nextSeasonNumber = Math.max(...seasonNumbers) + 1;
        }
      }
      
      return `Season ${nextSeasonNumber}`;
    } catch (error) {
      console.error('Error generating season name:', error);
      return 'Season 1';
    }
  },

  // Get season date range for a given year and half (1 = Spring, 2 = Fall)
  getSeasonDateRange: (year, half) => {
    let start, end;
    
    if (half === 1) {
      // Spring season: January 1 - June 30 (UTC)
      start = new Date(Date.UTC(year, 0, 1, 0, 0, 0)); // January 1 UTC
      end = new Date(Date.UTC(year, 5, 30, 23, 59, 59)); // June 30 UTC
    } else {
      // Fall season: July 1 - December 31 (UTC)
      start = new Date(Date.UTC(year, 6, 1, 0, 0, 0)); // July 1 UTC
      end = new Date(Date.UTC(year, 11, 31, 23, 59, 59)); // December 31 UTC
    }
    
    return {
      start_date: start.toISOString(),
      end_date: end.toISOString()
    };
  },

  // Get current season info (which half of year we're in)
  getCurrentSeasonInfo: (date = new Date()) => {
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const half = month <= 6 ? 1 : 2;
    
    return { year, half };
  },

  // Auto-rotate season if needed (6-month rotation)
  autoRotateSeason: async (supabaseInstance = null) => {
    try {
      const supabaseToUse = supabaseInstance || supabase;
      
      const { data: currentSeason } = await supabaseToUse
        .from('seasons')
        .select('*')
        .eq('is_current', true)
        .single();

      if (seasonUtils.shouldRotateSeason(currentSeason)) {
        const now = new Date();
        const { year, half } = seasonUtils.getCurrentSeasonInfo(now);
        const dateRange = seasonUtils.getSeasonDateRange(year, half);
        
        // Get next season number
        const newSeasonName = await seasonUtils.generateSeasonName(now, supabaseToUse);

        // Mark current season as not current
        if (currentSeason) {
          await supabaseToUse
            .from('seasons')
            .update({ is_current: false })
            .eq('id', currentSeason.id);
        }

        // Create new current season
        const { data: newSeason, error } = await supabaseToUse
          .from('seasons')
          .insert({
            name: newSeasonName,
            start_date: dateRange.start_date,
            end_date: dateRange.end_date,
            is_current: true,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          })
          .select()
          .single();

        if (error) {
          console.error('Error creating new season:', error);
          return null;
        }

        console.log('Season rotated to:', newSeasonName);
        return newSeason;
      }

      return currentSeason;
    } catch (error) {
      console.error('Error in auto-rotate season:', error);
      return null;
    }
  },

  // Get current season with auto-rotation
  getCurrentSeasonWithRotation: async () => {
    return await seasonUtils.autoRotateSeason();
  },

  // Format season display name
  formatSeasonName: (season) => {
    if (!season) return 'Unknown Season';
    return season.name;
  },

  // Format season date range for display
  formatSeasonDateRange: (season) => {
    if (!season || !season.start_date || !season.end_date) return '';
    
    const start = new Date(season.start_date);
    const end = new Date(season.end_date);
    
    const startStr = start.toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric',
      year: 'numeric'
    });
    const endStr = end.toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric',
      year: 'numeric'
    });
    
    return `${startStr} - ${endStr}`;
  },

  // Check if a date falls within a season
  isDateInSeason: (date, season) => {
    if (!season) return false;
    
    const checkDate = new Date(date);
    const seasonStart = new Date(season.start_date);
    const seasonEnd = new Date(season.end_date);
    
    return checkDate >= seasonStart && checkDate <= seasonEnd;
  },

  // Get the season that contains a specific date
  getSeasonForDate: async (date) => {
    try {
      const { data: seasons, error } = await supabase
        .from('seasons')
        .select('*')
        .order('start_date', { ascending: false });

      if (error) throw error;

      for (const season of seasons) {
        if (seasonUtils.isDateInSeason(date, season)) {
          return season;
        }
      }

      return null;
    } catch (error) {
      console.error('Error finding season for date:', error);
      return null;
    }
  },

  // Group challenges by season
  groupChallengesBySeason: (challenges) => {
    const grouped = {};
    
    challenges.forEach(challenge => {
      const seasonName = challenge.seasons?.name || 'Unknown Season';
      if (!grouped[seasonName]) {
        grouped[seasonName] = {
          season: challenge.seasons,
          challenges: []
        };
      }
      grouped[seasonName].challenges.push(challenge);
    });
    
    // Sort groups by season start date (most recent first)
    const sortedGroups = {};
    Object.keys(grouped)
      .sort((a, b) => {
        const seasonA = grouped[a].season;
        const seasonB = grouped[b].season;
        
        if (!seasonA || !seasonB) return 0;
        
        const dateA = new Date(seasonA.start_date);
        const dateB = new Date(seasonB.start_date);
        
        return dateB - dateA; // Most recent first
      })
      .forEach(key => {
        sortedGroups[key] = grouped[key];
      });
    
    return sortedGroups;
  },

  // Get season statistics
  getSeasonStats: async (seasonId) => {
    try {
      const { data: challenges, error: challengesError } = await supabase
        .from('challenges')
        .select(`
          id,
          participant_count,
          playlists (
            id,
            scores (
              id
            )
          )
        `)
        .eq('season_id', seasonId);

      if (challengesError) throw challengesError;

      const totalChallenges = challenges.length;
      const totalParticipants = challenges.reduce((sum, c) => sum + (c.participant_count || 0), 0);
      const totalScores = challenges.reduce((sum, c) => {
        return sum + c.playlists.reduce((playlistSum, p) => playlistSum + p.scores.length, 0);
      }, 0);

      return {
        totalChallenges,
        totalParticipants,
        totalScores,
        avgParticipantsPerChallenge: totalChallenges > 0 ? Math.round(totalParticipants / totalChallenges) : 0
      };
    } catch (error) {
      console.error('Error getting season stats:', error);
      return {
        totalChallenges: 0,
        totalParticipants: 0,
        totalScores: 0,
        avgParticipantsPerChallenge: 0
      };
    }
  },

  // Validate season dates
  validateSeasonDates: (startDate, endDate) => {
    const start = new Date(startDate);
    const end = new Date(endDate);

    const errors = [];

    if (isNaN(start.getTime())) {
      errors.push('Invalid start date');
    }

    if (isNaN(end.getTime())) {
      errors.push('Invalid end date');
    }

    if (start >= end) {
      errors.push('Start date must be before end date');
    }

    // Check if dates align with 6-month seasons
    const startMonth = start.getMonth() + 1;
    const endMonth = end.getMonth() + 1;
    const startDay = start.getDate();
    const endDay = end.getDate();

    if (!((startMonth === 1 && startDay === 1) || (startMonth === 7 && startDay === 1))) {
      errors.push('Season should start on January 1st or July 1st');
    }

    if (!((endMonth === 6 && endDay === 30) || (endMonth === 12 && endDay === 31))) {
      errors.push('Season should end on June 30th or December 31st');
    }

    return errors;
  },

  // Create a new season programmatically
  createSeason: async (year, half, customName = null) => {
    try {
      let seasonName;
      
      if (customName) {
        seasonName = customName;
      } else {
        // Generate next incremental name
        seasonName = await seasonUtils.generateSeasonName();
      }
      
      const dateRange = seasonUtils.getSeasonDateRange(year, half);

      const { data: season, error } = await supabase
        .from('seasons')
        .insert({
          name: seasonName,
          start_date: dateRange.start_date,
          end_date: dateRange.end_date,
          is_current: false,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .select()
        .single();

      if (error) throw error;

      return season;
    } catch (error) {
      console.error('Error creating season:', error);
      return null;
    }
  },

  getSeasonNumber: (seasonName) => {
    if (!seasonName) return null;
    const match = seasonName.match(/^Season (\d+)$/);
    return match ? parseInt(match[1]) : null;
  },

  // Get next season info
  getNextSeasonInfo: async (currentSeason) => {
    if (!currentSeason) return null;

    const currentStart = new Date(currentSeason.start_date);
    const currentYear = currentStart.getFullYear();
    const currentMonth = currentStart.getMonth() + 1;

    let nextYear, nextHalf;
    
    if (currentMonth <= 6) {
      // Current is first half, next is second half same year
      nextYear = currentYear;
      nextHalf = 2;
    } else {
      // Current is second half, next is first half next year
      nextYear = currentYear + 1;
      nextHalf = 1;
    }

    const nextSeasonName = await seasonUtils.generateSeasonName();
    const nextDateRange = seasonUtils.getSeasonDateRange(nextYear, nextHalf);

    return {
      year: nextYear,
      half: nextHalf,
      name: nextSeasonName,
      number: seasonUtils.getSeasonNumber(nextSeasonName),
      ...nextDateRange
    };
  },
  
  // Check if it's time to create next season (30 days before current ends)
  shouldCreateNextSeason: (currentSeason) => {
    if (!currentSeason) return false;

    const now = new Date();
    const seasonEnd = new Date(currentSeason.end_date);
    const thirtyDaysBeforeEnd = new Date(seasonEnd.getTime() - (30 * 24 * 60 * 60 * 1000));

    return now >= thirtyDaysBeforeEnd;
  }
};


================================================
FILE: frontend/lib/secure-auth.js
================================================
import crypto from 'crypto';
import { supabaseAdmin } from './supabase-admin';

const SESSION_SECRET = process.env.SESSION_SECRET;
if (!SESSION_SECRET || SESSION_SECRET.length < 32) {
  throw new Error('SESSION_SECRET must be set and at least 32 characters');
}
const SESSION_EXPIRY = 30 * 24 * 60 * 60 * 1000; // 30 days

// Get real user IP, accounting for Cloudflare proxy
function getRealIP(req) {
  // Cloudflare provides the real user IP in CF-Connecting-IP header
  return req.headers['cf-connecting-ip'] ||           // Cloudflare real IP
         req.headers['x-real-ip'] ||                  // Other proxies  
         req.headers['x-forwarded-for']?.split(',')[0]?.trim() || 
         req.connection.remoteAddress;
}

// Generate cryptographically secure session token
export function generateSessionToken(userId, userAgent = '', req = null) {
  const timestamp = Date.now();
  const random = crypto.randomBytes(32).toString('hex');
  
  // Get real IP address
  const ipAddress = req ? getRealIP(req) : '';
  
  // Create payload with user info and metadata
  const payload = {
    userId,
    timestamp,
    random,
    userAgent: userAgent.substring(0, 100), // Limit length
    ipAddress: ipAddress,
    expiresAt: timestamp + SESSION_EXPIRY
  };
  
  // Create signature
  const data = JSON.stringify(payload);
  const signature = crypto
    .createHmac('sha256', SESSION_SECRET)
    .update(data)
    .digest('hex');
  
  // Combine payload and signature
  const token = Buffer.from(JSON.stringify({ data: payload, signature })).toString('base64');
  
  return { token, expiresAt: payload.expiresAt };
}

// Verify and decode session token
export function verifySessionToken(token, userAgent = '', req = null) {
  try {
    if (!token) return null;
    
    // Decode token
    const decoded = JSON.parse(Buffer.from(token, 'base64').toString());
    const { data: payload, signature } = decoded;
    
    if (!payload || !signature) return null;
    
    // Verify signature
    const expectedSignature = crypto
      .createHmac('sha256', SESSION_SECRET)
      .update(JSON.stringify(payload))
      .digest('hex');
    
    if (signature !== expectedSignature) {
      console.warn('üîí Invalid session signature');
      return null;
    }
    
    // Check expiration
    if (Date.now() > payload.expiresAt) {
      console.warn('üîí Session expired');
      return null;
    }
    
    return {
      userId: payload.userId,
      createdAt: payload.timestamp,
      expiresAt: payload.expiresAt,
      isValid: true
    };
    
  } catch (error) {
    console.error('üîí Session verification error:', error);
    return null;
  }
}

// Enhanced middleware with proper session management
export function withSecureAuth(handler, options = {}) {
  return async (req, res) => {
    const { requireAdmin = false, optional = false } = options;
    
    try {
      // Get session token from cookie
      const sessionToken = req.cookies.osu_session;
      
      if (!sessionToken) {
        if (optional) {
          return handler(req, res);
        }
        return res.status(401).json({
          success: false,
          error: {
            message: 'No authentication session found',
            code: 'NO_SESSION'
          }
        });
      }
      
      // Verify session token with full request object
      const session = verifySessionToken(
        sessionToken, 
        req.headers['user-agent'], 
        req  // Pass full request object for proper IP extraction
      );
      
      if (!session) {
        if (optional) {
          return handler(req, res);
        }
        
        // Clear invalid session cookie
        res.setHeader('Set-Cookie', [
          'osu_session=; Path=/; HttpOnly; SameSite=Lax; Max-Age=0'
        ]);
        
        return res.status(401).json({
          success: false,
          error: {
            message: 'Invalid or expired session',
            code: 'INVALID_SESSION'
          }
        });
      }
      
      // Get user from database
      const { data: user, error } = await supabaseAdmin
        .from('users')
        .select('*, admin')
        .eq('id', session.userId)
        .single();
      
      if (error || !user) {
        if (optional) {
          return handler(req, res);
        }
        
        return res.status(401).json({
          success: false,
          error: {
            message: 'User not found',
            code: 'USER_NOT_FOUND'
          }
        });
      }
      
      // Check if user is active
      if (user.status === 'inactive' || user.banned_at) {
        return res.status(403).json({
          success: false,
          error: {
            message: 'User account is inactive or banned',
            code: 'USER_INACTIVE'
          }
        });
      }
      
      // Check admin requirement
      if (requireAdmin && !user.admin) {
        return res.status(403).json({
          success: false,
          error: {
            message: 'Admin access required',
            code: 'ADMIN_REQUIRED'
          }
        });
      }
      
      // Add user and session info to request
      req.user = user;
      req.session = session;
      
      // Refresh session if it's more than halfway to expiry
      const timeUntilExpiry = session.expiresAt - Date.now();
      const halfSessionLife = SESSION_EXPIRY / 2;
      
      if (timeUntilExpiry < halfSessionLife) {
        console.log(`üîÑ Refreshing session for user ${user.id}`);
        
        const { token: newToken, expiresAt } = generateSessionToken(
          user.id,
          req.headers['user-agent'],
          req  // Pass full request object
        );
        
        // Set new session cookie
        const isProduction = process.env.NODE_ENV === 'production';
        const sessionCookieOptions = [
          `osu_session=${newToken}`,
          'Path=/',
          'HttpOnly',
          'SameSite=Lax',
          `Max-Age=${Math.floor(SESSION_EXPIRY / 1000)}`,
          ...(isProduction ? ['Secure'] : [])
        ].join('; ');
        
        res.setHeader('Set-Cookie', sessionCookieOptions);
      }
      
      return handler(req, res);
      
    } catch (error) {
      console.error('üîí Secure auth middleware error:', error);
      
      if (optional) {
        return handler(req, res);
      }
      
      return res.status(500).json({
        success: false,
        error: {
          message: 'Authentication verification failed',
          code: 'AUTH_ERROR'
        }
      });
    }
  };
}

// Updated auth callback with secure sessions
export async function handleSecureAuthCallback(req, res) {
  const { code, state } = req.query;
  
  console.log('üîë === SECURE AUTH CALLBACK START ===');
  console.log('üìç URL:', req.url);
  console.log('üîë Code present:', !!code);
  console.log('üé≤ State received:', state);
  console.log('üåê Real IP:', getRealIP(req));
  
  // Verify state parameter
  const cookieHeader = req.headers.cookie || '';
  const cookies = cookieHeader.split('; ');
  const stateCookie = cookies.find(c => c.startsWith('osu_auth_state='));
  
  if (!stateCookie) {
    console.log('‚ùå State cookie not found');
    return res.status(400).json({ 
      error: 'Invalid state parameter',
      details: 'State cookie not found'
    });
  }
  
  const savedState = stateCookie.split('=')[1];
  
  if (savedState !== state) {
    console.log('‚ùå State mismatch');
    return res.status(400).json({ 
      error: 'Invalid state parameter',
      details: 'State values do not match'
    });
  }
  
  console.log('‚úÖ State verification PASSED');
  
  // Clear state cookie
  const isProduction = process.env.NODE_ENV === 'production';
  const clearStateCookie = [
    'osu_auth_state=',
    'Path=/',
    'HttpOnly',
    'SameSite=Lax',
    'Max-Age=0',
    ...(isProduction ? ['Secure'] : [])
  ].join('; ');
  
  try {
    console.log('üîÑ Exchanging code for access token...');
    
    // Exchange code for access token
    const tokenResponse = await fetch('https://osu.ppy.sh/oauth/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        client_id: process.env.OSU_CLIENT_ID,
        client_secret: process.env.OSU_CLIENT_SECRET,
        code,
        grant_type: 'authorization_code',
        redirect_uri: process.env.OSU_REDIRECT_URI,
      }),
    });
    
    if (!tokenResponse.ok) {
      const errorText = await tokenResponse.text();
      console.error('‚ùå Token exchange failed:', tokenResponse.status, errorText);
      throw new Error(`Failed to exchange code for token: ${tokenResponse.status}`);
    }
    
    const { access_token } = await tokenResponse.json();
    console.log('‚úÖ Access token received');
    
    // Get user info from osu! API
    console.log('üë§ Fetching user info from osu! API...');
    const userResponse = await fetch('https://osu.ppy.sh/api/v2/me', {
      headers: {
        'Authorization': `Bearer ${access_token}`,
      },
    });
    
    if (!userResponse.ok) {
      console.error('‚ùå User info fetch failed:', userResponse.status);
      throw new Error('Failed to fetch user info');
    }
    
    const osuUser = await userResponse.json();
    console.log('üë§ osu! user data:', { 
      id: osuUser.id, 
      username: osuUser.username, 
      country: osuUser.country_code 
    });
    
    // Save user to database
    console.log('üíæ Upserting user in database...');
    const { data: dbUser, error: dbError } = await supabaseAdmin
      .from('users')
      .upsert({
        osu_id: osuUser.id,
        username: osuUser.username,
        avatar_url: osuUser.avatar_url,
        country: osuUser.country_code,
        global_rank: osuUser.statistics?.global_rank,
        country_rank: osuUser.statistics?.country_rank,
        pp: osuUser.statistics?.pp,
        updated_at: new Date().toISOString()
      }, {
        onConflict: 'osu_id',
        ignoreDuplicates: false
      })
      .select()
      .single();
    
    if (dbError) {
      console.error('‚ùå Database error:', dbError);
      throw new Error('Failed to save user data');
    }
    
    console.log('‚úÖ User saved to database:', { 
      id: dbUser.id, 
      username: dbUser.username,
      admin: dbUser.admin 
    });
    
    // Generate secure session token with real IP
    const { token: sessionToken } = generateSessionToken(
      dbUser.id,
      req.headers['user-agent'],
      req  // Pass full request object for proper IP extraction
    );
    
    // Set secure session cookie
    const sessionCookieOptions = [
      `osu_session=${sessionToken}`,
      'Path=/',
      'HttpOnly',
      'SameSite=Lax',
      `Max-Age=${Math.floor(SESSION_EXPIRY / 1000)}`,
      ...(isProduction ? ['Secure'] : [])
    ].join('; ');
    
    console.log('üç™ Setting secure session cookie');
    
    // Set both cookies in response
    res.setHeader('Set-Cookie', [clearStateCookie, sessionCookieOptions]);
    
    // Redirect to profile page
    console.log('‚Ü©Ô∏è Redirecting to profile...');
    res.redirect(`/profile/${dbUser.id}`);
    
  } catch (error) {
    console.error('üö® Secure auth callback error:', error);
    res.redirect(`/?error=auth_failed&details=${encodeURIComponent(error.message)}`);
  }
}

// Utility functions for use in other parts of the app
export function withOptionalAuth(handler) {
  return withSecureAuth(handler, { optional: true });
}

export function withAdminAuth(handler) {
  return withSecureAuth(handler, { requireAdmin: true });
}

// Session management utilities
export async function invalidateSession(userId) {
  // In a production app, you might want to maintain a blacklist of invalidated sessions
  // For now, we rely on the cryptographic verification
  console.log(`üîí Session invalidated for user ${userId}`);
}

export async function invalidateAllUserSessions(userId) {
  // This would be used for security incidents or password changes
  console.log(`üîí All sessions invalidated for user ${userId}`);
}

// Security monitoring
export function logSecurityEvent(type, details, req) {
  console.warn(`üö® SECURITY EVENT: ${type}`, {
    timestamp: new Date().toISOString(),
    type,
    details,
    ip: getRealIP(req),
    cloudflareIP: req.headers['x-forwarded-for']?.split(',')[0]?.trim(),
    userAgent: req.headers['user-agent']?.substring(0, 100),
    url: req.url
  });
}

// Export the IP utility for use in other files
export { getRealIP };


================================================
FILE: frontend/lib/security.js
================================================
// Security configuration and utilities

import crypto from 'crypto';
import { rateLimit } from 'express-rate-limit';

// Content Security Policy configuration
export const CSP_CONFIG = {
  'default-src': ["'self'"],
  'script-src': [
    "'self'",
    "'unsafe-eval'", // Next.js requires this
    'https://vercel.live',
    'https://www.googletagmanager.com',
    'https://www.google-analytics.com'
  ],
  'style-src': [
    "'self'",
    "'unsafe-inline'", // Tailwind requires this
    'https://fonts.googleapis.com'
  ],
  'img-src': [
    "'self'",
    'data:',
    'blob:',
    'https:',
    'https://a.ppy.sh', // osu! avatars
    'https://assets.ppy.sh', // osu! assets
    'https://vercel.com'
  ],
  'font-src': [
    "'self'",
    'https://fonts.gstatic.com'
  ],
  'connect-src': [
    "'self'",
    'https://osu.ppy.sh', // osu! API
    'https://*.supabase.co', // Supabase
    'https://vercel.live',
    'wss://*.supabase.co' // Supabase realtime
  ],
  'frame-src': [
    "'self'",
    'https://vercel.live'
  ],
  'object-src': ["'none'"],
  'base-uri': ["'self'"],
  'form-action': ["'self'"],
  'frame-ancestors': ["'none'"],
  'upgrade-insecure-requests': []
};

// Generate CSP header string
export function generateCSPHeader(config = CSP_CONFIG) {
  return Object.entries(config)
    .map(([directive, sources]) => {
      if (sources.length === 0) return directive;
      return `${directive} ${sources.join(' ')}`;
    })
    .join('; ');
}

// Security headers middleware
export function setSecurityHeaders(req, res, next) {
  const isProduction = process.env.NODE_ENV === 'production';
  
  // Content Security Policy
  res.setHeader('Content-Security-Policy', generateCSPHeader());
  
  // Prevent MIME type sniffing
  res.setHeader('X-Content-Type-Options', 'nosniff');
  
  // Prevent clickjacking
  res.setHeader('X-Frame-Options', 'DENY');
  
  // XSS Protection
  res.setHeader('X-XSS-Protection', '1; mode=block');
  
  // Referrer Policy
  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
  
  // Permissions Policy
  res.setHeader('Permissions-Policy', 
    'camera=(), microphone=(), geolocation=(), payment=(), usb=()'
  );
  
  if (isProduction) {
    // HSTS - only in production with HTTPS
    const hstsMaxAge = process.env.HSTS_MAX_AGE || '31536000'; // 1 year
    res.setHeader('Strict-Transport-Security', 
      `max-age=${hstsMaxAge}; includeSubDomains; preload`
    );
    
    // Prevent caching of sensitive pages
    if (req.url.includes('/api/') || req.url.includes('/admin')) {
      res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
      res.setHeader('Pragma', 'no-cache');
      res.setHeader('Expires', '0');
    }
  }
  
  if (next) next();
}

// Input sanitization functions
export const sanitize = {
  // Remove potentially dangerous HTML tags and attributes
  html: (input) => {
    if (typeof input !== 'string') return '';
    
    return input
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      .replace(/<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi, '')
      .replace(/<object\b[^<]*(?:(?!<\/object>)<[^<]*)*<\/object>/gi, '')
      .replace(/<embed\b[^<]*(?:(?!<\/embed>)<[^<]*)*<\/embed>/gi, '')
      .replace(/<link\b[^<]*>/gi, '')
      .replace(/<meta\b[^<]*>/gi, '')
      .replace(/on\w+\s*=/gi, '') // Remove event handlers
      .replace(/javascript:/gi, '')
      .replace(/data:text\/html/gi, '')
      .trim();
  },
  
  // Sanitize for SQL-like queries (basic protection)
  sql: (input) => {
    if (typeof input !== 'string') return '';
    
    return input
      .replace(/['"`;\\]/g, '')
      .replace(/\b(DROP|DELETE|INSERT|UPDATE|CREATE|ALTER|EXEC|EXECUTE)\b/gi, '')
      .trim();
  },
  
  // Sanitize filename
  filename: (input) => {
    if (typeof input !== 'string') return '';
    
    return input
      .replace(/[<>:"/\\|?*\x00-\x1f]/g, '') // Remove invalid filename chars
      .replace(/^\.+/, '') // Remove leading dots
      .replace(/\.+$/, '') // Remove trailing dots
      .substring(0, 255) // Limit length
      .trim();
  },
  
  // Sanitize URL
  url: (input) => {
    if (typeof input !== 'string') return '';
    
    try {
      const url = new URL(input);
      // Only allow specific protocols
      if (!['http:', 'https:'].includes(url.protocol)) {
        return '';
      }
      return url.toString();
    } catch {
      return '';
    }
  },
  
  // Sanitize email
  email: (input) => {
    if (typeof input !== 'string') return '';
    
    const email = input.toLowerCase().trim();
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    
    if (!emailRegex.test(email) || email.length > 254) {
      return '';
    }
    
    return email;
  }
};

// Password security utilities
export const password = {
  // Check password strength
  checkStrength: (password) => {
    if (typeof password !== 'string') return { score: 0, feedback: ['Invalid password'] };
    
    const checks = {
      length: password.length >= 8,
      lowercase: /[a-z]/.test(password),
      uppercase: /[A-Z]/.test(password),
      numbers: /\d/.test(password),
      symbols: /[!@#$%^&*(),.?":{}|<>]/.test(password),
      notCommon: !isCommonPassword(password)
    };
    
    const score = Object.values(checks).filter(Boolean).length;
    const feedback = [];
    
    if (!checks.length) feedback.push('Password must be at least 8 characters long');
    if (!checks.lowercase) feedback.push('Add lowercase letters');
    if (!checks.uppercase) feedback.push('Add uppercase letters');
    if (!checks.numbers) feedback.push('Add numbers');
    if (!checks.symbols) feedback.push('Add symbols');
    if (!checks.notCommon) feedback.push('Avoid common passwords');
    
    return { score, feedback, checks };
  },
  
  // Generate secure random password
  generate: (length = 16) => {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*';
    let password = '';
    
    for (let i = 0; i < length; i++) {
      password += chars.charAt(crypto.randomInt(0, chars.length));
    }
    
    return password;
  }
};

// Common password list (subset)
const commonPasswords = new Set([
  'password', '123456', '123456789', 'qwerty', 'abc123', 'password123',
  'admin', 'letmein', 'welcome', 'monkey', '1234567890', 'iloveyou'
]);

function isCommonPassword(password) {
  return commonPasswords.has(password.toLowerCase());
}

// CSRF protection utilities
export const csrf = {
  // Generate CSRF token
  generateToken: () => {
    return crypto.randomBytes(32).toString('hex');
  },
  
  // Verify CSRF token
  verifyToken: (sessionToken, requestToken) => {
    if (!sessionToken || !requestToken) return false;
    return crypto.timingSafeEqual(
      Buffer.from(sessionToken, 'hex'),
      Buffer.from(requestToken, 'hex')
    );
  },
  
  // Middleware for CSRF protection
  middleware: (req, res, next) => {
    if (req.method === 'GET') {
      // Generate token for GET requests
      if (!req.session.csrfToken) {
        req.session.csrfToken = csrf.generateToken();
      }
      return next();
    }
    
    // Verify token for state-changing requests
    const token = req.headers['x-csrf-token'] || req.body._csrf;
    
    if (!csrf.verifyToken(req.session.csrfToken, token)) {
      return res.status(403).json({
        success: false,
        error: { message: 'Invalid CSRF token', code: 'CSRF_ERROR' }
      });
    }
    
    next();
  }
};

// Rate limiting configurations
export const rateLimiters = {
  // General API rate limiting
  api: rateLimit({
    windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 60000, // 1 minute
    max: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS) || 100,
    message: {
      success: false,
      error: { message: 'Too many requests', code: 'RATE_LIMIT_EXCEEDED' }
    },
    standardHeaders: true,
    legacyHeaders: false,
    skip: (req) => {
      // Skip rate limiting for admin users (optional)
      return req.user?.is_admin === true;
    }
  }),
  
  // Stricter rate limiting for auth endpoints
  auth: rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 5, // 5 attempts per window
    message: {
      success: false,
      error: { message: 'Too many authentication attempts', code: 'AUTH_RATE_LIMIT' }
    },
    standardHeaders: true,
    legacyHeaders: false
  }),
  
  // Very strict rate limiting for password reset
  passwordReset: rateLimit({
    windowMs: 60 * 60 * 1000, // 1 hour
    max: 3, // 3 attempts per hour
    message: {
      success: false,
      error: { message: 'Too many password reset attempts', code: 'PASSWORD_RESET_LIMIT' }
    }
  })
};

// Secure session configuration
export const sessionConfig = {
  name: process.env.SESSION_NAME || 'osu_tracker_session',
  secret: process.env.SESSION_SECRET || 'your-super-secret-session-key',
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: process.env.NODE_ENV === 'production', // HTTPS only in production
    httpOnly: true, // Prevent XSS
    maxAge: parseInt(process.env.SESSION_MAX_AGE) || 7 * 24 * 60 * 60 * 1000, // 7 days
    sameSite: process.env.SESSION_SAME_SITE || 'lax' // CSRF protection
  },
  rolling: true // Reset expiry on activity
};

// Data validation schemas
export const validationSchemas = {
  // User input validation
  username: {
    type: 'string',
    minLength: 3,
    maxLength: 15,
    pattern: /^[a-zA-Z0-9_-]+$/,
    required: true
  },
  
  email: {
    type: 'string',
    pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
    maxLength: 254,
    required: true
  },
  
  password: {
    type: 'string',
    minLength: 8,
    maxLength: 128,
    required: true
  },
  
  osuUserId: {
    type: 'number',
    min: 1,
    max: 99999999,
    required: true
  },
  
  challengeName: {
    type: 'string',
    minLength: 3,
    maxLength: 100,
    required: true
  },
  
  challengeDescription: {
    type: 'string',
    maxLength: 1000,
    required: false
  }
};

// Security audit logger
export function logSecurityEvent(event, details = {}) {
  const logEntry = {
    timestamp: new Date().toISOString(),
    event,
    details,
    ip: details.ip || 'unknown',
    userAgent: details.userAgent || 'unknown',
    userId: details.userId || null
  };
  
  console.warn('SECURITY EVENT:', JSON.stringify(logEntry));
  
  // In production, send to security monitoring service
  if (process.env.NODE_ENV === 'production') {
    // Send to security monitoring service
  }
}

// Middleware to log suspicious activity
export function securityLogger(req, res, next) {
  const suspiciousPatterns = [
    /\.\./,  // Path traversal
    /<script/i,  // XSS attempts
    /union.*select/i,  // SQL injection
    /javascript:/i,  // JavaScript injection
    /eval\(/i,  // Code injection
  ];
  
  const fullUrl = req.url + JSON.stringify(req.body || {});
  
  for (const pattern of suspiciousPatterns) {
    if (pattern.test(fullUrl)) {
      logSecurityEvent('suspicious_request', {
        pattern: pattern.toString(),
        url: req.url,
        method: req.method,
        ip: req.ip || req.connection.remoteAddress,
        userAgent: req.headers['user-agent'],
        body: req.body
      });
      break;
    }
  }
  
  next();
}

// Export middleware setup function
export function setupSecurity(app) {
  // Apply security headers
  app.use(setSecurityHeaders);
  
  // Apply security logging
  app.use(securityLogger);
  
  // Apply rate limiting
  app.use('/api/', rateLimiters.api);
  app.use('/api/auth/', rateLimiters.auth);
  app.use('/api/auth/reset-password', rateLimiters.passwordReset);
}

export default {
  CSP_CONFIG,
  generateCSPHeader,
  setSecurityHeaders,
  sanitize,
  password,
  csrf,
  rateLimiters,
  sessionConfig,
  validationSchemas,
  logSecurityEvent,
  securityLogger,
  setupSecurity
};


================================================
FILE: frontend/lib/SettingsContext.js
================================================
import React, { createContext, useContext, useState, useEffect, useMemo, useCallback } from 'react';
import { useAuth } from './AuthContext';

const SettingsContext = createContext();

const STORAGE_KEY = 'user_settings_cache';
const CACHE_VERSION = 1;

export const useSettings = () => {
  const context = useContext(SettingsContext);
  if (!context) {
    throw new Error('useSettings must be used within a SettingsProvider');
  }
  return context;
};

// Helper functions for local storage
const getCachedSettings = (userId) => {
  if (typeof window === 'undefined') return null;
  
  try {
    const cached = localStorage.getItem(`${STORAGE_KEY}_${userId}`);
    if (!cached) return null;
    
    const parsed = JSON.parse(cached);
    
    if (parsed.version !== CACHE_VERSION || 
        Date.now() - parsed.timestamp > 24 * 60 * 60 * 1000) {
      localStorage.removeItem(`${STORAGE_KEY}_${userId}`);
      return null;
    }
    
    return parsed.data;
  } catch (error) {
    console.error('Error reading cached settings:', error);
    return null;
  }
};

const setCachedSettings = (userId, data) => {
  if (typeof window === 'undefined') return;
  
  try {
    const cacheData = {
      version: CACHE_VERSION,
      timestamp: Date.now(),
      data: {
        ...data,
        timestamp: Date.now()
      }
    };
    localStorage.setItem(`${STORAGE_KEY}_${userId}`, JSON.stringify(cacheData));
  } catch (error) {
    console.error('Error caching settings:', error);
  }
};

const clearCachedSettings = (userId) => {
  if (typeof window === 'undefined') return;
  try {
    localStorage.removeItem(`${STORAGE_KEY}_${userId}`);
  } catch (error) {
    console.error('Error clearing cached settings:', error);
  }
};

export const SettingsProvider = ({ children }) => {
  const { user } = useAuth();
  const [settings, setSettings] = useState(null);
  const [tempSettings, setTempSettings] = useState(null);
  const [donorStatus, setDonorStatus] = useState(null);
  const [availableBackgrounds, setAvailableBackgrounds] = useState([]);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [isFromCache, setIsFromCache] = useState(false);

  useEffect(() => {
    if (user) {
      const cached = getCachedSettings(user.id);
      if (cached) {
        console.log('‚úÖ Loaded settings from cache');
        setSettings(cached.settings);
        setDonorStatus(cached.donorStatus);
        setAvailableBackgrounds(cached.availableBackgrounds || []);
        setIsFromCache(true);
        setLoading(false);
        
        const cacheAge = Date.now() - (cached.timestamp || 0);
        if (cacheAge > 5 * 60 * 1000) {
          fetchSettings();
        }
      } else {
        fetchSettings();
      }
    } else {
      setSettings(null);
      setTempSettings(null);
      setDonorStatus(null);
      setAvailableBackgrounds([]);
      setLoading(false);
      setIsFromCache(false);
    }
  }, [user?.id]);

  const fetchSettings = useCallback(async () => {
    if (!user) return;

    try {
      if (!isFromCache) {
        setLoading(true);
      }
      
      const response = await fetch('/api/settings', {
        method: 'GET',
        credentials: 'include',
        headers: {
          'Cache-Control': 'no-cache'
        }
      });

      if (!response.ok) {
        throw new Error(`Failed to fetch settings: ${response.status}`);
      }

      const data = await response.json();
      const responseData = data.data || data;
      
      setSettings(responseData.settings);
      setDonorStatus(responseData.donorStatus);
      setAvailableBackgrounds(responseData.availableBackgrounds || []);
      
      setCachedSettings(user.id, {
        settings: responseData.settings,
        donorStatus: responseData.donorStatus,
        availableBackgrounds: responseData.availableBackgrounds || []
      });
      
      console.log('‚úÖ Settings updated from API');
    } catch (error) {
      console.error('Error fetching settings:', error);
      if (!isFromCache) {
        console.error('Failed to load settings and no cache available');
      }
    } finally {
      setLoading(false);
    }
  }, [user, isFromCache]);

  const updateSettings = async (newSettings, isPreview = false) => {
    if (!user) {
      return { success: false, error: 'User not authenticated' };
    }

    if (isPreview) {
      const newTempSettings = {
        ...settings,
        ...tempSettings,
        ...newSettings
      };
      setTempSettings(newTempSettings);
      return { success: true };
    }

    try {
      setSaving(true);
      
      const requestBody = { settings: newSettings };
      
      const response = await fetch('/api/settings', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify(requestBody)
      });

      const data = await response.json();

      if (!response.ok) {
        return { success: false, error: data.error?.message || 'Failed to update settings' };
      }

      const responseData = data.data || data;
      
      setSettings(responseData.settings);
      setTempSettings(null);
      
      setCachedSettings(user.id, {
        settings: responseData.settings,
        donorStatus,
        availableBackgrounds
      });
      
      return { success: true, settings: responseData.settings };
    } catch (error) {
      console.error('Error saving settings:', error);
      return { success: false, error: error.message };
    } finally {
      setSaving(false);
    }
  };

  const cancelPreview = () => {
    setTempSettings(null);
  };

  const resetSettings = async (category = 'all') => {
    if (!user) return { success: false, error: 'User not authenticated' };

    const defaultSettings = getDefaultSettings();
    let settingsToReset = {};

    switch (category) {
      case 'appearance':
        settingsToReset = {
          background_type: defaultSettings.background_type,
          background_gradient_type: defaultSettings.background_gradient_type,
          background_gradient_angle: defaultSettings.background_gradient_angle,
          background_color: defaultSettings.background_color,
          background_gradient_end: defaultSettings.background_gradient_end,
          background_blur: defaultSettings.background_blur,
          background_dimming: defaultSettings.background_dimming,
          background_saturation: defaultSettings.background_saturation,
          background_id: null
        };
        break;
      case 'privacy':
        settingsToReset = {
          profile_visibility: defaultSettings.profile_visibility
        };
        break;
      default:
        settingsToReset = defaultSettings;
    }

    const result = await updateSettings(settingsToReset);
    
    if (result.success) {
      clearCachedSettings(user.id);
    }
    
    return result;
  };

  const getDefaultSettings = () => ({
    background_type: 'gradient',
    background_gradient_type: 'linear',
    background_gradient_angle: 135,
    background_color: '#FF5714',
    background_gradient_end: '#1056F9',
    background_blur: 50,
    background_dimming: 50,
    background_saturation: 0,
    animations_enabled: true,
    number_format: 'abbreviated',
    default_profile_tab: 'recent',
    profile_visibility: 'public',
    background_id: null,
    donor_effects: {}
  });

  const activeSettings = tempSettings || settings || getDefaultSettings();

  // Generate gradient CSS based on type
  const generateGradientCSS = useCallback((type, angle, startColor, endColor) => {
    switch (type) {
      case 'linear':
        return `linear-gradient(${angle}deg, ${startColor} 0%, ${endColor} 100%)`;
      case 'radial':
        return `radial-gradient(circle at center, ${startColor} 0%, ${endColor} 100%)`;
      case 'conic':
        return `conic-gradient(from 0deg at center, ${startColor} 0%, ${endColor} 50%, ${startColor} 100%)`;
      default:
        return `linear-gradient(135deg, ${startColor} 0%, ${endColor} 100%)`;
    }
  }, []);

  const backgroundStyle = useMemo(() => {

    if (activeSettings.background_id) {
      const selectedBackground = availableBackgrounds.find(bg => bg.id === activeSettings.background_id);
      if (selectedBackground) {
        return {
          backgroundImage: `url(${selectedBackground.image_url})`,
          backgroundSize: 'cover',
          backgroundPosition: 'center',
          filter: `
            blur(${activeSettings.background_blur || 0}px)
            brightness(${100 - (activeSettings.background_dimming || 0)}%)
            saturate(${100 + (activeSettings.background_saturation || 0)}%)
          `.trim()
        };
      }
    }

    if (activeSettings.background_type === 'gradient') {
      const gradientType = activeSettings.background_gradient_type || 'linear';
      const gradientAngle = activeSettings.background_gradient_angle || 135;
      
      return {
        background: generateGradientCSS(
          gradientType,
          gradientAngle,
          activeSettings.background_color,
          activeSettings.background_gradient_end
        ),
        filter: `
          blur(${activeSettings.background_blur || 0}px)
          brightness(${100 - (activeSettings.background_dimming || 0)}%)
          saturate(${100 + (activeSettings.background_saturation || 0)}%)
        `.trim()
      };
    } else {
      return {
        backgroundColor: activeSettings.background_color,
        filter: `
          blur(${activeSettings.background_blur || 0}px)
          brightness(${100 - (activeSettings.background_dimming || 0)}%)
          saturate(${100 + (activeSettings.background_saturation || 0)}%)
        `.trim()
      };
    }
  }, [
    activeSettings.background_id,
    activeSettings.background_type,
    activeSettings.background_gradient_type,
    activeSettings.background_gradient_angle,
    activeSettings.background_color,
    activeSettings.background_gradient_end,
    activeSettings.background_blur,
    activeSettings.background_dimming,
    activeSettings.background_saturation,
    availableBackgrounds,
    generateGradientCSS
  ]);

  const getBackgroundStyle = useCallback(() => backgroundStyle, [backgroundStyle]);

  const value = {
    settings: activeSettings,
    tempSettings,
    donorStatus,
    availableBackgrounds,
    loading,
    saving,
    isFromCache,
    backgroundStyle,
    updateSettings,
    cancelPreview,
    resetSettings,
    fetchSettings,
    getBackgroundStyle
  };

  return (
    <SettingsContext.Provider value={value}>
      {children}
    </SettingsContext.Provider>
  );
};


================================================
FILE: frontend/lib/stripe.js
================================================
import Stripe from 'stripe';

// Server-side Stripe instance
let stripe = null;

if (process.env.STRIPE_SECRET_KEY) {
  stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
    apiVersion: '2023-10-16',
  });
}

// Utility functions for common Stripe operations
export const stripeUtils = {
  // Create a customer
  createCustomer: async ({ email, userId, username }) => {
    if (!stripe) throw new Error('Stripe not configured');
    
    return await stripe.customers.create({
      email,
      metadata: {
        userId: userId || 'guest',
        username: username || 'Guest User'
      }
    });
  },

  // Create a payment intent
  createPaymentIntent: async ({ amount, currency = 'usd', customerId, metadata }) => {
    if (!stripe) throw new Error('Stripe not configured');
    
    return await stripe.paymentIntents.create({
      amount,
      currency,
      customer: customerId,
      metadata,
      automatic_payment_methods: {
        enabled: true,
      },
    });
  },

  // Create a subscription
  createSubscription: async ({ customerId, priceId, metadata }) => {
    if (!stripe) throw new Error('Stripe not configured');
    
    return await stripe.subscriptions.create({
      customer: customerId,
      items: [{ price: priceId }],
      payment_behavior: 'default_incomplete',
      expand: ['latest_invoice.payment_intent'],
      metadata
    });
  },

  // Cancel a subscription
  cancelSubscription: async (subscriptionId) => {
    if (!stripe) throw new Error('Stripe not configured');
    
    return await stripe.subscriptions.cancel(subscriptionId);
  },

  // List customer's subscriptions
  listSubscriptions: async (customerId) => {
    if (!stripe) throw new Error('Stripe not configured');
    
    return await stripe.subscriptions.list({
      customer: customerId,
      status: 'all',
      expand: ['data.default_payment_method']
    });
  },

  // Get payment methods
  getPaymentMethods: async (customerId) => {
    if (!stripe) throw new Error('Stripe not configured');
    
    return await stripe.paymentMethods.list({
      customer: customerId,
      type: 'card'
    });
  }
};

// Price IDs for different donation tiers (create these in Stripe Dashboard)
export const DONATION_PRICES = {
  oneTime: {
    coffee: 'price_coffee_onetime',      // $5
    pizza: 'price_pizza_onetime',        // $20
    supporter: 'price_supporter_onetime', // $50
    hero: 'price_hero_onetime'           // $100
  },
  recurring: {
    coffee: 'price_coffee_monthly',      // $5/month
    pizza: 'price_pizza_monthly',        // $20/month
    supporter: 'price_supporter_monthly', // $50/month
    hero: 'price_hero_monthly'           // $100/month
  }
};

export default stripe;


================================================
FILE: frontend/lib/supabase-admin.js
================================================
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const serviceRoleKey = process.env.SUPABASE_SERVICE_KEY;

if (!supabaseUrl || !serviceRoleKey) {
  console.error('Missing Supabase admin environment variables');
  console.error('SUPABASE_URL:', supabaseUrl ? 'Set' : 'Missing');
  console.error('SUPABASE_SERVICE_KEY:', serviceRoleKey ? 'Set' : 'Missing');
  throw new Error('Missing Supabase admin environment variables');
}

export const supabaseAdmin = createClient(supabaseUrl, serviceRoleKey, {
  auth: {
    persistSession: false,
    autoRefreshToken: false,
    detectSessionInUrl: false
  }
});


================================================
FILE: frontend/lib/supabase.js
================================================
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables');
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey);

// Import admin client for server-side operations
let supabaseAdmin = null;
if (typeof window === 'undefined') {
  // Only import on server side
  try {
    const { supabaseAdmin: admin } = require('./supabase-admin');
    supabaseAdmin = admin;
  } catch (error) {
    console.warn('Could not load admin client:', error.message);
  }
  console.log('admin loaded')
}

// Helper functions for common queries
export const challengeQueries = {
  // Get all active challenges with season information
  getActiveChallenges: async () => {
    const { data, error } = await supabase
      .from('challenges')
      .select(`
        *,
        seasons (
          id,
          name,
          start_date,
          end_date,
          is_current
        ),
        playlists (
          id,
          playlist_id,
          beatmap_title,
          beatmap_artist,
          beatmap_version,
          beatmap_difficulty,
          beatmap_cover_url,
          beatmap_card_url,
          beatmap_list_url,
          beatmap_slimcover_url
        )
      `)
      .eq('is_active', true)
      .order('created_at', { ascending: false });

    if (error) throw error;
    return data;
  },

  // Get challenges by season
  getChallengesBySeason: async (seasonId) => {
    const { data, error } = await supabase
      .from('challenges')
      .select(`
        *,
        seasons (
          id,
          name,
          start_date,
          end_date,
          is_current
        ),
        playlists (
          id,
          playlist_id,
          beatmap_title,
          beatmap_artist,
          beatmap_version,
          beatmap_difficulty,
          beatmap_cover_url,
          beatmap_card_url,
          beatmap_list_url,
          beatmap_slimcover_url
        )
      `)
      .eq('season_id', seasonId)
      .order('created_at', { ascending: false });

    if (error) throw error;
    return data;
  },

  // Get single challenge with all details
  getChallengeDetails: async (roomId) => {
    const { data, error } = await supabase
      .from('challenges')
      .select(`
        *,
        seasons (
          id,
          name,
          start_date,
          end_date,
          is_current
        ),
        playlists (
          *,
          scores (
            *,
            users (
              username,
              avatar_url,
              country
            )
          )
        )
      `)
      .eq('room_id', roomId)
      .single();

    if (error) throw error;
    
    // Sort scores for each playlist
    if (data?.playlists) {
      data.playlists = data.playlists.map(playlist => ({
        ...playlist,
        scores: playlist.scores?.sort((a, b) => b.score - a.score) || []
      }));
    }
    
    return data;
  },

  getChallengeLeaderboard: async (challengeId) => {
    const { data, error } = await supabase
      .rpc('get_challenge_leaderboard', { challenge_id: challengeId });

    if (error) throw error;
    return data || [];
  },

  // Get user scores
  getUserScores: async (userId) => {
    const { data, error } = await supabase
      .from('scores')
      .select(`
        *,
        playlists (
          *,
          challenges (
            name,
            custom_name,
            room_id,
            seasons (
              name
            )
          )
        )
      `)
      .eq('user_id', userId)
      .order('submitted_at', { ascending: false });

    if (error) throw error;
    return data;
  },

  // Get user streak data using the PostgreSQL function
getUserStreaks: async (userId) => {
  console.log('üî• getUserStreaks called with userId:', userId);
  
  try {
    const { data, error } = await supabase
      .rpc('get_user_streaks', { user_id_param: userId });

    if (error) {
      console.error('‚ùå Error calling get_user_streaks function:', error);
      throw error;
    }

    if (!data || data.length === 0) {
      console.log('üìà No streak data returned, returning zeros');
      return {
        currentStreak: 0,
        longestStreak: 0,
        lastParticipatedDate: null,
        totalChallengesParticipated: 0,
        totalChallengesAvailable: 0,
        missedChallenges: 0
      };
    }

    const streakData = data[0];
    console.log('üìà Streak data from PostgreSQL function:', streakData);

    return {
      currentStreak: streakData.current_streak || 0,
      longestStreak: streakData.longest_streak || 0,
      lastParticipatedDate: streakData.last_participated_date,
      totalChallengesParticipated: streakData.total_challenges_participated || 0,
      totalChallengesAvailable: streakData.total_challenges_available || 0,
      missedChallenges: streakData.missed_challenges || 0
    };

  } catch (error) {
    console.error('üö® Error in getUserStreaks:', error);
    // Return safe defaults on error
    return {
      currentStreak: 0,
      longestStreak: 0,
      lastParticipatedDate: null,
      totalChallengesParticipated: 0,
      totalChallengesAvailable: 0,
      missedChallenges: 0
    };
  }
},

getUserStats: async (userId) => {
  try {
    // Get comprehensive user statistics for the past 3 months only
    const { data: userStats, error: statsError } = await supabase
      .rpc('get_user_comprehensive_stats_3months', { user_id_param: userId });

    if (statsError) {
      console.error('Error fetching user stats (3 months):', statsError);
      throw statsError;
    }

    if (!userStats || userStats.length === 0) {
      console.log('No stats data returned for user');
      // Return default empty stats
      return {
        totalChallenges: 0,
        totalScores: 0,
        avgAccuracy: '0.00',
        avgScore: 0,
        avgRank: null,
        bestRank: null,
        worstRank: null,
        bestAccuracy: null,
        highestScore: null,
        participationRate: 0,
        improvementTrend: null,
        lastSubmission: null
      };
    }

    const stats = userStats[0];
    
    return {
      // Basic stats (past 3 months only)
      totalChallenges: stats.total_challenges || 0,
      totalScores: stats.total_scores || 0,
      
      // Averages (past 3 months only)
      avgAccuracy: stats.avg_accuracy ? parseFloat(stats.avg_accuracy).toFixed(2) : '0.00',
      avgScore: stats.avg_score ? Math.round(stats.avg_score) : 0,
      avgRank: stats.avg_rank ? Math.round(stats.avg_rank) : null,
      
      // Best/worst stats (past 3 months only)
      bestRank: stats.best_rank || null,
      worstRank: stats.worst_rank || null,
      bestAccuracy: stats.best_accuracy ? parseFloat(stats.best_accuracy).toFixed(2) : null,
      highestScore: stats.highest_score || null,
      
      // Additional insights (past 3 months only)
      participationRate: stats.participation_rate || 0,
      improvementTrend: stats.improvement_trend || null,
      lastSubmission: stats.last_submission || null
    };

  } catch (error) {
    console.error('Error in getUserStats (3 months):', error);
    throw error;
  }
}
};

// Season helper functions
export const seasonQueries = {
  // Get current season
  getCurrentSeason: async () => {
    const { data, error } = await supabase
      .from('seasons')
      .select('*')
      .eq('is_current', true)
      .single();

    if (error) throw error;
    return data;
  },

  // Get all seasons
  getAllSeasons: async () => {
    const { data, error } = await supabase
      .from('seasons')
      .select('*')
      .order('start_date', { ascending: false });

    if (error) throw error;
    return data;
  },

  // Create new season
  createSeason: async (seasonData) => {
    // Only admin can create seasons (this should be called server-side)
    const { data, error } = await supabase
      .from('seasons')
      .insert(seasonData)
      .select()
      .single();

    if (error) throw error;
    return data;
  }
};

// Donation helper functions
export const donationQueries = {
  // Get user's donation history
  getUserDonations: async (userId) => {
    const { data, error } = await supabase
      .from('donations')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });

    if (error) throw error;
    return data;
  },

  // Get total donations for a user
  getUserDonationTotal: async (userId) => {
    const { data, error } = await supabase
      .from('donations')
      .select('amount')
      .eq('user_id', userId)
      .eq('status', 'completed');

    if (error) throw error;
    
    const total = data?.reduce((sum, donation) => sum + parseFloat(donation.amount), 0) || 0;
    return total;
  },

  // Get recent donations (non-anonymous)
  getRecentDonations: async (limit = 10) => {
    const { data, error } = await supabase
      .from('donations')
      .select(`
        id,
        amount,
        created_at,
        anonymous,
        users (
          username,
          avatar_url
        )
      `)
      .eq('status', 'completed')
      .eq('anonymous', false)
      .order('created_at', { ascending: false })
      .limit(limit);

    if (error) throw error;
    return data;
  },

  // Get donation statistics
  getDonationStats: async () => {
    const { data, error } = await supabase
      .from('donations')
      .select('amount')
      .eq('status', 'completed');

    if (error) throw error;

    const total = data?.reduce((sum, donation) => sum + parseFloat(donation.amount), 0) || 0;
    const count = data?.length || 0;
    const average = count > 0 ? total / count : 0;

    return {
      totalAmount: total,
      totalCount: count,
      averageAmount: average
    };
  }
};

// Auth helper functions
export const auth = {
  getCurrentUser: async () => {
    console.log('üîç auth.getCurrentUser() called');
    
    try {
      // Check if we're in browser environment
      if (typeof window === 'undefined') {
        console.log('‚ùå Server-side environment, no user');
        return null;
      }

      // Call our auth status API with cache busting
      console.log('üì° Calling auth status API...');
      const response = await fetch(`/api/auth/status?_=${Date.now()}`, {
        method: 'GET',
        credentials: 'include',
        cache: 'no-store' // Prevent browser caching
      });

      if (!response.ok) {
        console.error('‚ùå Auth status API failed:', response.status);
        return null;
      }

      const data = await response.json();
      console.log('üì° Auth status response:', data);

      if (!data.authenticated || !data.user) {
        console.log('‚ùå User not authenticated');
        return null;
      }

      console.log('‚úÖ User authenticated successfully:', data.user.username, 'Admin:', data.user.admin);
      return data.user;

    } catch (error) {
      console.error('üö® Error in getCurrentUser:', error);
      return null;
    }
  },

  // Check if user is admin
  isAdmin: async () => {
    const user = await auth.getCurrentUser();
    return user?.admin || false;
  },

  // Sign out
  signOut: async () => {
    console.log('üö™ Signing out...');
    
    try {
      // Call logout API which will clear the HttpOnly cookie
      const response = await fetch('/api/auth/logout', {
        method: 'POST',
        credentials: 'include'
      });

      if (!response.ok) {
        console.warn('‚ö†Ô∏è Logout API failed, clearing manually');
      }
      
      console.log('‚úÖ Signed out successfully');
    } catch (error) {
      console.error('üö® Signout error:', error);
      throw error;
    }
  }
};

// Settings helper functions
export const settingsQueries = {
  // Get user settings
  getUserSettings: async (userId) => {
    const { data, error } = await supabase
      .from('user_settings')
      .select('*')
      .eq('user_id', userId)
      .single();

    if (error && error.code === 'PGRST116') {
      // No settings found, return defaults
      return {
        background_enabled: true,
        background_type: 'gradient',
        background_color: '#FFA500',
        background_gradient_end: '#FF6347',
        background_blur: 50,
        background_dimming: 50,
        background_saturation: 0,
        animations_enabled: true,
        number_format: 'abbreviated',
        default_profile_tab: 'recent',
        profile_visibility: 'public',
        background_id: null, // Updated field name
        donor_effects: {}
      };
    }

    if (error) throw error;
    return data;
  },

  // Update user settings
  updateUserSettings: async (userId, settings) => {
    const { data: existing } = await supabase
      .from('user_settings')
      .select('id')
      .eq('user_id', userId)
      .single();

    if (existing) {
      // Update existing settings
      const { data, error } = await supabase
        .from('user_settings')
        .update({
          ...settings,
          updated_at: new Date().toISOString()
        })
        .eq('user_id', userId)
        .select()
        .single();

      if (error) throw error;
      return data;
    } else {
      // Create new settings
      const { data, error } = await supabase
        .from('user_settings')
        .insert({
          user_id: userId,
          ...settings
        })
        .select()
        .single();

      if (error) throw error;
      return data;
    }
  },

  // Get available backgrounds based on user donation status
  getAvailableBackgrounds: async (userId, totalDonations = 0) => {
    const { data, error } = await supabase
      .from('backgrounds')
      .select('*')
      .eq('is_active', true)
      .or(`category.eq.public,and(category.eq.donor,min_donation_total.lte.${totalDonations}),and(category.eq.premium,min_donation_total.lte.${totalDonations})`)
      .order('category', { ascending: true })
      .order('sort_order', { ascending: true });

    if (error) throw error;
    return data || [];
  },

  // Get single background by ID
  getBackground: async (backgroundId) => {
    const { data, error } = await supabase
      .from('backgrounds')
      .select('*')
      .eq('id', backgroundId)
      .single();

    if (error) throw error;
    return data;
  },

  // Get all public backgrounds (for non-donors to see in UI)
  getPublicBackgrounds: async () => {
    const { data, error } = await supabase
      .from('backgrounds') // Updated table name
      .select('*')
      .eq('is_active', true)
      .eq('category', 'public')
      .order('sort_order', { ascending: true });

    if (error) throw error;
    return data || [];
  },

  // Legacy function for backward compatibility (DEPRECATED)
  getDonorBackgrounds: async (minDonationAmount = 0) => {
    console.warn('getDonorBackgrounds is deprecated, use getAvailableBackgrounds instead');
    const { data, error } = await supabase
      .from('backgrounds')
      .select('*')
      .eq('is_active', true)
      .lte('min_donation_total', minDonationAmount)
      .order('sort_order', { ascending: true });

    if (error) throw error;
    return data || [];
  },

  // Legacy function for backward compatibility (DEPRECATED)
  getDonorBackground: async (backgroundId) => {
    console.warn('getDonorBackground is deprecated, use getBackground instead');
    return await settingsQueries.getBackground(backgroundId);
  }
};


================================================
FILE: frontend/lib/sync-config.js
================================================
export const syncConfig = {
  // How old data must be before cron updates it (5 minutes)
  STALENESS_THRESHOLD_MS: parseInt(process.env.STALENESS_THRESHOLD_MS) || 5 * 60 * 1000, // Changed from 4 to 5
  
  // Maximum concurrent updates in cron job
  MAX_CONCURRENT_UPDATES: parseInt(process.env.MAX_CONCURRENT_UPDATES) || 5,
  
  // Batch size for processing
  BATCH_SIZE: parseInt(process.env.BATCH_SIZE) || 10,
  
  // Cron secret for authentication
  CRON_SECRET: process.env.CRON_SECRET || 'your-secure-cron-secret',
};

// Helper to ensure UTC interpretation of timestamps
function ensureUTC(dateString) {
  if (!dateString) return null;
  // If it already has timezone info, use as-is
  if (dateString.includes('Z') || dateString.includes('+') || dateString.includes('-', 10)) {
    return new Date(dateString);
  }
  // Otherwise, treat as UTC by appending 'Z'
  return new Date(dateString + 'Z');
}

export function isStale(updatedAt) {
  if (!updatedAt) return true;
  
  const timestamp = ensureUTC(updatedAt).getTime();
  return Date.now() - timestamp > syncConfig.STALENESS_THRESHOLD_MS;
}

export default syncConfig;


================================================
FILE: frontend/lib/text-formatting.js
================================================
import React from 'react';
import { ExternalLink } from 'lucide-react';

// Helper function to count only display text (not markup)
export const countDisplayCharacters = (text) => {
  if (!text) return 0;
  
  // Remove markdown syntax for counting (including escape sequences)
  let displayText = text
    // Remove escape sequences first
    .replace(/\\(.)/g, '$1')  // \* becomes *, \[ becomes [, etc.
    
    // Remove bold/italic markers
    .replace(/\*\*\*(.*?)\*\*\*/g, '$1')  // Bold italic
    .replace(/\*\*(.*?)\*\*/g, '$1')      // Bold
    .replace(/\*(.*?)\*/g, '$1')          // Italic
    .replace(/~~(.*?)~~/g, '$1')          // Strikethrough
    .replace(/`(.*?)`/g, '$1')            // Code
    
    // Remove link syntax, keep only display text
    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')  // [text](url) -> text
    
    // Remove color syntax
    .replace(/\{color:([^}]+)\}(.*?)\{\/color\}/g, '$2')  // {color:red}text{/color} -> text
    
    // Remove highlight syntax
    .replace(/==(.*?)==/g, '$1')          // ==highlight== -> text
    
    // Clean up any remaining whitespace
    .trim();
    
  return displayText.length;
};

// Simple markdown-style parser for partner descriptions
const FormattedDescription = ({ text, className = "" }) => {
  if (!text) return null;

  // Parse the text and convert markdown-style formatting to JSX
  const parseFormatting = (text) => {
    // First, let's preserve line breaks by splitting into lines and processing each line
    const lines = text.split('\n');
    
    return lines.map((line, lineIndex) => {
      if (!line.trim()) {
        // Empty line
        return <div key={`empty-${lineIndex}`} className="h-2"></div>;
      }
      
      // Process formatting for this line
      const processLine = (lineText) => {
        // First, handle escape sequences - replace \* with a placeholder, process formatting, then restore
        const escapeMap = new Map();
        let escapeCounter = 0;
        
        // Replace escaped characters with placeholders
        const textWithPlaceholders = lineText.replace(/\\(.)/g, (match, char) => {
          const placeholder = `__ESC_${escapeCounter}__`;
          escapeMap.set(placeholder, char);
          escapeCounter++;
          return placeholder;
        });
        
        const patterns = [
          // Bold italic (must come before bold and italic)
          { regex: /\*\*\*(.*?)\*\*\*/g, render: (match, content) => <strong key={Math.random()} className="font-bold italic">{content}</strong> },
          
          // Bold
          { regex: /\*\*(.*?)\*\*/g, render: (match, content) => <strong key={Math.random()} className="font-bold">{content}</strong> },
          
          // Italic
          { regex: /\*(.*?)\*/g, render: (match, content) => <em key={Math.random()} className="italic">{content}</em> },
          
          // Strikethrough
          { regex: /~~(.*?)~~/g, render: (match, content) => <del key={Math.random()} className="line-through opacity-75">{content}</del> },
          
          // Code/monospace
          { regex: /`(.*?)`/g, render: (match, content) => <code key={Math.random()} className="bg-black/10 text-purple-700 px-1 py-0.5 rounded text-sm font-mono">{content}</code> },
          
          // Highlight
          { regex: /==(.*?)==/g, render: (match, content) => <mark key={Math.random()} className="bg-yellow-200 text-yellow-900 px-1 rounded">{content}</mark> },
          
          // Color text - supports CSS color names and hex codes
          { regex: /\{color:([^}]+)\}(.*?)\{\/color\}/g, render: (match, color, content) => 
            <span key={Math.random()} style={{ color: color }} className="font-medium">{content}</span> 
          },
          
          // Links - [text](url)
          { regex: /\[([^\]]+)\]\(([^)]+)\)/g, render: (match, linkText, url) => (
            <a 
              key={Math.random()}
              href={url} 
              target="_blank" 
              rel="noopener noreferrer"
              className="text-purple-600 hover:text-purple-700 underline decoration-purple-300 hover:decoration-purple-500 transition-all font-medium inline-flex items-center gap-1"
            >
              {linkText}
              <ExternalLink className="w-3 h-3" />
            </a>
          )}
        ];
        
        let segments = [{ text: textWithPlaceholders, type: 'text' }];
        
        patterns.forEach(pattern => {
          const newSegments = [];
          
          segments.forEach(segment => {
            if (segment.type !== 'text') {
              newSegments.push(segment);
              return;
            }
            
            let lastIndex = 0;
            let match;
            pattern.regex.lastIndex = 0;
            
            while ((match = pattern.regex.exec(segment.text)) !== null) {
              if (match.index > lastIndex) {
                newSegments.push({
                  text: segment.text.slice(lastIndex, match.index),
                  type: 'text'
                });
              }
              
              newSegments.push({
                element: pattern.render(match[0], match[1], match[2]),
                type: 'formatted'
              });
              
              lastIndex = match.index + match[0].length;
            }
            
            if (lastIndex < segment.text.length) {
              newSegments.push({
                text: segment.text.slice(lastIndex),
                type: 'text'
              });
            }
          });
          
          segments = newSegments;
        });
        
        // Restore escaped characters in the final output
        return segments.map((segment, index) => {
          if (segment.type === 'formatted') {
            return React.cloneElement(segment.element, { key: index });
          } else {
            // Restore escaped characters
            let restoredText = segment.text;
            escapeMap.forEach((char, placeholder) => {
              restoredText = restoredText.replace(placeholder, char);
            });
            return restoredText;
          }
        });
      };
      
      return (
        <div key={`line-${lineIndex}`} className="leading-relaxed">
          {processLine(line)}
        </div>
      );
    });
  };

  const displayCharCount = countDisplayCharacters(text);

  return (
    <div className={`formatted-description ${className}`}>
      <div className="w-full text-justify">
        {parseFormatting(text)}
      </div>
    </div>
  );
};

export default FormattedDescription;


================================================
FILE: frontend/lib/token-encryption.js
================================================
import crypto from 'crypto';

const ALGORITHM = 'aes-256-gcm';
const IV_LENGTH = 16;

// Get encryption key from environment (must be 32 bytes for AES-256)
const ENCRYPTION_KEY_BASE64 = process.env.TOKEN_ENCRYPTION_KEY;

if (!ENCRYPTION_KEY_BASE64) {
  throw new Error('TOKEN_ENCRYPTION_KEY must be set in environment');
}

// Decode the key (should be 32 bytes)
const ENCRYPTION_KEY = Buffer.from(ENCRYPTION_KEY_BASE64, 'base64');

if (ENCRYPTION_KEY.length !== 32) {
  throw new Error('TOKEN_ENCRYPTION_KEY must be 32 bytes (base64 encoded)');
}

/**
 * Encrypts an osu! token string
 * @param {string} tokenString - Format: "access_token|expires_timestamp|refresh_token"
 * @returns {string} Encrypted token (base64: iv:authTag:ciphertext)
 */
export function encryptToken(tokenString) {
  const iv = crypto.randomBytes(IV_LENGTH);
  const cipher = crypto.createCipheriv(ALGORITHM, ENCRYPTION_KEY, iv);
  
  let encrypted = cipher.update(tokenString, 'utf8');
  encrypted = Buffer.concat([encrypted, cipher.final()]);
  
  const authTag = cipher.getAuthTag();
  
  // Return as: iv:authTag:ciphertext (all base64)
  return `${iv.toString('base64')}:${authTag.toString('base64')}:${encrypted.toString('base64')}`;
}

/**
 * Decrypts an encrypted osu! token
 * @param {string} encryptedToken 
 * @returns {string} Original token string
 */
export function decryptToken(encryptedToken) {
  const [ivB64, authTagB64, ciphertextB64] = encryptedToken.split(':');
  
  const iv = Buffer.from(ivB64, 'base64');
  const authTag = Buffer.from(authTagB64, 'base64');
  const ciphertext = Buffer.from(ciphertextB64, 'base64');
  
  const decipher = crypto.createDecipheriv(ALGORITHM, ENCRYPTION_KEY, iv);
  decipher.setAuthTag(authTag);
  
  let decrypted = decipher.update(ciphertext);
  decrypted = Buffer.concat([decrypted, decipher.final()]);
  
  return decrypted.toString('utf8');
}

/**
 * Parse token string into components
 */
export function parseToken(tokenString) {
  const [accessToken, expiresTimestamp, refreshToken] = tokenString.split('|');
  return {
    accessToken,
    expiresAt: new Date(parseInt(expiresTimestamp) * 1000),
    refreshToken
  };
}

/**
 * Check if token is expired (with 5 min buffer)
 */
export function isTokenExpired(tokenString, bufferSeconds = 300) {
  const { expiresAt } = parseToken(tokenString);
  return (expiresAt.getTime() - Date.now()) <= (bufferSeconds * 1000);
}

/**
 * Mask token for safe logging
 */
export function maskToken(tokenString) {
  if (!tokenString) return '[no token]';
  const parts = tokenString.split('|');
  if (parts.length !== 3) return '[invalid]';
  
  const mask = (s) => s.length > 8 ? `${s.slice(0,4)}...${s.slice(-4)}` : '****';
  return `${mask(parts[0])}|${parts[1]}|${mask(parts[2])}`;
}

export function testEncryption() {
  if (process.env.NODE_ENV === 'production') {
    console.warn('testEncryption should not be used in production');
    return;
  }

  console.log('Testing token encryption...');
  
  const testToken = 'test_access_token_12345|1730000000|test_refresh_token_67890';
  console.log('Original:', maskToken(testToken));
  
  try {
    // Encrypt
    const encrypted = encryptToken(testToken);
    console.log('‚úÖ Encryption successful');
    console.log('Encrypted length:', encrypted.length);
    
    // Decrypt
    const decrypted = decryptToken(encrypted);
    console.log('‚úÖ Decryption successful');
    
    // Verify
    if (decrypted === testToken) {
      console.log('‚úÖ Encryption/Decryption verification PASSED');
    } else {
      console.error('‚ùå Verification FAILED - tokens do not match');
    }
    
    // Test parsing
    const parsed = parseToken(decrypted);
    console.log('‚úÖ Token parsing successful');
    console.log('Expires at:', parsed.expiresAt);
    console.log('Is expired?', isTokenExpired(decrypted));
    
    // Test invalid encryption
    try {
      decryptToken('invalid:encrypted:token:data');
      console.error('‚ùå Should have thrown error for invalid token');
    } catch {
      console.log('‚úÖ Invalid token detection working');
    }
    
    console.log('All encryption tests passed!');
    
  } catch (error) {
    console.error('‚ùå Encryption test failed:', error.message);
  }
}

/**
 * Create token string from components
 * @param {string} accessToken 
 * @param {number} expiresTimestamp - Unix timestamp in seconds
 * @param {string} refreshToken 
 * @returns {string} Format: "access_token|expires_timestamp|refresh_token"
 */
export function createTokenString(accessToken, expiresTimestamp, refreshToken) {
  return `${accessToken}|${expiresTimestamp}|${refreshToken}`;
}


================================================
FILE: frontend/lib/update-tracker.js
================================================
import { syncConfig } from './sync-config';

// Simple function to check if challenge is stale (server-side only)
export function isStaleChallenge(challenge) {
  if (!challenge || !challenge.is_active) return false;
  
  const updatedAt = challenge.updated_at;
  if (!updatedAt) return true;
  
  const timestamp = new Date(updatedAt).getTime();
  const age = Date.now() - timestamp;
  
  return age > syncConfig.STALENESS_THRESHOLD_MS;
}

// Mark challenge as updated (for compatibility - does nothing now)
export function markChallengeUpdated(roomId) {
  console.log(`‚úÖ Challenge ${roomId} updated`);
}


================================================
FILE: frontend/pages/_app.js
================================================
import '../styles/globals.css';
import { AuthProvider } from '../lib/AuthContext';
import { SettingsProvider } from '../lib/SettingsContext';
import { Toaster } from 'react-hot-toast';
import ErrorBoundary from '../components/ErrorBoundary';

function MyApp({ Component, pageProps }) {
  return (
    <ErrorBoundary>
      <AuthProvider>
        <SettingsProvider>
          <Component {...pageProps} />
          <Toaster 
            position="bottom-right"
            toastOptions={{
              className: 'glass-2 text-white font-medium',
              style: {
                background: 'rgba(255, 255, 255, 0.1)',
                color: '#fff',
                backdropFilter: 'blur(10px)',
                border: '1px solid rgba(255, 255, 255, 0.2)',
              },
              duration: 4000,
            }}
          />
        </SettingsProvider>
      </AuthProvider>
    </ErrorBoundary>
  );
}

export default MyApp;


================================================
FILE: frontend/pages/_document.js
================================================
import { Html, Head, Main, NextScript } from 'next/document'

export default function Document() {
  return (
    <Html>
      <Head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" />
        
        {/* Favicons */}
        <link rel="icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
        <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
        <link rel="icon" type="image/png" sizes="192x192" href="/android-chrome-192x192.png" />
        <link rel="icon" type="image/png" sizes="512x512" href="/android-chrome-512x512.png" />
        
        {/* Web App Manifest */}
        <link rel="manifest" href="/site.webmanifest" />
      </Head>
      <body>
        <Main />
        <NextScript />
      </body>
    </Html>
  )
}


================================================
FILE: frontend/pages/admin.js
================================================
import { useState, useEffect, useRef } from 'react';
import Link from 'next/link';
import Layout from '../components/Layout';
import { Plus, Loader2, CheckCircle, AlertCircle, Settings, RefreshCw, Zap, Users, Calendar, Music, X, Pause, Play, Edit3, ArrowRight, Info, Link as PartnersIcon, ExternalLink, Trash2, Eye, EyeOff, GripVertical, Sparkles, BarChart3 } from 'lucide-react';
import { useAuth } from '../lib/AuthContext';
import { useRouter } from 'next/router';
import RulesetManager from '../components/RulesetManager';
import { Crown, Target } from 'lucide-react';

// Fixed UTC time formatting function
const formatUTCDateTime = (utcDateString) => {
  if (!utcDateString) return 'N/A';
  
  const utcString = utcDateString.endsWith('Z') ? utcDateString : `${utcDateString}Z`;
  const date = new Date(utcString);
  
  return date.toLocaleString(undefined, {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  });
}

const getUTCTimestamp = (utcDateString) => {
  if (!utcDateString) return null;
  const utcString = utcDateString.endsWith('Z') ? utcDateString : `${utcDateString}Z`;
  return new Date(utcString).getTime();
}

// Import the name generator directly
import { generateRulesetName } from '../lib/ruleset-name-generator';

// Helper function to generate ruleset names
const generateRulesetDisplayName = (challenge) => {
  if (!challenge.has_ruleset || !challenge.required_mods || challenge.required_mods.length === 0) {
    return null;
  }

  try {
    // Use the imported function directly
    return generateRulesetName(
      challenge.required_mods, 
      challenge.ruleset_match_type || 'exact'
    );
  } catch (error) {
    console.warn('Error generating ruleset name:', error);
    
    // Fallback: simple concatenation of mod acronyms
    const modNames = challenge.required_mods.map(mod => mod.acronym).join('');
    const prefix = challenge.ruleset_match_type === 'at_least' ? 'AtLeast:' : 
                   challenge.ruleset_match_type === 'any_of' ? 'Any:' : '';
    return `${prefix}${modNames}`;
  }
};

export default function Admin() {
  const { user, loading, isAdmin } = useAuth();
  const [roomId, setRoomId] = useState('');
  const [customName, setCustomName] = useState('');
  const [loading2, setLoading2] = useState(false);
  const [result, setResult] = useState(null);
  const [activeChallenges, setActiveChallenges] = useState([]);
  const [updatingChallenges, setUpdatingChallenges] = useState(new Set());
  const [showRulesetManager, setShowRulesetManager] = useState(false);
  const [selectedChallengeForRuleset, setSelectedChallengeForRuleset] = useState(null);
  
  // Partner management state variables
  const [partners, setPartners] = useState([]);
  const [loadingPartners, setLoadingPartners] = useState(false);
  const [showPartnerForm, setShowPartnerForm] = useState(false);
  const [editingPartner, setEditingPartner] = useState(null);
  const [partnerForm, setPartnerForm] = useState({
    name: '',
    icon_url: '',
    description: '',
    is_active: true,
    display_order: 0
  });
  
  // Non-blocking bulk update state
  const [bulkUpdateState, setBulkUpdateState] = useState({
    isRunning: false,
    isPaused: false,
    progress: { current: 0, total: 0 },
    results: [],
    currentChallenge: null,
    canCancel: false
  });
  
  const bulkUpdateController = useRef(null);
  const router = useRouter();

  useEffect(() => {
    if (!loading) { // Wait for auth to load
      if (!user) {
        router.push('/');
        return;
      }
      
      if (!user.admin) {
        router.push('/');
        return;
      }
      
      // If we get here, user is admin - load data
      loadActiveChallenges();
      loadPartners();
    }
  }, [user, loading, router]);

  const loadActiveChallenges = async () => {
    try {
      const response = await fetch('/api/challenges?active=true');
      const data = await response.json();
      if (data.success) {
        // Handle the nested structure - challenges are in data.data.challenges
        const challenges = data.data?.challenges || data.challenges || [];
        setActiveChallenges(challenges);
        console.log('Active challenges loaded:', challenges.length);
      } else {
        console.error('API returned error:', data.error);
      }
    } catch (error) {
      console.error('Failed to load active challenges:', error);
    }
  };

  // Partner management functions
  const loadPartners = async () => {
    try {
      setLoadingPartners(true);
      const response = await fetch('/api/admin/partners');
      const data = await response.json();
      
      if (data.success) {
        const partners = data.data?.partners || data.partners || [];
        console.log('‚úÖ Partners loaded successfully:', partners.length);
        setPartners(partners);
      } else {
        console.error('API returned error:', data.error);
        setResult({
          success: false,
          message: data.error || 'Failed to load partners'
        });
      }
    } catch (error) {
      console.error('Failed to load partners:', error);
      setResult({
        success: false,
        message: 'Network error loading partners'
      });
    } finally {
      setLoadingPartners(false);
    }
  };

  const handlePartnerSubmit = async (e) => {
    e.preventDefault();
    
    try {
      // Always use the index endpoint
      const url = '/api/partners';
      const method = editingPartner ? 'PUT' : 'POST';
      
      // For editing, include the ID in the body
      const body = editingPartner 
        ? { ...partnerForm, id: editingPartner.id }
        : partnerForm;
      
      console.log(`üîÑ ${method} request to ${url}`, body);
      
      const response = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      });
      
      console.log('üì° Response status:', response.status);
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('‚ùå HTTP Error:', response.status, errorText);
        
        let errorMessage;
        try {
          const errorData = JSON.parse(errorText);
          errorMessage = errorData.error?.message || errorData.error || errorData.message || errorText;
        } catch {
          errorMessage = errorText || `HTTP ${response.status} error`;
        }
        
        throw new Error(errorMessage);
      }
      
      const data = await response.json();
      console.log('üì¶ Response data:', data);
      
      if (data.success !== false) {
        setResult({
          success: true,
          message: editingPartner 
            ? 'Partner updated successfully'
            : 'Partner created successfully'
        });
        
        // Reset form
        setShowPartnerForm(false);
        setEditingPartner(null);
        setPartnerForm({
          name: '',
          icon_url: '',
          description: '',
          is_active: true,
          display_order: 0
        });
        
        // Reload partners
        setTimeout(() => {
          loadPartners();
        }, 500);
        
      } else {
        throw new Error(data.error || 'Failed to save partner');
      }
      
    } catch (error) {
      console.error('‚ùå Partner submit error:', error);
      
      setResult({
        success: false,
        message: error.message || 'Network error. Please try again.'
      });
    }
  };

  const handleTogglePartnerStatus = async (partner) => {
    try {
      // Use the index endpoint with PUT method, including ID in body
      const response = await fetch('/api/partners', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          id: partner.id,
          is_active: !partner.is_active 
        })
      });
      
      if (response.ok) {
        loadPartners(); // Reload the partners list
      } else {
        const errorText = await response.text();
        console.error('Toggle status error:', errorText);
        
        let errorMessage;
        try {
          const errorData = JSON.parse(errorText);
          errorMessage = errorData.error?.message || errorData.error || errorData.message || errorText;
        } catch {
          errorMessage = errorText || 'Failed to update partner status';
        }
        
        setResult({
          success: false,
          message: errorMessage
        });
      }
    } catch (error) {
      console.error('Toggle partner status error:', error);
      setResult({
        success: false,
        message: error.message || 'Network error. Please try again.'
      });
    }
  };

  const handleDeletePartner = async (partnerId) => {
    if (!confirm('Are you sure you want to delete this partner?')) {
      return;
    }
    
    try {
      console.log('üóëÔ∏è Deleting partner ID:', partnerId, 'Type:', typeof partnerId);
      
      // Ensure partnerId is a number and send as array
      const partnerIdNumber = typeof partnerId === 'string' ? parseInt(partnerId) : partnerId;
      
      // Validate that we have a valid number
      if (isNaN(partnerIdNumber) || partnerIdNumber <= 0) {
        throw new Error('Invalid partner ID');
      }
      
      const requestBody = {
        operation: 'delete',
        partnerIds: [partnerIdNumber] // ‚úÖ Correctly formatted as array
      };
      
      console.log('üì¶ Request body:', JSON.stringify(requestBody));
      
      const response = await fetch('/api/admin/partners', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody)
      });
      
      console.log('üì° Delete response status:', response.status);
      
      if (response.ok) {
        const data = await response.json();
        console.log('‚úÖ Delete successful:', data);
        
        setResult({
          success: true,
          message: 'Partner deleted successfully'
        });
        
        // Reload partners list
        loadPartners();
      } else {
        const errorText = await response.text();
        console.error('‚ùå Delete error:', errorText);
        
        let errorMessage;
        try {
          const errorData = JSON.parse(errorText);
          errorMessage = errorData.error?.message || errorData.error || errorData.message || errorText;
        } catch {
          errorMessage = errorText || 'Failed to delete partner';
        }
        
        setResult({
          success: false,
          message: errorMessage
        });
      }
    } catch (error) {
      console.error('‚ùå Delete partner error:', error);
      setResult({
        success: false,
        message: error.message || 'Network error. Please try again.'
      });
    }
  };

  const handleUpdateAllActive = async () => {
    if (activeChallenges.length === 0) {
      setResult({ success: false, error: 'No active challenges to update' });
      return;
    }

    // Create abort controller for cancellation
    bulkUpdateController.current = new AbortController();
    
    setBulkUpdateState({
      isRunning: true,
      isPaused: false,
      progress: { current: 0, total: activeChallenges.length },
      results: [],
      currentChallenge: null,
      canCancel: true
    });
    
    try {
      let updated = 0;
      let failed = 0;
      const results = [];
      
      console.log(`üîÑ Starting non-blocking bulk update of ${activeChallenges.length} challenges`);
      
      for (let i = 0; i < activeChallenges.length; i++) {
        const challenge = activeChallenges[i];
        
        // Check if cancelled
        if (bulkUpdateController.current?.signal.aborted) {
          console.log('üõë Bulk update cancelled by user');
          break;
        }
        
        // Update current challenge
        setBulkUpdateState(prev => ({
          ...prev,
          currentChallenge: challenge,
          progress: { current: i, total: activeChallenges.length }
        }));
        
        // Wait for pause if needed
        while (bulkUpdateState.isPaused && !bulkUpdateController.current?.signal.aborted) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        try {
          console.log(`üöÄ Updating challenge ${challenge.room_id} (${i + 1}/${activeChallenges.length})`);
          
          const response = await fetch('/api/update-challenge', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ roomId: challenge.room_id }),
            signal: bulkUpdateController.current?.signal
          });
          
          const result = await response.json();
          
          const challengeResult = {
            roomId: challenge.room_id,
            name: challenge.name,
            success: result.success,
            error: result.error,
            timestamp: new Date().toISOString()
          };
          
          if (result.success) {
            updated++;
            console.log(`‚úÖ Challenge ${challenge.room_id} updated successfully`);
          } else {
            failed++;
            console.error(`‚ùå Challenge ${challenge.room_id} failed:`, result.error);
          }
          
          results.push(challengeResult);
          
          // Update progress in real-time
          setBulkUpdateState(prev => ({
            ...prev,
            results: [...prev.results, challengeResult],
            progress: { current: i + 1, total: activeChallenges.length }
          }));
          
          // Non-blocking delay - allows UI to remain responsive
          if (i < activeChallenges.length - 1) { // Don't delay after last item
            for (let delay = 0; delay < 2000; delay += 100) {
              if (bulkUpdateController.current?.signal.aborted) break;
              
              // Check for pause during delay
              if (!bulkUpdateState.isPaused) {
                await new Promise(resolve => setTimeout(resolve, 100));
              }
            }
          }
          
        } catch (error) {
          if (error.name === 'AbortError') {
            console.log('üõë Challenge update aborted');
            break;
          }
          
          failed++;
          console.error(`‚ùå Error updating challenge ${challenge.room_id}:`, error);
          
          const errorResult = {
            roomId: challenge.room_id,
            name: challenge.name,
            success: false,
            error: error.message,
            timestamp: new Date().toISOString()
          };
          
          results.push(errorResult);
          
          setBulkUpdateState(prev => ({
            ...prev,
            results: [...prev.results, errorResult]
          }));
        }
      }
      
      // Final state update
      setBulkUpdateState(prev => ({
        ...prev,
        isRunning: false,
        currentChallenge: null,
        canCancel: false
      }));
      
      // Set final result
      setResult({
        success: updated > 0,
        updated,
        failed,
        total: activeChallenges.length,
        cancelled: bulkUpdateController.current?.signal.aborted,
        message: bulkUpdateController.current?.signal.aborted 
          ? `Update cancelled. Processed ${updated + failed}/${activeChallenges.length} challenges`
          : `Updated ${updated}/${activeChallenges.length} challenges successfully`,
        results
      });
      
      // Refresh the challenges list after updates
      if (updated > 0) {
        setTimeout(() => {
          loadActiveChallenges();
        }, 2000);
      }
      
    } catch (error) {
      setBulkUpdateState(prev => ({
        ...prev,
        isRunning: false,
        currentChallenge: null,
        canCancel: false
      }));
      
      setResult({
        success: false,
        error: error.message
      });
    }
  };

  const handleManageRuleset = (challenge) => {
    setSelectedChallengeForRuleset(challenge);
    setShowRulesetManager(true);
  };

  const handleRulesetSuccess = (message) => {
    setResult({
      success: true,
      message: message
    });
    setShowRulesetManager(false);
    setSelectedChallengeForRuleset(null);
    
    // Refresh challenges list
    setTimeout(() => {
      loadActiveChallenges();
    }, 1000);
  };

  // Pause/Resume functionality
  const toggleBulkUpdatePause = () => {
    setBulkUpdateState(prev => ({
      ...prev,
      isPaused: !prev.isPaused
    }));
  };

  // Cancel functionality
  const cancelBulkUpdate = () => {
    if (bulkUpdateController.current) {
      bulkUpdateController.current.abort();
    }
  };

  const handleUpdateSingleChallenge = async (roomId) => {
    setUpdatingChallenges(prev => new Set(prev).add(roomId));
    
    try {
      const response = await fetch('/api/update-challenge', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ roomId })
      });
      
      const result = await response.json();
      
      if (result.success) {
        setResult({
          success: true,
          message: `Successfully updated challenge ${roomId}`,
          updated: 1,
          total: 1,
          skipped: 0
        });
        
        setTimeout(() => {
          loadActiveChallenges();
        }, 1000);
      } else {
        setResult({
          success: false,
          error: result.error || 'Update failed'
        });
      }
    } catch (error) {
      setResult({
        success: false,
        error: error.message
      });
    } finally {
      setUpdatingChallenges(prev => {
        const newSet = new Set(prev);
        newSet.delete(roomId);
        return newSet;
      });
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!roomId.trim()) {
      setResult({ success: false, message: 'Please enter a room ID' });
      return;
    }

    setLoading2(true);
    setResult(null);

    try {
      console.log('üöÄ Submitting challenge creation:', {
        roomId: parseInt(roomId),
        custom_name: customName.trim() || null
      });

      const response = await fetch('/api/challenges', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          roomId: parseInt(roomId),
          custom_name: customName.trim() || null
        })
      });

      console.log('üì° Response status:', response.status);
      console.log('üì° Response headers:', response.headers.get('content-type'));

      // Check if the response is JSON
      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        console.error('‚ùå Response is not JSON:', contentType);
        const textResponse = await response.text();
        console.error('‚ùå Response text:', textResponse);
        throw new Error('Server returned invalid response format');
      }

      const data = await response.json();
      console.log('üì¶ Response data:', data);

      if (response.ok) {
        // Handle successful response
        const challengeName = data.challenge?.custom_name || data.challenge?.name || `Challenge ${roomId}`;
        
        setResult({
          success: true,
          message: `Successfully added challenge: ${challengeName}`,
          challenge: data.challenge
        });
        
        // Clear the form
        setRoomId('');
        setCustomName('');
        
        // Reload challenges list after a short delay
        setTimeout(() => {
          loadActiveChallenges();
        }, 1000);
        
      } else {
        // Handle error response
        console.error('‚ùå Server returned error:', data);
        
        let errorMessage = 'Failed to add challenge';
        
        if (data.error) {
          errorMessage = typeof data.error === 'string' ? data.error : data.error.message || errorMessage;
        } else if (data.message) {
          errorMessage = data.message;
        }
        
        setResult({
          success: false,
          message: errorMessage
        });
      }

    } catch (error) {
      console.error('‚ùå Network/Parse error:', error);
      
      let errorMessage = 'Network error. Please try again.';
      
      // Provide more specific error messages
      if (error.name === 'SyntaxError') {
        errorMessage = 'Server returned invalid response. Please try again.';
      } else if (error.message?.includes('fetch')) {
        errorMessage = 'Connection error. Please check your internet connection.';
      } else if (error.message?.includes('timeout')) {
        errorMessage = 'Request timed out. Please try again.';
      } else if (error.message) {
        errorMessage = error.message;
      }
      
      setResult({
        success: false,
        message: errorMessage
      });
    } finally {
      setLoading2(false);
    }
  };

  if (loading) {
    return (
      <Layout>
        <div className="min-h-screen flex items-center justify-center">
          <div className="glass-card-enhanced rounded-2xl p-8">
            <Loader2 className="w-8 h-8 animate-spin text-primary-500 mx-auto" />
            <p className="text-neutral-600 mt-4 text-center">Checking admin access...</p>
          </div>
        </div>
      </Layout>
    );
  }

  if (!user || !user.admin) {
    return null;
  }

  return (
    <Layout>
      <div className="min-h-screen py-8">
        <div className="max-w-7xl mx-auto px-4">
          {/* Enhanced Header Section */}
          <div className="mb-12">
            <div className="flex items-start justify-between mb-8">
              <div>
                <div className="flex items-center gap-4 mb-4">
                  <div className="relative">
                    <Settings className="w-10 h-10 text-primary-600 icon-adaptive-shadow" />
                    <Sparkles className="w-5 h-5 text-yellow-500 absolute -top-1 -right-1 icon-adaptive-shadow" />
                  </div>
                  
                  {/* Header with adaptive text shadow */}
                  <h1 
                    className="text-4xl font-bold text-neutral-800 text-white/90 text-adaptive-shadow"
                    data-text="Admin Panel"
                  >
                    Admin Panel
                  </h1>
                </div>
                
                {/* Description */}
                <p className="text-neutral-600 text-lg max-w-2xl text-white/85 text-adaptive-shadow">
                  Welcome, {user?.username}! Manage challenges, partners, and system settings from your control center.
                </p>
              </div>
            </div>
          </div>

          {/* Enhanced Result Message */}
          {result && (
            <div className={`mb-8 glass-card-enhanced rounded-2xl p-6 border-l-4 ${
              result.success 
                ? 'border-green-500 bg-gradient-to-r from-green-50/80 to-emerald-50/80' 
                : 'border-red-500 bg-gradient-to-r from-red-50/80 to-pink-50/80'
            }`}>
              <div className="flex items-start gap-3">
                {result.success ? (
                  <div className="p-2 bg-green-100 rounded-lg">
                    <CheckCircle className="w-5 h-5 text-green-600" />
                  </div>
                ) : (
                  <div className="p-2 bg-red-100 rounded-lg">
                    <AlertCircle className="w-5 h-5 text-red-600" />
                  </div>
                )}
                <div className="flex-1">
                  <p className={`font-medium ${result.success ? 'text-green-800' : 'text-red-800'}`}>
                    {(() => {
                      if (typeof result.message === 'string') {
                        return result.message;
                      }
                      if (typeof result.error === 'string') {
                        return result.error;
                      }
                      if (typeof result.error === 'object' && result.error?.message) {
                        return result.error.message;
                      }
                      return 'An error occurred';
                    })()}
                  </p>
                  {result.challenge && (
                    <div className="mt-3 p-3 bg-white/60 rounded-lg text-sm text-neutral-700">
                      <div className="grid grid-cols-2 gap-2">
                        <p><span className="font-medium">Room ID:</span> {result.challenge.room_id}</p>
                        <p><span className="font-medium">Host:</span> {result.challenge.host}</p>
                        {result.challenge.custom_name && (
                          <p className="col-span-2"><span className="font-medium">Custom Name:</span> {result.challenge.custom_name}</p>
                        )}
                      </div>
                      <p className="text-green-600 font-medium mt-2 flex items-center gap-1">
                        <CheckCircle className="w-4 h-4" />
                        Active Challenge
                      </p>
                    </div>
                  )}
                  {result.updated !== undefined && (
                    <div className="mt-3 p-3 bg-white/60 rounded-lg text-sm text-neutral-700">
                      <div className="flex items-center justify-between">
                        <span>Updated: <span className="font-bold text-green-600">{result.updated}</span> challenges</span>
                        {result.failed > 0 && (
                          <span>Failed: <span className="font-bold text-red-600">{result.failed}</span></span>
                        )}
                      </div>
                      {result.cancelled && (
                        <p className="text-orange-600 font-medium mt-2 flex items-center gap-1">
                          <X className="w-4 h-4" />
                          Operation was cancelled
                        </p>
                      )}
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}

          <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
            
            {/* Enhanced Add Challenge Section */}
            <div className="glass-card-enhanced rounded-2xl p-8 border border-primary-200/60 bg-gradient-to-br from-primary-50/80 to-blue-50/80 backdrop-blur-lg">
              <div className="flex items-center gap-3 mb-6">
                <div className="p-3 bg-gradient-to-br from-primary-500 to-blue-500 rounded-xl">
                  <Plus className="w-6 h-6 text-white" />
                </div>
                <h2 className="text-xl font-semibold text-neutral-800">Add New Challenge</h2>
              </div>
              
              <form onSubmit={handleSubmit} className="space-y-6">
                <div>
                  <label htmlFor="roomId" className="block text-sm font-medium mb-2 text-neutral-700">
                    osu! Multiplayer Room ID *
                  </label>
                  <input
                    type="text"
                    id="roomId"
                    value={roomId}
                    onChange={(e) => setRoomId(e.target.value)}
                    placeholder="e.g., 1392361"
                    className="w-full px-4 py-3 bg-white/80 border border-neutral-300/60 rounded-xl focus:outline-none focus:border-primary-500 focus:ring-2 focus:ring-primary-200 transition-all backdrop-blur-sm"
                    disabled={loading}
                  />
                  <p className="text-xs text-neutral-500 mt-2 bg-white/40 rounded-lg px-3 py-2">
                    üí° Find the room ID in the URL: osu.ppy.sh/multiplayer/rooms/<strong>1392361</strong>
                  </p>
                </div>

                <div>
                  <label htmlFor="customName" className="block text-sm font-medium mb-2 text-neutral-700">
                    Custom Display Name
                  </label>
                  <input
                    type="text"
                    id="customName"
                    value={customName}
                    onChange={(e) => setCustomName(e.target.value)}
                    placeholder="Override the default room name (optional)"
                    className="w-full px-4 py-3 bg-white/80 border border-neutral-300/60 rounded-xl focus:outline-none focus:border-primary-500 focus:ring-2 focus:ring-primary-200 transition-all backdrop-blur-sm"
                    disabled={loading}
                  />
                  <p className="text-xs text-neutral-500 mt-2 bg-white/40 rounded-lg px-3 py-2">
                    ‚ú® Leave empty to use the original room name from osu!
                  </p>
                </div>

                <button
                  type="submit"
                  disabled={loading2 || !roomId.trim()}
                  className="w-full flex items-center justify-center gap-2 bg-gradient-to-r from-primary-600 to-blue-600 hover:from-primary-700 hover:to-blue-700 disabled:from-neutral-400 disabled:to-neutral-500 disabled:cursor-not-allowed text-white px-6 py-4 rounded-xl transition-all font-medium shadow-lg hover:shadow-xl transform hover:scale-105 disabled:transform-none"
                >
                  {loading2 ? (
                    <>
                      <Loader2 className="w-5 h-5 animate-spin" />
                      Adding Challenge...
                    </>
                  ) : (
                    <>
                      <Plus className="w-5 h-5" />
                      Add Challenge
                    </>
                  )}
                </button>
              </form>

              {/* Enhanced Manage Challenge Names Link */}
              <div className="mt-8 pt-6 border-t border-primary-200/60">
                <h3 className="text-sm font-medium text-neutral-700 mb-4 flex items-center gap-2">
                  <Settings className="w-4 h-4" />
                  Challenge Management
                </h3>
                <Link href="/admin/challenges">
                  <div className="glass-card rounded-xl p-4 hover:shadow-xl transform hover:scale-105 transition-all duration-300 cursor-pointer group bg-gradient-to-r from-purple-50/80 to-indigo-50/80 border border-purple-200/60">
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-3">
                        <div className="w-10 h-10 bg-gradient-to-br from-purple-500 to-indigo-500 rounded-xl flex items-center justify-center group-hover:shadow-lg transition-all">
                          <Edit3 className="w-5 h-5 text-white" />
                        </div>
                        <div>
                          <h4 className="font-semibold text-neutral-800">Manage Challenges</h4>
                          <p className="text-xs text-neutral-600">Edit names and rulesets for all challenges</p>
                        </div>
                      </div>
                      <ArrowRight className="w-5 h-5 text-purple-400 group-hover:text-purple-600 group-hover:translate-x-1 transition-all" />
                    </div>
                  </div>
                </Link>
                <Link href="/admin/schedules">
                  <div className="glass-card rounded-xl p-4 hover:shadow-xl transform hover:scale-105 transition-all duration-300 cursor-pointer group bg-gradient-to-r from-blue-50/80 to-cyan-50/80 border border-blue-200/60 mt-4">
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-3">
                        <div className="w-10 h-10 bg-gradient-to-br from-blue-500 to-cyan-500 rounded-xl flex items-center justify-center group-hover:shadow-lg transition-all">
                          <Calendar className="w-5 h-5 text-white" />
                        </div>
                        <div>
                          <h4 className="font-semibold text-neutral-800">Scheduled Challenges</h4>
                          <p className="text-xs text-neutral-600">View and manage scheduled creations</p>
                        </div>
                      </div>
                      <ArrowRight className="w-5 h-5 text-blue-400 group-hover:text-blue-600 group-hover:translate-x-1 transition-all" />
                    </div>
                  </div>
                </Link>
              </div>
            </div>

            {/* Enhanced Active Challenge Management Section */}
            <div className="glass-card-enhanced rounded-2xl p-8 border border-blue-200/60 bg-gradient-to-br from-blue-50/80 to-indigo-50/80 backdrop-blur-lg flex flex-col">
              <div className="flex items-center justify-between mb-6">
                <div className="flex items-center gap-3">
                  <div className="p-3 bg-gradient-to-br from-blue-500 to-indigo-500 rounded-xl">
                    <Zap className="w-6 h-6 text-white" />
                  </div>
                  <h2 className="text-xl font-semibold text-neutral-800">Active Challenge Management</h2>
                </div>
                
                {/* Enhanced bulk update controls */}
                <div className="flex items-center gap-3">
                  {bulkUpdateState.isRunning && (
                    <>
                      <button
                        onClick={toggleBulkUpdatePause}
                        className="flex items-center gap-2 bg-gradient-to-r from-orange-500 to-amber-500 hover:from-orange-600 hover:to-amber-600 text-white px-4 py-2 rounded-xl text-sm font-medium transition-all shadow-lg hover:shadow-xl transform hover:scale-105"
                      >
                        {bulkUpdateState.isPaused ? (
                          <>
                            <Play className="w-4 h-4" />
                            Resume
                          </>
                        ) : (
                          <>
                            <Pause className="w-4 h-4" />
                            Pause
                          </>
                        )}
                      </button>
                      <button
                        onClick={cancelBulkUpdate}
                        className="flex items-center gap-2 bg-gradient-to-r from-red-500 to-pink-500 hover:from-red-600 hover:to-pink-600 text-white px-4 py-2 rounded-xl text-sm font-medium transition-all shadow-lg hover:shadow-xl transform hover:scale-105"
                      >
                        <X className="w-4 h-4" />
                        Cancel
                      </button>
                    </>
                  )}
                  
                  <button
                    onClick={handleUpdateAllActive}
                    disabled={bulkUpdateState.isRunning || activeChallenges.length === 0}
                    className="flex items-center gap-2 bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 disabled:from-gray-400 disabled:to-gray-500 text-white px-4 py-2 rounded-xl font-medium transition-all shadow-lg hover:shadow-xl transform hover:scale-105 disabled:transform-none disabled:cursor-not-allowed"
                  >
                    {bulkUpdateState.isRunning ? (
                      <>
                        <Loader2 className="w-4 h-4 animate-spin" />
                        <span>
                          {bulkUpdateState.isPaused ? 'Paused' : 'Updating'} 
                          ({bulkUpdateState.progress.current}/{bulkUpdateState.progress.total})
                        </span>
                      </>
                    ) : (
                      <>
                        <RefreshCw className="w-4 h-4" />
                        <span>Update All</span>
                      </>
                    )}
                  </button>
                </div>
              </div>

              {/* Enhanced Progress indicator for bulk updates */}
              {bulkUpdateState.isRunning && (
                <div className="mb-6 glass-card rounded-xl p-6 border border-blue-200/60 bg-gradient-to-r from-blue-100/80 to-indigo-100/80">
                  <div className="flex items-center justify-between mb-3">
                    <span className="text-sm font-semibold text-blue-800 flex items-center gap-2">
                      {bulkUpdateState.isPaused ? (
                        <>
                          <Pause className="w-4 h-4" />
                          Paused
                        </>
                      ) : (
                        <>
                          <Loader2 className="w-4 h-4 animate-spin" />
                          Updating Challenges
                        </>
                      )}
                    </span>
                    <span className="text-sm text-blue-600 font-medium">
                      {bulkUpdateState.progress.current}/{bulkUpdateState.progress.total}
                    </span>
                  </div>
                  
                  {/* Enhanced Progress bar */}
                  <div className="w-full bg-blue-200/60 rounded-full h-3 mb-3 overflow-hidden">
                    <div 
                      className="bg-gradient-to-r from-blue-600 to-indigo-600 h-3 rounded-full transition-all duration-300 shadow-sm"
                      style={{ 
                        width: `${(bulkUpdateState.progress.current / bulkUpdateState.progress.total) * 100}%` 
                      }}
                    ></div>
                  </div>
                  
                  {bulkUpdateState.currentChallenge && (
                    <p className="text-xs text-blue-700 bg-white/60 rounded-lg px-3 py-2">
                      <span className="font-medium">Currently updating:</span> {bulkUpdateState.currentChallenge.name} (Room {bulkUpdateState.currentChallenge.room_id})
                    </p>
                  )}
                </div>
              )}

              {/* Enhanced Main content area */}
              <div className="flex-1">
                {activeChallenges.length === 0 ? (
                  <div className="text-center py-12 glass-card rounded-xl bg-white/40">
                    <div className="w-16 h-16 mx-auto mb-4 bg-gradient-to-br from-neutral-300 to-neutral-400 rounded-2xl flex items-center justify-center">
                      <Users className="w-8 h-8 text-white" />
                    </div>
                    <p className="text-neutral-600 font-medium mb-2">No active challenges</p>
                    <p className="text-sm text-neutral-500">Add a new challenge to get started!</p>
                  </div>
                ) : (
                  <div className="space-y-4">
                    {activeChallenges.slice(0, 5).map(challenge => {
                      const lastUpdated = getUTCTimestamp(challenge.updated_at);
                      const isStale = lastUpdated && (Date.now() - lastUpdated) > 10 * 60 * 1000;
                      const needsUpdate = lastUpdated && (Date.now() - lastUpdated) > 5 * 60 * 1000;
                      const rulesetName = generateRulesetDisplayName(challenge);
                      
                      return (
                        <div key={challenge.id} className="glass-card rounded-xl p-4 bg-white/60 border border-neutral-200/60 hover:border-neutral-300/60 hover:shadow-lg transition-all">
                          <div className="flex items-center justify-between">
                            <div className="flex-1 min-w-0">
                              <div className="flex items-start gap-2 mb-2">
                                <h4 className="font-semibold text-neutral-800 text-sm flex-1 leading-tight">
                                  {challenge.custom_name || challenge.name}
                                  {challenge.custom_name && (
                                    <span className="ml-2 inline-flex items-center gap-1 text-xs bg-purple-100 text-purple-700 px-2 py-1 rounded-full font-medium">
                                      <Sparkles className="w-3 h-3" />
                                      Custom
                                    </span>
                                  )}
                                  {/* Enhanced Ruleset indicator */}
                                  {challenge.has_ruleset && rulesetName && (
                                    <span className="ml-2 inline-flex items-center gap-1 text-xs bg-gradient-to-r from-yellow-100 to-amber-100 text-yellow-800 px-2 py-1 rounded-full font-medium border border-yellow-200/60">
                                      <Crown className="w-3 h-3" />
                                      {rulesetName}
                                    </span>
                                  )}
                                </h4>
                              </div>
                              <div className="flex items-center gap-4 text-xs text-neutral-600 mb-2">
                                <span className="flex items-center gap-1">
                                  <span className="w-2 h-2 bg-primary-500 rounded-full"></span>
                                  Room ID: <span className="font-mono font-medium">{challenge.room_id}</span>
                                </span>
                                <span className="flex items-center gap-1">
                                  <Users className="w-3 h-3" />
                                  {challenge.host}
                                </span>
                                <span className="flex items-center gap-1">
                                  <BarChart3 className="w-3 h-3" />
                                  {challenge.participant_count || 0} participants
                                </span>
                                <span className="flex items-center gap-1">
                                  <Music className="w-3 h-3" />
                                  {challenge.playlists?.length || 0} maps
                                </span>
                              </div>
                              <div className="text-xs text-neutral-500 bg-white/40 rounded-lg px-2 py-1 inline-block">
                                <Calendar className="w-3 h-3 inline mr-1" />
                                Last updated: {formatUTCDateTime(challenge.updated_at)}
                              </div>
                            </div>
                            
                            <div className="flex items-center gap-2 ml-4">
                              {/* Enhanced Ruleset Management Button */}
                              <button
                                onClick={() => handleManageRuleset(challenge)}
                                disabled={bulkUpdateState.isRunning}
                                className="px-3 py-2 bg-gradient-to-r from-yellow-50 to-amber-50 text-yellow-700 border border-yellow-200/60 rounded-xl hover:from-yellow-100 hover:to-amber-100 hover:shadow-lg transform hover:scale-105 transition-all text-xs font-medium flex items-center gap-1 disabled:opacity-50 disabled:transform-none"
                                title="Manage Ruleset"
                              >
                                <Target className="w-3 h-3" />
                                <span>Ruleset</span>
                              </button>
                              
                              {/* Enhanced Update Button */}
                              <button
                                onClick={() => handleUpdateSingleChallenge(challenge.room_id)}
                                disabled={bulkUpdateState.isRunning || updatingChallenges.has(challenge.room_id)}
                                className={`px-3 py-2 rounded-xl text-xs font-medium transition-all border flex items-center gap-1 shadow-sm hover:shadow-lg transform hover:scale-105 disabled:transform-none ${
                                  isStale 
                                    ? 'bg-gradient-to-r from-yellow-50 to-amber-50 text-yellow-700 border-yellow-200/60 hover:from-yellow-100 hover:to-amber-100' 
                                    : needsUpdate
                                    ? 'bg-gradient-to-r from-blue-50 to-indigo-50 text-blue-700 border-blue-200/60 hover:from-blue-100 hover:to-indigo-100'
                                    : 'bg-gradient-to-r from-green-50 to-emerald-50 text-green-700 border-green-200/60 hover:from-green-100 hover:to-emerald-100'
                                } disabled:opacity-50 disabled:cursor-not-allowed`}
                              >
                                {updatingChallenges.has(challenge.room_id) ? (
                                  <Loader2 className="w-3 h-3 animate-spin" />
                                ) : (
                                  <RefreshCw className="w-3 h-3" />
                                )}
                                <span>Update</span>
                              </button>
                            </div>
                          </div>
                        </div>
                      );
                    })}
                    
                    {activeChallenges.length > 5 && (
                      <div className="text-center pt-4 border-t border-blue-200/60">
                        <Link href="/admin/challenges?status=active">
                          <span className="text-sm text-blue-600 hover:text-blue-700 font-medium cursor-pointer flex items-center justify-center gap-2 hover:gap-3 transition-all">
                            View all {activeChallenges.length} active challenges 
                            <ArrowRight className="w-4 h-4" />
                          </span>
                        </Link>
                      </div>
                    )}
                  </div>
                )}
              </div>

              {/* Enhanced Notes Section */}
              <div className="mt-auto pt-6 border-t border-blue-200/60">
                <div className="flex items-center gap-2 mb-4">
                  <div className="p-2 bg-gradient-to-br from-blue-500 to-indigo-500 rounded-lg">
                    <Info className="w-4 h-4 text-white" />
                  </div>
                  <h4 className="font-semibold text-neutral-800">Challenge Management Notes</h4>
                </div>
                <div className="text-sm text-neutral-600 space-y-2 glass-card rounded-xl p-4 bg-blue-50/50 border border-blue-200/60">
                  <p className="flex items-start gap-2">
                    <span className="text-blue-500 mt-1">‚Ä¢</span>
                    <span>Only public multiplayer rooms can be tracked</span>
                  </p>
                  <p className="flex items-start gap-2">
                    <span className="text-blue-500 mt-1">‚Ä¢</span>
                    <span>Data updates automatically when users view challenges (4-minute cooldown)</span>
                  </p>
                  <p className="flex items-start gap-2">
                    <span className="text-blue-500 mt-1">‚Ä¢</span>
                    <span>Use "Update All" to force refresh all active challenges (can be paused/cancelled)</span>
                  </p>
                  <p className="flex items-start gap-2">
                    <span className="text-blue-500 mt-1">‚Ä¢</span>
                    <span>New challenges are automatically assigned to the current season (6-month cycles)</span>
                  </p>
                  <p className="flex items-start gap-2">
                    <span className="text-blue-500 mt-1">‚Ä¢</span>
                    <span>Use "Manage Challenges" to edit names and rulesets for all challenges</span>
                  </p>
                  <p className="flex items-start gap-2">
                    <span className="text-blue-500 mt-1">‚Ä¢</span>
                    <span>Ruleset names are auto-generated from selected mods and settings</span>
                  </p>
                </div>
              </div>
            </div>

            {/* Enhanced Partners Management Section */}
            <div className="glass-card-enhanced rounded-2xl p-8 border border-purple-200/60 bg-gradient-to-br from-purple-50/80 to-pink-50/80 backdrop-blur-lg col-span-1 lg:col-span-2">
              <div className="flex items-center justify-between mb-8">
                <div className="flex items-center gap-3">
                  <div className="p-3 bg-gradient-to-br from-purple-500 to-pink-500 rounded-xl">
                    <PartnersIcon className="w-6 h-6 text-white" />
                  </div>
                  <h2 className="text-xl font-semibold text-neutral-800">Partners Management</h2>
                </div>
                
                <button
                  onClick={() => {
                    setShowPartnerForm(true);
                    setEditingPartner(null);
                    setPartnerForm({
                      name: '',
                      icon_url: '',
                      description: '',
                      is_active: true,
                      display_order: partners.length
                    });
                  }}
                  className="flex items-center gap-2 bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 text-white px-6 py-3 rounded-xl font-medium transition-all shadow-lg hover:shadow-xl transform hover:scale-105"
                >
                  <Plus className="w-4 h-4" />
                  Add Partner
                </button>
              </div>

              {/* Enhanced Partner Form Modal */}
              {showPartnerForm && (
                <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4">
                  <div className="glass-card-enhanced rounded-3xl p-8 max-w-md w-full shadow-2xl border border-purple-200/60 bg-gradient-to-br from-white/95 to-purple-50/95">
                    <div className="flex items-center gap-3 mb-6">
                      <div className="p-3 bg-gradient-to-br from-purple-500 to-pink-500 rounded-xl">
                        <PartnersIcon className="w-6 h-6 text-white" />
                      </div>
                      <h3 className="text-lg font-semibold text-neutral-800">
                        {editingPartner ? 'Edit Partner' : 'Add New Partner'}
                      </h3>
                    </div>
                    
                    <form onSubmit={handlePartnerSubmit} className="space-y-5">
                      <div>
                        <label className="block text-sm font-medium text-neutral-700 mb-2">
                          Partner Name *
                        </label>
                        <input
                          type="text"
                          value={partnerForm.name}
                          onChange={(e) => setPartnerForm({...partnerForm, name: e.target.value})}
                          className="w-full px-4 py-3 border border-neutral-300/60 rounded-xl focus:outline-none focus:border-purple-500 focus:ring-2 focus:ring-purple-200 transition-all bg-white/80 backdrop-blur-sm"
                          required
                        />
                      </div>
                      
                      <div>
                        <label className="block text-sm font-medium text-neutral-700 mb-2">
                          Icon URL *
                        </label>
                        <input
                          type="url"
                          value={partnerForm.icon_url}
                          onChange={(e) => setPartnerForm({...partnerForm, icon_url: e.target.value})}
                          className="w-full px-4 py-3 border border-neutral-300/60 rounded-xl focus:outline-none focus:border-purple-500 focus:ring-2 focus:ring-purple-200 transition-all bg-white/80 backdrop-blur-sm"
                          placeholder="https://example.com/icon.png"
                          required
                        />
                      </div>
                      
                      <div>
                        <label className="block text-sm font-medium text-neutral-700 mb-2">
                          Description
                        </label>
                        <textarea
                          value={partnerForm.description}
                          onChange={(e) => setPartnerForm({...partnerForm, description: e.target.value})}
                          className="w-full px-4 py-3 border border-neutral-300/60 rounded-xl focus:outline-none focus:border-purple-500 focus:ring-2 focus:ring-purple-200 transition-all bg-white/80 backdrop-blur-sm"
                          rows="3"
                          maxLength="500"
                        />
                      </div>
                      
                      <div className="grid grid-cols-2 gap-4">
                        <div>
                          <label className="block text-sm font-medium text-neutral-700 mb-2">
                            Display Order
                          </label>
                          <input
                            type="number"
                            value={partnerForm.display_order}
                            onChange={(e) => setPartnerForm({...partnerForm, display_order: parseInt(e.target.value) || 0})}
                            className="w-full px-4 py-3 border border-neutral-300/60 rounded-xl focus:outline-none focus:border-purple-500 focus:ring-2 focus:ring-purple-200 transition-all bg-white/80 backdrop-blur-sm"
                            min="0"
                          />
                        </div>
                        
                        <div className="flex items-end">
                          <label className="flex items-center gap-3 w-full p-3 bg-purple-50/60 rounded-xl border border-purple-200/60 cursor-pointer hover:bg-purple-100/60 transition-colors">
                            <input
                              type="checkbox"
                              checked={partnerForm.is_active}
                              onChange={(e) => setPartnerForm({...partnerForm, is_active: e.target.checked})}
                              className="w-4 h-4 text-purple-600 rounded focus:ring-purple-500"
                            />
                            <span className="text-sm font-medium text-neutral-700">Active</span>
                          </label>
                        </div>
                      </div>
                      
                      <div className="flex gap-3 mt-8">
                        <button
                          type="submit"
                          className="flex-1 bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 text-white px-6 py-3 rounded-xl font-medium transition-all shadow-lg hover:shadow-xl transform hover:scale-105"
                        >
                          {editingPartner ? 'Update' : 'Create'} Partner
                        </button>
                        <button
                          type="button"
                          onClick={() => {
                            setShowPartnerForm(false);
                            setEditingPartner(null);
                          }}
                          className="flex-1 bg-gradient-to-r from-neutral-200 to-neutral-300 hover:from-neutral-300 hover:to-neutral-400 text-neutral-700 px-6 py-3 rounded-xl font-medium transition-all shadow-lg hover:shadow-xl transform hover:scale-105"
                        >
                          Cancel
                        </button>
                      </div>
                    </form>
                  </div>
                </div>
              )}

              {/* Enhanced Partners List */}
              {loadingPartners ? (
                <div className="text-center py-12 glass-card rounded-xl bg-white/40">
                  <Loader2 className="w-8 h-8 animate-spin text-purple-500 mx-auto mb-4" />
                  <p className="text-neutral-600">Loading partners...</p>
                </div>
              ) : partners.length === 0 ? (
                <div className="text-center py-12 glass-card rounded-xl bg-white/40">
                  <div className="w-16 h-16 mx-auto mb-4 bg-gradient-to-br from-neutral-300 to-neutral-400 rounded-2xl flex items-center justify-center">
                    <PartnersIcon className="w-8 h-8 text-white" />
                  </div>
                  <p className="text-neutral-600 font-medium mb-2">No partners yet</p>
                  <p className="text-sm text-neutral-500">Add your first partner to get started!</p>
                </div>
              ) : (
                <div className="space-y-4">
                  {partners.map((partner) => (
                    <div key={partner.id} className="glass-card rounded-xl p-6 bg-white/60 border border-neutral-200/60 hover:border-neutral-300/60 hover:shadow-lg transition-all">
                      <div className="flex items-center justify-between">
                        <div className="flex items-center gap-4">
                          <div className="relative">
                            <img
                              src={partner.icon_url}
                              alt={partner.name}
                              className="w-16 h-16 rounded-xl object-cover shadow-lg"
                              onError={(e) => {
                                e.target.onerror = null;
                                e.target.src = `https://ui-avatars.com/api/?name=${encodeURIComponent(partner.name)}&background=9333ea&color=fff&size=128`;
                              }}
                            />
                            <div className={`absolute -bottom-1 -right-1 w-5 h-5 rounded-full border-2 border-white ${partner.is_active ? 'bg-green-500' : 'bg-gray-400'}`}></div>
                          </div>
                          <div>
                            <h4 className="font-semibold text-neutral-800 text-lg">{partner.name}</h4>
                            <div className="flex items-center gap-4 text-sm text-neutral-600 mt-1">
                              <span className="flex items-center gap-1">
                                <GripVertical className="w-4 h-4" />
                                Order: {partner.display_order}
                              </span>
                              <span className={`px-2 py-1 rounded-full text-xs font-medium ${partner.is_active ? 'bg-green-100 text-green-700' : 'bg-neutral-100 text-neutral-600'}`}>
                                {partner.is_active ? 'Active' : 'Inactive'}
                              </span>
                            </div>
                            {partner.description && (
                              <p className="text-sm text-neutral-600 mt-2 max-w-md">{partner.description}</p>
                            )}
                          </div>
                        </div>
                        
                        <div className="flex items-center gap-3">
                          <button
                            onClick={() => handleTogglePartnerStatus(partner)}
                            className={`p-3 rounded-xl transition-all shadow-lg hover:shadow-xl transform hover:scale-105 ${
                              partner.is_active 
                                ? 'bg-gradient-to-r from-yellow-50 to-amber-50 text-yellow-700 hover:from-yellow-100 hover:to-amber-100' 
                                : 'bg-gradient-to-r from-green-50 to-emerald-50 text-green-700 hover:from-green-100 hover:to-emerald-100'
                            }`}
                            title={partner.is_active ? 'Deactivate' : 'Activate'}
                          >
                            {partner.is_active ? <EyeOff className="w-5 h-5" /> : <Eye className="w-5 h-5" />}
                          </button>
                          
                          <button
                            onClick={() => {
                              setEditingPartner(partner);
                              setPartnerForm({
                                name: partner.name,
                                icon_url: partner.icon_url,
                                description: partner.description || '',
                                is_active: partner.is_active,
                                display_order: partner.display_order
                              });
                              setShowPartnerForm(true);
                            }}
                            className="p-3 bg-gradient-to-r from-blue-50 to-indigo-50 text-blue-700 rounded-xl hover:from-blue-100 hover:to-indigo-100 transition-all shadow-lg hover:shadow-xl transform hover:scale-105"
                          >
                            <Edit3 className="w-5 h-5" />
                          </button>
                          
                          <button
                            onClick={() => handleDeletePartner(partner.id)}
                            className="p-3 bg-gradient-to-r from-red-50 to-pink-50 text-red-700 rounded-xl hover:from-red-100 hover:to-pink-100 transition-all shadow-lg hover:shadow-xl transform hover:scale-105"
                          >
                            <Trash2 className="w-5 h-5" />
                          </button>
                        </div>
                      </div>
                    </div>
                  ))}
                  
                  <div className="text-center pt-6 border-t border-purple-200/60">
                    <Link href="/partners">
                      <span className="text-sm text-purple-600 hover:text-purple-700 font-medium cursor-pointer flex items-center justify-center gap-2 hover:gap-3 transition-all">
                        View partners page 
                        <ArrowRight className="w-4 h-4" />
                      </span>
                    </Link>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Ruleset Manager Modal */}
        {showRulesetManager && selectedChallengeForRuleset && (
          <RulesetManager
            challengeId={selectedChallengeForRuleset.id}
            onClose={() => {
              setShowRulesetManager(false);
              setSelectedChallengeForRuleset(null);
            }}
            onSuccess={handleRulesetSuccess}
          />
        )}
      </div>
    </Layout>
  );
}


================================================
FILE: frontend/pages/bulk-update.js
================================================
import React, { useState } from 'react';
import { Play, Pause, RotateCcw, CheckCircle, XCircle, AlertCircle, Clock } from 'lucide-react';

export default function AdminBulkUpdate() {
  const [isRunning, setIsRunning] = useState(false);
  const [isDryRun, setIsDryRun] = useState(true);
  const [results, setResults] = useState(null);
  const [currentProgress, setCurrentProgress] = useState(null);
  const [limit, setLimit] = useState('');

  const runBulkUpdate = async () => {
    setIsRunning(true);
    setResults(null);
    setCurrentProgress({ current: 0, total: 0, status: 'Starting...' });

    try {
      const response = await fetch('/api/admin/bulk-update-challenges', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ 
          dryRun: isDryRun,
          limit: limit ? parseInt(limit) : null
        })
      });

      const data = await response.json();
      setResults(data);
      setCurrentProgress(null);

    } catch (error) {
      setResults({ 
        error: 'Failed to run bulk update', 
        details: error.message 
      });
      setCurrentProgress(null);
    } finally {
      setIsRunning(false);
    }
  };

  const getStatusIcon = (status) => {
    switch (status) {
      case 'updated':
      case 'analyzed':
        return <CheckCircle className="w-4 h-4 text-green-500" />;
      case 'failed':
      case 'error':
        return <XCircle className="w-4 h-4 text-red-500" />;
      case 'skipped':
        return <AlertCircle className="w-4 h-4 text-yellow-500" />;
      default:
        return <Clock className="w-4 h-4 text-gray-500" />;
    }
  };

  const getStatusColor = (status) => {
    switch (status) {
      case 'updated':
      case 'analyzed':
        return 'text-green-700 bg-green-50 border-green-200';
      case 'failed':
      case 'error':
        return 'text-red-700 bg-red-50 border-red-200';
      case 'skipped':
        return 'text-yellow-700 bg-yellow-50 border-yellow-200';
      default:
        return 'text-gray-700 bg-gray-50 border-gray-200';
    }
  };

  return (
    <div className="max-w-6xl mx-auto p-6">
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6 mb-6">
        <h1 className="text-2xl font-bold text-gray-900 mb-4">
          Bulk Update Challenges
        </h1>
        <p className="text-gray-600 mb-6">
          Update submission dates for all challenges by re-fetching data from osu! API.
        </p>

        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Mode
            </label>
            <div className="space-y-2">
              <label className="flex items-center">
                <input
                  type="radio"
                  checked={isDryRun}
                  onChange={() => setIsDryRun(true)}
                  className="mr-2"
                  disabled={isRunning}
                />
                <span className="text-sm">Dry Run (analyze only)</span>
              </label>
              <label className="flex items-center">
                <input
                  type="radio"
                  checked={!isDryRun}
                  onChange={() => setIsDryRun(false)}
                  className="mr-2"
                  disabled={isRunning}
                />
                <span className="text-sm">Actually Update</span>
              </label>
            </div>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Limit (optional)
            </label>
            <input
              type="number"
              value={limit}
              onChange={(e) => setLimit(e.target.value)}
              placeholder="e.g., 10"
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              disabled={isRunning}
            />
            <p className="text-xs text-gray-500 mt-1">
              Leave empty to process all challenges
            </p>
          </div>

          <div className="flex items-end">
            <button
              onClick={runBulkUpdate}
              disabled={isRunning}
              className={`w-full flex items-center justify-center px-4 py-2 rounded-md font-medium transition-colors ${
                isRunning
                  ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                  : isDryRun
                  ? 'bg-blue-600 hover:bg-blue-700 text-white'
                  : 'bg-red-600 hover:bg-red-700 text-white'
              }`}
            >
              {isRunning ? (
                <>
                  <Pause className="w-4 h-4 mr-2" />
                  Running...
                </>
              ) : (
                <>
                  <Play className="w-4 h-4 mr-2" />
                  {isDryRun ? 'Analyze' : 'Update'} Challenges
                </>
              )}
            </button>
          </div>
        </div>

        {!isDryRun && (
          <div className="bg-red-50 border border-red-200 rounded-md p-4 mb-4">
            <div className="flex">
              <AlertCircle className="w-5 h-5 text-red-400 mr-2 mt-0.5" />
              <div>
                <h3 className="text-sm font-medium text-red-800">
                  Warning: This will make many API calls
                </h3>
                <p className="text-sm text-red-700 mt-1">
                  This operation will consume significant API quota. Make sure you have enough remaining calls.
                </p>
              </div>
            </div>
          </div>
        )}
      </div>

      {currentProgress && (
        <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6 mb-6">
          <h2 className="text-lg font-semibold text-gray-900 mb-4">Progress</h2>
          <div className="space-y-2">
            <div className="flex justify-between text-sm">
              <span>Status: {currentProgress.status}</span>
              <span>{currentProgress.current}/{currentProgress.total}</span>
            </div>
            <div className="w-full bg-gray-200 rounded-full h-2">
              <div 
                className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                style={{ 
                  width: currentProgress.total > 0 
                    ? `${(currentProgress.current / currentProgress.total) * 100}%` 
                    : '0%' 
                }}
              ></div>
            </div>
          </div>
        </div>
      )}

      {results && (
        <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
          <div className="flex items-center justify-between mb-6">
            <h2 className="text-lg font-semibold text-gray-900">Results</h2>
            <button
              onClick={() => setResults(null)}
              className="text-gray-400 hover:text-gray-600"
            >
              <RotateCcw className="w-4 h-4" />
            </button>
          </div>

          {results.error ? (
            <div className="bg-red-50 border border-red-200 rounded-md p-4">
              <h3 className="text-sm font-medium text-red-800">Error</h3>
              <p className="text-sm text-red-700 mt-1">{results.error}</p>
              {results.details && (
                <p className="text-xs text-red-600 mt-2">{results.details}</p>
              )}
            </div>
          ) : (
            <>
              <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                <div className="text-center p-3 bg-gray-50 rounded-lg">
                  <div className="text-2xl font-bold text-gray-900">
                    {results.summary?.totalChallenges || 0}
                  </div>
                  <div className="text-sm text-gray-600">Total</div>
                </div>
                <div className="text-center p-3 bg-green-50 rounded-lg">
                  <div className="text-2xl font-bold text-green-600">
                    {results.summary?.totalUpdated || 0}
                  </div>
                  <div className="text-sm text-gray-600">
                    {isDryRun ? 'Analyzed' : 'Updated'}
                  </div>
                </div>
                <div className="text-center p-3 bg-red-50 rounded-lg">
                  <div className="text-2xl font-bold text-red-600">
                    {results.summary?.totalFailed || 0}
                  </div>
                  <div className="text-sm text-gray-600">Failed</div>
                </div>
                <div className="text-center p-3 bg-blue-50 rounded-lg">
                  <div className="text-2xl font-bold text-blue-600">
                    {results.summary?.totalApiCalls || 0}
                  </div>
                  <div className="text-sm text-gray-600">API Calls</div>
                </div>
              </div>

              {results.apiUsage && (
                <div className="bg-blue-50 border border-blue-200 rounded-md p-4 mb-6">
                  <h3 className="text-sm font-medium text-blue-800 mb-2">
                    API Usage: {results.apiUsage.percentage}%
                  </h3>
                  <div className="w-full bg-blue-200 rounded-full h-2">
                    <div 
                      className="bg-blue-600 h-2 rounded-full"
                      style={{ width: `${Math.min(parseFloat(results.apiUsage.percentage), 100)}%` }}
                    ></div>
                  </div>
                </div>
              )}

              <div className="space-y-2">
                <h3 className="font-medium text-gray-900">Challenge Details</h3>
                <div className="max-h-96 overflow-y-auto border border-gray-200 rounded-md">
                  {results.results?.map((result, index) => (
                    <div key={index} className={`p-3 border-b border-gray-100 last:border-b-0`}>
                      <div className="flex items-center justify-between">
                        <div className="flex items-center space-x-3">
                          {getStatusIcon(result.status)}
                          <div>
                            <div className="font-medium text-gray-900">
                              {result.name || `Room ${result.roomId}`}
                            </div>
                            <div className="text-sm text-gray-500">
                              Room ID: {result.roomId}
                            </div>
                          </div>
                        </div>
                        <div className="text-right">
                          <span className={`px-2 py-1 text-xs font-medium rounded-full border ${getStatusColor(result.status)}`}>
                            {result.status}
                          </span>
                          {result.estimatedScores && (
                            <div className="text-xs text-gray-500 mt-1">
                              ~{result.estimatedScores} scores
                            </div>
                          )}
                        </div>
                      </div>
                      {result.error && (
                        <div className="mt-2 text-sm text-red-600">
                          Error: {result.error}
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            </>
          )}
        </div>
      )}
    </div>
  );
}


================================================
FILE: frontend/pages/challenges.js
================================================
import { useState, useEffect } from 'react';
import Link from 'next/link';
import useSWR from 'swr';
import Layout from '../components/Layout';
import Loading from '../components/Loading';
import ChallengeCard from '../components/ChallengeCard';
import SeasonSelector from '../components/SeasonSelector';
import { 
  Trophy, History, Sparkles, RefreshCw, 
  Users, Music, Clock, AlertCircle
} from 'lucide-react';

const fetcher = async (url) => {
  const res = await fetch(url);
  if (!res.ok) {
    throw new Error('API request failed');
  }
  const data = await res.json();
  return data.data || data;
};

export default function ChallengesPage() {
  const [selectedSeason, setSelectedSeason] = useState(null);
  const [currentSeason, setCurrentSeason] = useState(null);
  const [historicalChallenges, setHistoricalChallenges] = useState([]);
  const [loadingHistorical, setLoadingHistorical] = useState(false);
  const [isRefreshing, setIsRefreshing] = useState(false);

  // Fetch active challenges with simple SWR
  const {
    data: activeChallengesData,
    error,
    mutate: refreshActiveChallenges,
    isValidating
  } = useSWR('/api/challenges?active=true', fetcher, {
    refreshInterval: 300000, // Auto-refresh every 5 minutes
    revalidateOnFocus: false,
    revalidateOnReconnect: true,
    dedupingInterval: 60000,
  });

  const activeChallenges = activeChallengesData?.challenges || [];
  const summary = activeChallengesData?.summary;
  const loading = !activeChallengesData && !error;

  useEffect(() => {
    fetchInitialData();
  }, []);

  useEffect(() => {
    if (selectedSeason?.id) {
      fetchHistoricalChallenges(selectedSeason.id);
    }
  }, [selectedSeason]);

  const fetchInitialData = async () => {
    try {
      const seasonResponse = await fetch('/api/seasons/current');
      if (seasonResponse.ok) {
        const seasonData = await seasonResponse.json();
        if (seasonData.success) {
          const responseData = seasonData.data || seasonData;
          if (responseData.season) {
            setCurrentSeason(responseData.season);
            setSelectedSeason(responseData.season);
          }
        }
      }
    } catch (err) {
      console.error('Fetch error:', err);
    }
  };

  const fetchHistoricalChallenges = async (seasonId) => {
    try {
      setLoadingHistorical(true);
      const response = await fetch(`/api/challenges?season_id=${seasonId}&active=false`);
      
      if (!response.ok) {
        throw new Error(`Failed to fetch historical challenges: ${response.status}`);
      }
      
      const data = await response.json();
      
      let challenges = [];
      if (data.success && data.data?.challenges) {
        challenges = data.data.challenges;
      } else if (data.challenges) {
        challenges = data.challenges;
      } else if (data.data && Array.isArray(data.data)) {
        challenges = data.data;
      }
      
      setHistoricalChallenges(challenges);
    } catch (err) {
      console.error('Historical challenges fetch error:', err);
      setHistoricalChallenges([]);
    } finally {
      setLoadingHistorical(false);
    }
  };

  const handleRefresh = async () => {
    setIsRefreshing(true);
    await refreshActiveChallenges();
    // Keep animation visible for at least 600ms for smooth UX
    setTimeout(() => {
      setIsRefreshing(false);
    }, 600);
  };

  const getChallengeType = (challenge) => {
    const mapCount = challenge.playlists?.length || 0;
    return mapCount === 1 ? 'weekly' : 'monthly';
  };

  const getFilteredChallenges = (challenges) => {
    return challenges.sort((a, b) => {
      const dateA = new Date(a.end_date || a.start_date || a.created_at || 0);
      const dateB = new Date(b.end_date || b.start_date || b.created_at || 0);
      return dateB.getTime() - dateA.getTime();
    });
  };

  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric',
      year: 'numeric'
    });
  };

  const filteredChallenges = getFilteredChallenges(historicalChallenges);

  if (loading) {
    return (
      <Layout>
        <Loading.FullPage message="Loading challenges..." />
      </Layout>
    );
  }

  return (
    <Layout>
      <div className="min-h-screen py-4 sm:py-6 lg:py-8">
        <div className="max-w-7xl mx-auto px-3 sm:px-4 lg:px-6">
          
          {/* Active Challenges Section */}
          <div className="mb-8 sm:mb-12 lg:mb-16">
            <div className="mb-6 sm:mb-8 lg:mb-10">
              <div className="flex flex-col lg:flex-row lg:items-start lg:justify-between gap-4 lg:gap-8">
                <div className="text-center lg:text-left">
                  <div className="flex flex-col sm:flex-row items-center sm:items-start gap-3 sm:gap-4 mb-4">
                    <div className="relative">
                      <Trophy className="w-8 h-8 sm:w-10 sm:h-10 text-white icon-shadow-adaptive-lg" />
                      <Sparkles className="w-4 h-4 sm:w-5 sm:h-5 text-yellow-400 absolute -top-1 -right-1 icon-shadow-adaptive-sm" />
                    </div>
                    <h1 className="text-2xl sm:text-3xl lg:text-4xl font-bold text-white text-shadow-adaptive-lg">
                      Active Challenges
                    </h1>
                  </div>
                  <p className="text-white/85 text-sm sm:text-base lg:text-lg max-w-none lg:max-w-2xl text-shadow-adaptive px-4 sm:px-0">
                    Jump into any of our currently active challenges and compete with players worldwide for the top spots!
                  </p>
                </div>
              </div>
            </div>

            {/* Data Freshness Info */}
            {summary && (
              <div className="mb-4 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2">
                <div className="flex items-center gap-2 text-sm text-white/70">
                  <Clock className="w-4 h-4 icon-shadow-adaptive-sm" />
                  <span className="text-shadow-adaptive-sm">
                    {summary.fresh || 0} fresh, {summary.stale || 0} updating
                  </span>
                </div>
                <button
                  onClick={handleRefresh}
                  disabled={isRefreshing || isValidating}
                  className="flex items-center gap-2 px-3 py-1.5 text-sm text-white/70 hover:text-white transition-all glass-1 rounded-full disabled:opacity-50 hover:scale-105 active:scale-95"
                >
                  <RefreshCw className={`w-4 h-4 icon-shadow-adaptive-sm transition-transform duration-500 ${isRefreshing || isValidating ? 'animate-spin' : ''}`} />
                  <span className="transition-opacity duration-200">
                    {isRefreshing || isValidating ? 'Refreshing...' : 'Refresh'}
                  </span>
                </button>
              </div>
            )}

            {/* Challenges Display */}
            <div className="relative">
              {/* Refresh Overlay */}
              {isRefreshing && (
                <div className="absolute inset-0 z-10 flex items-center justify-center bg-black/20 backdrop-blur-sm rounded-xl transition-all duration-300">
                  <div className="glass-1 px-6 py-4 rounded-2xl shadow-2xl animate-pulse">
                    <div className="flex items-center gap-3">
                      <RefreshCw className="w-5 h-5 text-white animate-spin" />
                      <span className="text-white font-medium text-shadow-adaptive">Updating challenges...</span>
                    </div>
                  </div>
                </div>
              )}

              {error ? (
                <div className="glass-1 rounded-2xl sm:rounded-3xl p-6 sm:p-12 text-center shadow-xl">
                  <div className="w-16 h-16 sm:w-20 sm:h-20 bg-red-500/20 rounded-full flex items-center justify-center mx-auto mb-4 sm:mb-6">
                    <AlertCircle className="w-8 h-8 sm:w-10 sm:h-10 text-red-400 icon-shadow-adaptive" />
                  </div>
                  <p className="text-red-300 mb-6 font-medium text-shadow-adaptive text-sm sm:text-base">
                    Failed to load challenges: {error.message}
                  </p>
                  <button 
                    onClick={handleRefresh}
                    disabled={isRefreshing || isValidating}
                    className="px-4 py-2 sm:px-6 sm:py-3 bg-red-600 hover:bg-red-700 disabled:opacity-50 text-white font-semibold rounded-xl transition-all hover:shadow-lg transform hover:scale-105 active:scale-95 text-sm sm:text-base"
                  >
                    {isRefreshing || isValidating ? 'Retrying...' : 'Try Again'}
                  </button>
                </div>
              ) : activeChallenges.length === 0 ? (
                <div className="glass-1 rounded-2xl sm:rounded-3xl p-8 sm:p-16 text-center shadow-xl">
                  <div className="w-16 h-16 sm:w-20 sm:h-20 bg-white/10 rounded-full flex items-center justify-center mx-auto mb-4 sm:mb-6">
                    <Trophy className="w-8 h-8 sm:w-10 sm:h-10 text-white/70 icon-shadow-adaptive" />
                  </div>
                  <h3 className="text-lg sm:text-xl font-bold text-white/90 mb-3 text-shadow-adaptive">
                    No Active Challenges
                  </h3>
                  <p className="text-white/70 mb-2 text-shadow-adaptive-sm text-sm sm:text-base">
                    Check back soon for new challenges!
                  </p>
                </div>
              ) : (
                <div className={`grid gap-4 sm:gap-6 lg:gap-8 transition-opacity duration-300 ${isRefreshing ? 'opacity-50' : 'opacity-100'}`}>
                  {activeChallenges.map(challenge => (
                    <Link key={challenge.id} href={`/challenges/${challenge.room_id}`}>
                      <div className="transition-opacity duration-200">
                        <ChallengeCard 
                          challenge={challenge} 
                          size="large"
                          challengeType={getChallengeType(challenge)}
                          showBackground={true}
                        />
                      </div>
                    </Link>
                  ))}
                </div>
              )}
            </div>
          </div>

          {/* History Section */}
          <div className="mt-12 sm:mt-16 lg:mt-20">
            <div className="flex flex-col lg:flex-row lg:items-center justify-between mb-6 sm:mb-8 gap-4">
              <div className="flex items-center gap-3 justify-center lg:justify-start">
                <History className="w-6 h-6 sm:w-8 sm:h-8 text-white icon-shadow-adaptive" />
                <h2 className="text-2xl sm:text-3xl lg:text-4xl font-bold text-white text-shadow-adaptive">
                  Challenge History
                </h2>
              </div>
              <SeasonSelector 
                onSeasonChange={setSelectedSeason}
                currentSeasonId={selectedSeason?.id}
              />
            </div>

            {selectedSeason && (
              <div className="mb-6 sm:mb-8">
                <div className="glass-1 rounded-xl sm:rounded-2xl p-4 sm:p-6 shadow-lg">
                  <div className="flex flex-col sm:flex-row sm:items-center justify-between gap-4">
                    <div>
                      <h3 className="text-lg sm:text-2xl font-bold text-white mb-2 text-shadow-adaptive">
                        {selectedSeason.name}
                      </h3>
                      <p className="text-white/80 text-shadow-adaptive-sm text-sm sm:text-base">
                        {formatDate(selectedSeason.start_date)} - {formatDate(selectedSeason.end_date)}
                      </p>
                    </div>
                    <div className="flex items-center gap-3">
                      {selectedSeason.is_current && (
                        <span className="px-3 py-1 sm:px-4 sm:py-2 badge-icon-green text-xs sm:text-sm font-semibold rounded-full">
                          Current Season
                        </span>
                      )}
                      <span className="px-3 py-1 sm:px-4 sm:py-2 badge-icon-orange text-xs sm:text-sm font-medium rounded-full">
                        {filteredChallenges.length} challenges
                      </span>
                    </div>
                  </div>
                </div>
              </div>
            )}

            {/* Historical Challenges Table */}
            <div className="relative">
              {loadingHistorical && (
                <div className="absolute inset-0 glass-2 z-10 flex items-center justify-center rounded-2xl">
                  <Loading.Section message="Loading history..." />
                </div>
              )}

              {filteredChallenges.length > 0 ? (
                <div className="glass-1 rounded-xl sm:rounded-2xl overflow-hidden shadow-xl">
                  <div className="p-2">
                    <div className="streak-card-current rounded-xl sm:rounded-2xl overflow-hidden">
                      <div className="grid grid-cols-[3fr_1fr] sm:grid-cols-[3fr_1fr_1fr] lg:grid-cols-[4fr_1fr_1fr_1fr_1fr] gap-0 items-center">
                        <div className="px-3 py-3 sm:px-4 sm:py-3 lg:px-6 lg:py-4 text-left text-xs font-bold text-white/90 uppercase tracking-wider text-shadow-adaptive-sm">
                          Challenge
                        </div>
                        <div className="px-3 py-3 sm:px-4 sm:py-3 lg:px-6 lg:py-4 text-center text-xs font-bold text-white/90 uppercase tracking-wider text-shadow-adaptive-sm">
                          Type
                        </div>
                        <div className="hidden sm:block px-3 py-3 sm:px-4 sm:py-3 lg:px-6 lg:py-4 ml-3 text-left text-xs font-bold text-white/90 uppercase tracking-wider text-shadow-adaptive-sm">
                          Maps
                        </div>
                        <div className="hidden lg:block px-3 py-3 sm:px-4 sm:py-3 lg:px-6 lg:py-4 text-left text-xs font-bold text-white/90 uppercase tracking-wider text-shadow-adaptive-sm">
                          Participants
                        </div>
                        <div className="hidden lg:block px-3 py-3 sm:px-4 sm:py-3 lg:px-6 lg:py-4 text-left text-xs font-bold text-white/90 uppercase tracking-wider text-shadow-adaptive-sm">
                          Ended
                        </div>
                      </div>
                    </div>
                  </div>
                  
                  <div className="border-t border-white/10"></div>
                  
                  <div className="divide-y divide-white/10">
                    {filteredChallenges.map((challenge) => {
                      const challengeType = getChallengeType(challenge);
                      const displayName = challenge.custom_name || challenge.name;
                      
                      return (
                        <div key={challenge.id} className="grid grid-cols-[3fr_1fr] sm:grid-cols-[3fr_1fr_1fr] lg:grid-cols-[4fr_1fr_1fr_1fr_1fr] gap-0 hover:bg-white/5 transition-all group items-center">
                          <div className="px-3 py-3 sm:px-4 sm:py-3 lg:px-6 lg:py-4 text-left">
                            <Link href={`/challenges/${challenge.room_id}`}>
                              <div className="cursor-pointer">
                                <div className="font-semibold text-white group-hover:text-purple-300 transition-colors text-shadow-adaptive text-sm sm:text-base">
                                  {displayName || `Challenge #${challenge.id}`}
                                </div>
                                <div className="sm:hidden mt-2 flex flex-wrap gap-2 text-xs">
                                  <span className="inline-flex items-center gap-1 text-white/60">
                                    <Music className="w-3 h-3 text-purple-400" />
                                    {challenge.playlists?.length || 0} maps
                                  </span>
                                  <span className="inline-flex items-center gap-1 text-white/60">
                                    <Users className="w-3 h-3 text-blue-400" />
                                    {challenge.participant_count || 0}
                                  </span>
                                </div>
                              </div>
                            </Link>
                          </div>
                          <div className="px-3 py-3 sm:px-4 sm:py-3 lg:px-6 lg:py-4 flex justify-center items-center">
                            <div className="flex flex-col items-center gap-1">
                              <span className={`inline-flex items-center text-s ${
                                challengeType === 'weekly' 
                                  ? 'challenge-badge-weekly' 
                                  : challengeType === 'monthly'
                                  ? 'challenge-badge-monthly'
                                  : 'challenge-badge-custom'
                              }`}>
                                {challengeType}
                              </span>
                              <div className="sm:hidden flex items-center gap-1 text-xs text-white/60">
                                <Clock className="w-3 h-3 text-gray-400" />
                                {challenge.end_date ? formatDate(challenge.end_date) : 'N/A'}
                              </div>
                            </div>
                          </div>
                          <div className="hidden sm:block px-3 py-3 sm:px-4 sm:py-3 lg:px-6 lg:py-4 ml-3 text-xl text-white/90 text-shadow-adaptive-sm">
                            <div className="flex items-center gap-2">
                              <Music className="w-4 h-4 sm:w-5 sm:h-5 text-white icon-shadow-adaptive-sm flex-shrink-0" />
                              <span className="font-medium">{challenge.playlists?.length || 0}</span>
                            </div>
                          </div>
                          <div className="hidden lg:block px-3 py-3 sm:px-4 sm:py-3 lg:px-6 lg:py-4 text-xl text-white/90 text-shadow-adaptive-sm">
                            <div className="flex items-center gap-2">
                              <Users className="w-4 h-4 sm:w-5 sm:h-5 text-white icon-shadow-adaptive-sm flex-shrink-0" />
                              <span className="font-medium">{challenge.participant_count || 0}</span>
                            </div>
                          </div>
                          <div className="hidden lg:block px-3 py-3 sm:px-4 sm:py-3 lg:px-6 lg:py-4 text-sm text-white/90 text-shadow-adaptive-sm">
                            <div className="flex items-center gap-2">
                              <Clock className="w-3 h-3 sm:w-4 sm:h-4 text-white/90 icon-shadow-adaptive-sm flex-shrink-0" />
                              <span>{challenge.end_date ? formatDate(challenge.end_date) : 'N/A'}</span>
                            </div>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              ) : !loadingHistorical && (
                <div className="glass-1 rounded-2xl sm:rounded-3xl p-8 sm:p-16 text-center shadow-xl">
                  <div className="w-16 h-16 sm:w-20 sm:h-20 bg-white/10 rounded-full flex items-center justify-center mx-auto mb-4 sm:mb-6">
                    <History className="w-8 h-8 sm:w-10 sm:h-10 text-white/70 icon-shadow-adaptive" />
                  </div>
                  <h3 className="text-lg sm:text-2xl font-bold text-white/90 mb-3 text-shadow-adaptive">
                    No Historical Challenges
                  </h3>
                  <p className="text-white/70 mb-2 text-shadow-adaptive-sm text-sm sm:text-base">
                    {selectedSeason?.is_current 
                      ? 'Completed challenges will appear here as they finish'
                      : 'This season had no completed challenges'
                    }
                  </p>
                </div>
              )}
            </div>
          </div>

          {/* Footer */}
          <div className="mt-12 sm:mt-16 lg:mt-20 text-center">
            <div className="inline-flex items-center gap-2 px-4 py-3 sm:px-6 sm:py-3 glass-1 rounded-xl sm:rounded-2xl shadow-lg">
              <div className="w-2 h-2 rounded-full bg-green-400 animate-pulse"></div>
              <p className="text-xs sm:text-sm text-white/80 font-medium text-shadow-adaptive-sm">
                Data updates automatically every 5 minutes
              </p>
            </div>
          </div>
        </div>
      </div>
    </Layout>
  );
}


================================================
FILE: frontend/pages/donate.js
================================================
import { useState } from 'react';
import { useRouter } from 'next/router';
import Layout from '../components/Layout';
import DonationForm from '../components/DonationForm';
import SubscriptionManager from '../components/SubscriptionManager';
import { 
  Heart, Sparkles, Shield, Zap, Trophy, Users, 
  Server, Code, Palette, ChevronRight
} from 'lucide-react';
import { useAuth } from '../lib/AuthContext';
import toast, { Toaster } from 'react-hot-toast';

export default function DonatePage() {
  const { user } = useAuth();
  const router = useRouter();

  const handleDonationComplete = (paymentIntent) => {
    router.push(`/thank-you?payment_intent=${paymentIntent.id}&amount=${paymentIntent.amount}`);
  };

  const handleDonationError = (error) => {
    toast.error(error.message || 'Something went wrong. Please try again.', {
      style: {
        background: 'rgba(255, 255, 255, 0.1)',
        backdropFilter: 'blur(10px)',
        color: '#fff',
        border: '1px solid rgba(255, 255, 255, 0.2)',
      },
    });
  };

  return (
    <Layout>
      <Toaster position="top-center" />
      
      <div className="min-h-screen py-4 sm:py-6 lg:py-8">
        <div className="max-w-7xl mx-auto px-3 sm:px-4 lg:px-6">
          
          {/* Hero Section */}
          <div className="mb-8 sm:mb-12">
            <div className="text-center">
              <div className="flex flex-col items-center mb-6">
                <div className="relative mb-6">
                  <Heart className="w-16 h-16 sm:w-20 sm:h-20 text-white icon-shadow-adaptive-lg animate-float" />
                </div>
                
                <h1 className="text-3xl sm:text-4xl lg:text-5xl font-black text-white text-shadow-adaptive-lg mb-4">
                  Support osu!Challengers
                </h1>
                
                <p className="text-base sm:text-lg lg:text-xl text-white/85 max-w-3xl mx-auto text-shadow-adaptive leading-relaxed px-4 sm:px-0">
                  Help us keep the platform running and free for everyone. 
                  Your donation directly supports server costs and development.
                </p>
              </div>
            </div>
          </div>

          {/* Subscription Manager (only shows if user has subscriptions) */}
          {user && (
            <div className="mb-8">
              <SubscriptionManager user={user} />
            </div>
          )}

          {/* Main Content Grid */}
          <div className="grid lg:grid-cols-2 gap-6 sm:gap-8 lg:gap-12">
            
            {/* Left Column - Impact Information */}
            <div className="space-y-6 sm:space-y-8">
              
              {/* Where Your Money Goes */}
              <div className="glass-1 rounded-xl sm:rounded-2xl p-4 sm:p-6 lg:p-8">
                <div className="flex items-center gap-3 mb-4 sm:mb-6">
                  <div className="p-2 sm:p-3 icon-gradient-purple rounded-lg sm:rounded-xl icon-container-purple">
                    <Trophy className="w-5 h-5 sm:w-6 sm:h-6 text-white icon-shadow-adaptive" />
                  </div>
                  <h2 className="text-xl sm:text-2xl font-bold text-white text-shadow-adaptive">
                    Your Impact
                  </h2>
                </div>

                <div className="space-y-4">
                  {/* Server Infrastructure */}
                  <div className="glass-1 rounded-lg sm:rounded-xl p-4 hover:glass-2 transition-all">
                    <div className="flex items-start gap-3">
                      <div className="p-2 icon-gradient-blue rounded icon-container-blue mt-0.5">
                        <Server className="w-4 h-4 text-white icon-shadow-adaptive-sm" />
                      </div>
                      <div className="flex-1">
                        <h4 className="font-semibold text-white text-shadow-adaptive mb-1">
                          Server Infrastructure
                        </h4>
                        <p className="text-sm text-white/80 text-shadow-adaptive-sm">
                          Website and database hosting, CDN, and automatic backups for 24/7 availability
                        </p>
                      </div>
                    </div>
                  </div>

                  {/* Platform Maintenance */}
                  <div className="glass-1 rounded-lg sm:rounded-xl p-4 hover:glass-2 transition-all">
                    <div className="flex items-start gap-3">
                      <div className="p-2 icon-gradient-green rounded icon-container-green mt-0.5">
                        <Code className="w-4 h-4 text-white icon-shadow-adaptive-sm" />
                      </div>
                      <div className="flex-1">
                        <h4 className="font-semibold text-white text-shadow-adaptive mb-1">
                          Reliability & Upkeep
                        </h4>
                        <p className="text-sm text-white/80 text-shadow-adaptive-sm">
                          Keeping things running, bug fixes, and maintaining functionality
                        </p>
                      </div>
                    </div>
                  </div>

                  {/* Platform Features */}
                  <div className="glass-1 rounded-lg sm:rounded-xl p-4 hover:glass-2 transition-all">
                    <div className="flex items-start gap-3">
                      <div className="p-2 icon-gradient-orange rounded icon-container-orange mt-0.5">
                        <Zap className="w-4 h-4 text-white icon-shadow-adaptive-sm" />
                      </div>
                      <div className="flex-1">
                        <h4 className="font-semibold text-white text-shadow-adaptive mb-1">
                          Platform Features
                        </h4>
                        <p className="text-sm text-white/80 text-shadow-adaptive-sm">
                          Real-time score tracking, leaderboards, seasonal competitions, and API integrations
                        </p>
                      </div>
                    </div>
                  </div>

                  {/* Community */}
                  <div className="glass-1 rounded-lg sm:rounded-xl p-4 hover:glass-2 transition-all">
                    <div className="flex items-start gap-3">
                      <div className="p-2 icon-gradient-purple rounded icon-container-red mt-0.5">
                        <Trophy className="w-4 h-4 text-white icon-shadow-adaptive-sm" />
                      </div>
                      <div className="flex-1">
                        <h4 className="font-semibold text-white text-shadow-adaptive mb-1">
                          Supporter Prizes & Community
                        </h4>
                        <p className="text-sm text-white/80 text-shadow-adaptive-sm">
                          Fund prizes for challenge winners while keeping the platform free for everyone
                        </p>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              {/* Why Donate */}
              <div className="glass-1 rounded-xl sm:rounded-2xl p-4 sm:p-6">
                <h3 className="text-lg font-bold text-white mb-4 text-shadow-adaptive">
                  Why Your Support Matters
                </h3>
                <div className="space-y-3">
                  <div className="flex items-start gap-2">
                    <ChevronRight className="w-4 h-4 mt-0.5 flex-shrink-0 text-white/70 icon-shadow-adaptive-sm" />
                    <span className="text-sm text-white/90 text-shadow-adaptive-sm">
                      We run entirely on community support with no ads or paywalls
                    </span>
                  </div>
                  <div className="flex items-start gap-2">
                    <ChevronRight className="w-4 h-4 mt-0.5 flex-shrink-0 text-white/70 icon-shadow-adaptive-sm" />
                    <span className="text-sm text-white/90 text-shadow-adaptive-sm">
                      Every dollar goes directly to platform costs and improvements
                    </span>
                  </div>
                  <div className="flex items-start gap-2">
                    <ChevronRight className="w-4 h-4 mt-0.5 flex-shrink-0 text-white/70 icon-shadow-adaptive-sm" />
                    <span className="text-sm text-white/90 text-shadow-adaptive-sm">
                      Your contribution helps thousands of players track their progress
                    </span>
                  </div>
                  <div className="flex items-start gap-2">
                    <ChevronRight className="w-4 h-4 mt-0.5 flex-shrink-0 text-white/70 icon-shadow-adaptive-sm" />
                    <span className="text-sm text-white/90 text-shadow-adaptive-sm">
                      Help maintain reliable service and platform stability
                    </span>
                  </div>
                  <div className="flex items-start gap-2">
                    <ChevronRight className="w-4 h-4 mt-0.5 flex-shrink-0 text-white/70 icon-shadow-adaptive-sm" />
                    <span className="text-sm text-white/90 text-shadow-adaptive-sm">
                      Help maintain fast, reliable service for all players
                    </span>
                  </div>
                </div>
              </div>

              {/* Additional Info Box */}
              <div className="glass-1 rounded-xl sm:rounded-2xl p-4 sm:p-6">
                <div className="flex items-center gap-3 mb-3">
                  <div className="p-1.5 icon-gradient-green rounded icon-container-green">
                    <Sparkles className="w-4 h-4 text-white icon-shadow-adaptive-sm" />
                  </div>
                  <h3 className="text-lg font-bold text-white text-shadow-adaptive">
                    Our Commitment
                  </h3>
                </div>
                <p className="text-sm text-white/80 text-shadow-adaptive-sm leading-relaxed mb-3">
                  We're committed to transparency and efficiency. Your donations ensure:
                </p>
                <ul className="space-y-2">
                  <li className="flex items-center gap-2">
                    <div className="w-2 h-2 bg-green-400 rounded-full"></div>
                    <span className="text-sm text-white/90 text-shadow-adaptive-sm">No ads or premium tiers</span>
                  </li>
                  <li className="flex items-center gap-2">
                    <div className="w-2 h-2 bg-green-400 rounded-full"></div>
                    <span className="text-sm text-white/90 text-shadow-adaptive-sm">Consistent uptime and reliability</span>
                  </li>
                  <li className="flex items-center gap-2">
                    <div className="w-2 h-2 bg-green-400 rounded-full"></div>
                    <span className="text-sm text-white/90 text-shadow-adaptive-sm">Community-driven development</span>
                  </li>
                </ul>
              </div>
            </div>

            {/* Right Column - Donation Form */}
            <div className="lg:sticky lg:top-6 lg:h-fit">
              <div className="glass-1 rounded-xl sm:rounded-2xl p-4 sm:p-6 lg:p-8">
                <div className="flex items-center gap-3 mb-4 sm:mb-6">
                  <Shield className="w-5 h-5 text-green-400 icon-shadow-adaptive-sm" />
                  <h3 className="text-lg sm:text-xl font-bold text-white text-shadow-adaptive">
                    Secure Donation
                  </h3>
                </div>

                <DonationForm
                  user={user}
                  onSuccess={handleDonationComplete}
                  onError={handleDonationError}
                />
              </div>
            </div>
          </div>

          {/* Thank You Section */}
          <div className="mt-12 sm:mt-16 text-center">
            <div className="glass-2 rounded-2xl sm:rounded-3xl p-6 sm:p-8 lg:p-10 max-w-3xl mx-auto">
              <div className="flex items-center justify-center gap-4 mb-4">
                <Sparkles className="w-6 h-6 sm:w-8 sm:h-8 text-white icon-shadow-adaptive animate-pulse-soft" />
                <h3 className="text-xl sm:text-2xl font-bold text-white text-shadow-adaptive">
                  Thank You
                </h3>
                <Sparkles className="w-6 h-6 sm:w-8 sm:h-8 text-white icon-shadow-adaptive animate-pulse-soft" />
              </div>
              <p className="text-sm sm:text-lg text-white/85 text-shadow-adaptive-sm leading-relaxed">
                Every donation helps keep osu!Challengers running and growing. 
                We're grateful for your support in building this community platform.
              </p>
            </div>
          </div>
        </div>
      </div>
    </Layout>
  );
}


================================================
FILE: frontend/pages/index.js
================================================
import { useState, useRef, useEffect } from 'react';
import Layout from '../components/Layout';
import { Trophy, Calendar, Gift, Zap, Users, Music, Sparkles, Info, ChevronRight, Star, Dice3, Award, Clock, AlertCircle, CheckCircle2, BarChart3, TrendingUp, Target, Download } from 'lucide-react';

export default function AboutChallengers() {
  const [activeTab, setActiveTab] = useState('weekly');
  const [clickCount, setClickCount] = useState(0);
  const [detectedOS, setDetectedOS] = useState({ os: 'unknown', link: '#' });
  const [isFalling, setIsFalling] = useState(false);
  const [hasFallen, setHasFallen] = useState(false);
  const [isShaking, setIsShaking] = useState(false);
  const trophyRef = useRef(null);
  const clickTimeoutRef = useRef(null);

  const handleTrophyClick = () => {
    if (hasFallen) return; // Don't allow clicking if trophy has already fallen
    
    setClickCount(prev => prev + 1);
    
    // Clear existing timeout
    if (clickTimeoutRef.current) {
      clearTimeout(clickTimeoutRef.current);
    }

    // Start shaking immediately
    setIsShaking(true);

    // Check if we've reached the threshold for falling
    if (clickCount >= 9) { // Falls on 10th click
      setIsFalling(true);
      setIsShaking(false);
      
      // Mark as fallen permanently after animation starts
      setTimeout(() => {
        setHasFallen(true);
      }, 100);
    } else {
      // Reset shake and click count after a delay if user stops clicking
      clickTimeoutRef.current = setTimeout(() => {
        setIsShaking(false);
        setClickCount(0);
      }, 1000);
    }
  };

  useEffect(() => {
    const links = {
      windows: "https://github.com/fuyukiSmkw/osu-challengers-ruleset/releases/latest/download/oCrs-installer.bat",
      linux: "https://github.com/fuyukiSmkw/osu-challengers-ruleset/releases/latest/download/oCrs-installer.sh",
      mac: "https://github.com/fuyukiSmkw/osu-challengers-ruleset/releases/latest/download/oCrs-installer.sh"
    };

    const userAgent = window.navigator.userAgent.toLowerCase();
    let os = "unknown";
    let link = "#";

    if (userAgent.includes("win")) {
      os = "Windows";
      link = links.windows;
    } else if (userAgent.includes("mac")) {
      os = "macOS";
      link = links.mac;
    } else if (userAgent.includes("linux")) {
      os = "Linux";
      link = links.linux;
    }

    setDetectedOS({ os, link });
  }, []);

  // Clean up timeout on unmount
  useEffect(() => {
    return () => {
      if (clickTimeoutRef.current) {
        clearTimeout(clickTimeoutRef.current);
      }
    };
  }, []);

  return (
    <Layout>
      <div className="min-h-screen py-4 sm:py-6 lg:py-8">
        <div className="max-w-7xl mx-auto px-3 sm:px-4 lg:px-6">
          {/* Header Section */}
          <div className="mb-8 sm:mb-10 lg:mb-12">
            <div className="text-center">
              {/* Trophy Animation Container */}
              <div className="relative inline-block mb-6 sm:mb-8">
                {!hasFallen && (
                  <Trophy 
                    ref={trophyRef}
                    onClick={handleTrophyClick}
                    className={`w-16 h-16 sm:w-24 sm:h-24 text-white relative z-10 icon-shadow-adaptive cursor-pointer transition-all duration-300 hover:scale-110 select-none ${
                      isFalling 
                        ? 'animate-trophy-fall' 
                        : isShaking 
                          ? 'animate-trophy-shake' 
                          : 'animate-float'
                    }`}
                    style={{
                      transform: isFalling ? 'translateY(200vh) rotate(720deg)' : 'none',
                      transition: isFalling ? 'transform 3s cubic-bezier(0.25, 0.46, 0.45, 0.94)' : 'none'
                    }}
                  />
                )}
                
                {/* Click indicator */}
                {clickCount > 0 && !isFalling && !hasFallen && (
                  <div className="absolute -top-2 -right-2 w-6 h-6 bg-red-500 text-white text-xs font-bold rounded-full flex items-center justify-center animate-pulse">
                    {clickCount}
                  </div>
                )}

                {/* Empty space placeholder when trophy is gone */}
                {hasFallen && (
                  <div className="w-16 h-16 sm:w-24 sm:h-24 opacity-20 flex items-center justify-center">
                    <div className="text-white/30 text-xs sm:text-sm text-center">
                      Trophy has fallen!<br />
                      <span className="text-xs">Reload to respawn</span>
                    </div>
                  </div>
                )}
              </div>
              
              <h1 className={`text-3xl sm:text-4xl lg:text-5xl font-black text-white text-shadow-adaptive-lg mb-4 sm:mb-6 transition-all duration-300 ${
                isFalling ? 'animate-text-bounce' : ''
              }`}>
                osu!Challengers
              </h1>
              
              <p className="text-base sm:text-lg lg:text-xl text-white/80 max-w-3xl mx-auto text-shadow-adaptive leading-relaxed px-4 sm:px-0">
                Welcome to osu!Challengers - a collection of competitive events where you can test your skills, win supporter, and have fun with the community!
              </p>
            </div>
          </div>

          {/* Event Types Grid */}
          <div className="mb-8 sm:mb-10">
            <div className="flex items-center gap-3 mb-6 sm:mb-8">
              <div className="p-2 sm:p-3 icon-gradient-purple rounded-lg sm:rounded-xl icon-container-purple">
                <Zap className="w-5 h-5 sm:w-6 sm:h-6 text-white icon-shadow-adaptive" />
              </div>
              <h2 className="text-2xl sm:text-3xl font-bold text-white text-shadow-adaptive">
                Event Types
              </h2>
            </div>
            
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4 sm:gap-6">
              {/* Weekly Card */}
              <div
                className={`glass-1 flex flex-col rounded-xl sm:rounded-2xl p-4 sm:p-6 cursor-pointer transition-all duration-300 hover:shadow-2xl hover:bg-white/30 ${
                  activeTab === 'weekly' ? 'ring-2 ring-blue-400/60 glass-2' : ''
                }`}
                onClick={() => setActiveTab('weekly')}
              >
                {/* Header: icon and title */}
                <div>
                  <div className="flex items-center gap-3 mb-4">
                    <div className="p-2 sm:p-3 icon-gradient-blue rounded-lg sm:rounded-xl icon-container-blue">
                      <Calendar className="w-5 h-5 sm:w-6 sm:h-6 text-white icon-shadow-adaptive" />
                    </div>
                    <h3 className="text-lg sm:text-xl font-bold text-white text-shadow-adaptive">
                      o!C Weekly
                    </h3>
                  </div>

                  {/* Description */}
                  <p className="text-sm sm:text-base text-white/80 leading-relaxed text-shadow-adaptive-sm">
                    Standard weekly challenges with single maps. Difficulty increases throughout the month.
                  </p>
                </div>

                {/* Prize section aligned to bottom */}
                <div className="mt-auto pt-4">
                  <div className="glass-1 rounded-lg sm:rounded-xl p-2.5 sm:p-3 inline-flex items-center gap-2">
                    <Award className="w-4 h-4 sm:w-5 sm:h-5 text-white/90 icon-shadow-adaptive-sm" />
                    <span className="text-sm sm:text-base font-semibold text-white/90 text-shadow-adaptive-sm">
                      2 Supporter Prizes
                    </span>
                  </div>
                </div>
              </div>

              {/* CE Card */}
              <div
                className={`glass-1 flex flex-col rounded-xl sm:rounded-2xl p-4 sm:p-6 cursor-pointer transition-all duration-300 hover:shadow-2xl hover:bg-white/30 ${
                  activeTab === 'ce' ? 'ring-2 ring-purple-400/60 glass-2' : ''
                }`}
                onClick={() => setActiveTab('ce')}
              >
                {/* Header: icon and title */}
                <div>
                  <div className="flex items-center gap-3 mb-4">
                    <div className="p-2 sm:p-3 icon-gradient-purple rounded-lg sm:rounded-xl icon-container-purple">
                      <Users className="w-5 h-5 sm:w-6 sm:h-6 text-white icon-shadow-adaptive" />
                    </div>
                    <h3 className="text-lg sm:text-xl font-bold text-white text-shadow-adaptive">
                      o!C CE
                    </h3>
                  </div>

                  {/* Description */}
                  <p className="text-sm sm:text-base text-white/80 leading-relaxed text-shadow-adaptive-sm">
                    Cycle End events featuring all maps from the current season. Top 3 + raffle system!
                  </p>
                </div>

                {/* Prize section aligned to bottom */}
                <div className="mt-auto pt-4">
                  <div className="glass-1 rounded-lg sm:rounded-xl p-2.5 sm:p-3 inline-flex items-center gap-2">
                    <Award className="w-4 h-4 sm:w-5 sm:h-5 text-white/90 icon-shadow-adaptive-sm" />
                    <span className="text-sm sm:text-base font-semibold text-white/90 text-shadow-adaptive-sm">
                      6 Supporter Prizes
                    </span>
                  </div>
                </div>
              </div>

              {/* Custom Card */}
              <div
                className={`glass-1 flex flex-col rounded-xl sm:rounded-2xl p-4 sm:p-6 cursor-pointer transition-all duration-300 hover:shadow-2xl hover:bg-white/30 relative overflow-hidden ${
                  activeTab === 'custom' ? 'ring-2 ring-yellow-400/60 glass-2' : ''
                }`}
                onClick={() => setActiveTab('custom')}
              >
                {/* Header: icon and title */}
                <div>
                  <div className="flex items-center gap-3 mb-4">
                    <div className="p-2 sm:p-3 icon-gradient-orange rounded-lg sm:rounded-xl icon-container-orange">
                      <Gift className="w-5 h-5 sm:w-6 sm:h-6 text-white icon-shadow-adaptive" />
                    </div>
                    <h3 className="text-lg sm:text-xl font-bold text-white text-shadow-adaptive">
                      o!C Custom
                    </h3>
                  </div>

                  {/* Description */}
                  <p className="text-sm sm:text-base text-white/80 leading-relaxed text-shadow-adaptive-sm">
                    Special events with custom maps and songs created just for you!
                  </p>
                </div>

                {/* Prize section aligned to bottom */}
                <div className="mt-auto pt-4">
                  <div className="glass-1 rounded-lg sm:rounded-xl p-2.5 sm:p-3 inline-flex items-center gap-2">
                    <Award className="w-4 h-4 sm:w-5 sm:h-5 text-white/90 icon-shadow-adaptive-sm" />
                    <span className="text-sm sm:text-base font-semibold text-white/90 text-shadow-adaptive-sm">
                      6 Months + Merch
                    </span>
                  </div>
                </div>

                {/* Badge on top right */}
                <span className="absolute top-3 right-3 px-2.5 py-1 bg-gradient-to-b from-yellow-400 to-orange-400 text-white text-xs font-bold rounded-full shadow-lg">
                  Coming Soon!
                </span>
              </div>
            </div>
          </div>

          {/* Tab Content Container */}
          <div className="glass-1 rounded-xl sm:rounded-2xl overflow-hidden mb-8 sm:mb-10">
            {/* Tab Navigation */}
            <div className="p-4 sm:p-6 border-b border-white/10">
              <div className="view-mode-slider">
                <div className="slider-track">
                  <div className="slider-thumb" style={{
                    left: activeTab === 'weekly' ? '4px' : 
                          activeTab === 'ce' ? 'calc(33.33% + 4px)' :
                          'calc(66.66% + 4px)',
                    width: 'calc(33.33% - 8px)',
                  }} />
                  <button
                    onClick={() => setActiveTab('weekly')}
                    className={`slider-option ${activeTab === 'weekly' ? 'slider-option-active' : ''}`}
                  >
                    <span className="hidden sm:inline">Weekly Details</span>
                    <span className="sm:hidden">Weekly</span>
                  </button>
                  <button
                    onClick={() => setActiveTab('ce')}
                    className={`slider-option ${activeTab === 'ce' ? 'slider-option-active' : ''}`}
                  >
                    <span className="hidden sm:inline">CE Details</span>
                    <span className="sm:hidden">CE</span>
                  </button>
                  <button
                    onClick={() => setActiveTab('custom')}
                    className={`slider-option ${activeTab === 'custom' ? 'slider-option-active' : ''}`}
                  >
                    <span className="hidden sm:inline">Custom Details</span>
                    <span className="sm:hidden">Custom</span>
                  </button>
                </div>
              </div>
            </div>

            {/* Tab Content */}
            <div className="p-4 sm:p-6 lg:p-8">
              {activeTab === 'weekly' && (
                <div className="space-y-6 sm:space-y-8">
                  <div>
                    <p className="text-base sm:text-lg text-white/90 leading-relaxed text-shadow-adaptive">
                      Every week, a new Playlist is created in Lazer containing exactly <span className="font-bold text-white">1 map</span>. 
                      The difficulty progression throughout the month is carefully designed to challenge players of all skill levels.
                    </p>
                  </div>
                  
                  {/* Difficulty Progression */}
                  <div>
                    <h4 className="text-lg sm:text-xl font-bold text-white mb-4 sm:mb-6 flex items-center gap-2 text-shadow-adaptive">
                      <BarChart3 className="w-5 h-5 sm:w-6 sm:h-6 icon-shadow-adaptive" />
                      Difficulty Progression
                    </h4>
                    <div className="grid grid-cols-2 sm:grid-cols-4 gap-3 sm:gap-4">
                      <div className="text-center glass-1 rounded-lg sm:rounded-xl p-3 sm:p-4">
                        <div className="text-xl sm:text-2xl font-black text-white mb-1 text-shadow-adaptive">Week 1</div>
                        <div className="text-sm sm:text-base font-semibold text-white/90 text-shadow-adaptive-sm">5.50‚òÖ - 5.99‚òÖ</div>
                      </div>
                      <div className="text-center glass-1 rounded-lg sm:rounded-xl p-3 sm:p-4">
                        <div className="text-xl sm:text-2xl font-black text-white mb-1 text-shadow-adaptive">Week 2</div>
                        <div className="text-sm sm:text-base font-semibold text-white/90 text-shadow-adaptive-sm">6.00‚òÖ - 6.49‚òÖ</div>
                      </div>
                      <div className="text-center glass-1 rounded-lg sm:rounded-xl p-3 sm:p-4">
                        <div className="text-xl sm:text-2xl font-black text-white mb-1 text-shadow-adaptive">Week 3</div>
                        <div className="text-sm sm:text-base font-semibold text-white/90 text-shadow-adaptive-sm">6.50‚òÖ - 6.99‚òÖ</div>
                      </div>
                      <div className="text-center glass-1 rounded-lg sm:rounded-xl p-3 sm:p-4">
                        <div className="text-xl sm:text-2xl font-black text-white mb-1 text-shadow-adaptive">Week 4</div>
                        <div className="text-sm sm:text-base font-semibold text-white/90 text-shadow-adaptive-sm">7.00‚òÖ - 7.49‚òÖ</div>
                      </div>
                    </div>
                  </div>

                  {/* How to Win */}
                  <div>
                    <h4 className="text-lg sm:text-xl font-bold text-white mb-4 sm:mb-6 flex items-center gap-2 text-shadow-adaptive">
                      <Trophy className="w-5 h-5 sm:w-6 sm:h-6 icon-shadow-adaptive" />
                      How to Win Supporter
                    </h4>
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 sm:gap-4">
                      <div className="glass-1 rounded-lg sm:rounded-xl p-4 sm:p-6">
                        <div className="flex items-center gap-3 mb-3">
                          <div className="p-2 icon-gradient-green rounded-lg icon-container-green">
                            <Trophy className="w-4 h-4 sm:w-5 sm:h-5 text-white icon-shadow-adaptive-sm" />
                          </div>
                          <h5 className="text-base sm:text-lg font-semibold text-white text-shadow-adaptive">Highest Score</h5>
                        </div>
                        <p className="text-sm sm:text-base text-white/80 leading-relaxed text-shadow-adaptive-sm">
                          Win the Playlist by achieving the highest overall score across all difficulties
                        </p>
                      </div>
                      <div className="glass-1 rounded-lg sm:rounded-xl p-4 sm:p-6">
                        <div className="flex items-center gap-3 mb-3">
                          <div className="p-2 icon-gradient-purple rounded-lg icon-container-purple">
                            <Zap className="w-4 h-4 sm:w-5 sm:h-5 text-white icon-shadow-adaptive-sm" />
                          </div>
                          <h5 className="text-base sm:text-lg font-semibold text-white text-shadow-adaptive">Mod Challenge</h5>
                        </div>
                        <p className="text-sm sm:text-base text-white/80 leading-relaxed text-shadow-adaptive-sm">
                          Get the best score with the specific mod chosen for that week
                        </p>
                      </div>
                    </div>
                  </div>
                </div>
              )}

              {activeTab === 'ce' && (
                <div className="space-y-6 sm:space-y-8">
                  <div>
                    <p className="text-base sm:text-lg text-white/90 leading-relaxed text-shadow-adaptive">
                      Three days before the end of each month, a special collage is created containing <span className="font-bold text-white">all Weekly maps </span> 
                      from the current season. This creates massive multi-map challenges that test your consistency across all difficulty levels!
                    </p>
                  </div>
                  
                  {/* Prize Distribution */}
                  <div className="glass-1 rounded-lg sm:rounded-xl p-4 sm:p-6">
                    <h4 className="text-lg sm:text-xl font-bold text-white mb-4 flex items-center gap-2 text-shadow-adaptive">
                      <Award className="w-5 h-5 sm:w-6 sm:h-6 icon-shadow-adaptive" />
                      Prize Distribution
                    </h4>
                    <div className="space-y-3">
                      <div className="flex items-center gap-3 sm:gap-4">
                        <div className="w-10 h-10 sm:w-12 sm:h-12 bg-gradient-to-b from-yellow-400 to-yellow-600 rounded-full flex items-center justify-center text-white font-bold text-base sm:text-lg shadow-lg">
                          1
                        </div>
                        <span className="text-sm sm:text-base font-semibold text-white text-shadow-adaptive-sm">
                          Top 3 on leaderboard: 1 month Supporter each
                        </span>
                      </div>
                      <div className="flex items-center gap-3 sm:gap-4">
                        <div className="w-10 h-10 sm:w-12 sm:h-12 bg-gradient-to-b from-purple-400 to-purple-600 rounded-full flex items-center justify-center text-white font-bold text-base sm:text-lg shadow-lg">
                          2
                        </div>
                        <span className="text-sm sm:text-base font-semibold text-white text-shadow-adaptive-sm">
                          Raffle winners (3 people): 1 month Supporter each
                        </span>
                      </div>
                    </div>
                  </div>

                  {/* Raffle System */}
                  <div className="glass-1 rounded-lg sm:rounded-xl p-4 sm:p-6">
                    <div className="flex items-center gap-3 mb-4">
                      <div className="p-2 icon-gradient-purple rounded-lg icon-container-purple">
                        <Dice3 className="w-5 h-5 sm:w-6 sm:h-6 text-white icon-shadow-adaptive" />
                      </div>
                      <h4 className="text-lg sm:text-xl font-bold text-white text-shadow-adaptive">How the Raffle Works</h4>
                    </div>
                    <ul className="space-y-2 sm:space-y-3">
                      <li className="flex items-start gap-2 sm:gap-3">
                        <ChevronRight className="w-4 h-4 sm:w-5 sm:h-5 mt-0.5 flex-shrink-0 text-white/70 icon-shadow-adaptive-sm" />
                        <span className="text-sm sm:text-base text-white/90 text-shadow-adaptive-sm">Entry requires completing each map</span>
                      </li>
                      <li className="flex items-start gap-2 sm:gap-3">
                        <ChevronRight className="w-4 h-4 sm:w-5 sm:h-5 mt-0.5 flex-shrink-0 text-white/70 icon-shadow-adaptive-sm" />
                        <span className="text-sm sm:text-base text-white/90 text-shadow-adaptive-sm">3 winners will be drawn</span>
                      </li>
                      <li className="flex items-start gap-2 sm:gap-3">
                        <ChevronRight className="w-4 h-4 sm:w-5 sm:h-5 mt-0.5 flex-shrink-0 text-white/70 icon-shadow-adaptive-sm" />
                        <span className="text-sm sm:text-base text-white/90 text-shadow-adaptive-sm">Names are removed once drawn</span>
                      </li>
                    </ul>
                  </div>
                </div>
              )}

              {activeTab === 'custom' && (
                <div className="space-y-6 sm:space-y-8">
                  <div className="glass-1 rounded-lg sm:rounded-xl p-4 sm:p-6 transition-all">
                    <div className="flex items-center gap-3 mb-3">
                      <div className="p-2 icon-gradient-green rounded-lg icon-container-green">
                        <Sparkles className="w-5 h-5 sm:w-6 sm:h-6 text-white icon-shadow-adaptive" />
                      </div>
                      <h4 className="text-lg sm:text-xl font-semibold text-white text-shadow-adaptive">Something Special!</h4>
                    </div>
                    <p className="text-sm sm:text-base text-white/80 leading-relaxed text-shadow-adaptive-sm">
                      Custom events feature <span className="font-bold text-white">custom commissioned maps</span> with 
                      <span className="font-bold text-white"> brand new songs</span> created exclusively for osu!Challengers participants! 
                      This is a completely unique experience you won't find anywhere else.
                    </p>
                  </div>

                  {/* Prize Pool */}
                  <div className="glass-1 rounded-lg sm:rounded-xl p-4 sm:p-6">
                    <h4 className="text-lg sm:text-xl font-bold text-white mb-4 flex items-center gap-2 text-shadow-adaptive">
                      Prize Pool
                    </h4>
                    <div className="flex items-center gap-4 sm:gap-6">
                      <div className="w-16 h-16 sm:w-20 sm:h-20 bg-gradient-to-b from-yellow-400 to-orange-500 rounded-2xl sm:rounded-3xl flex items-center justify-center shadow-xl">
                        <Trophy className="w-8 h-8 sm:w-10 sm:h-10 text-white icon-shadow-adaptive" />
                      </div>
                      <div>
                        <h5 className="font-bold text-white text-lg sm:text-xl mb-1 text-shadow-adaptive">
                          6 Months of osu!supporter
                        </h5>
                        <p className="text-sm sm:text-base text-white/90 text-shadow-adaptive-sm">
                          Plus your choice of official osu! merchandise up to 80USD total!
                        </p>
                      </div>
                    </div>
                    <div className="mt-4 glass-1 rounded-lg p-3 flex items-center gap-2">
                      <Info className="w-4 h-4 text-white/80 icon-shadow-adaptive-sm" />
                      <span className="text-xs sm:text-sm text-white/80 text-shadow-adaptive-sm">
                        Merchandise must be in stock on the official osu! store
                      </span>
                    </div>
                  </div>

                  <div className="text-center">
                    <div className="inline-flex items-center gap-3 px-6 py-3 sm:px-8 sm:py-4 bg-gradient-to-b from-yellow-500 to-orange-500 text-white font-bold rounded-full shadow-lg text-base sm:text-lg">
                      <Clock className="w-5 h-5 sm:w-6 sm:h-6" />
                      Currently in Production - Stay Tuned!
                    </div>
                  </div>
                </div>
              )}
            </div>
          </div>

          {/* Rules Section */}
          <div className="glass-1 rounded-xl sm:rounded-2xl p-4 sm:p-6 lg:p-8">
            <div className="flex items-center gap-3 mb-6">
              <div className="p-2 sm:p-3 icon-gradient-orange rounded-lg sm:rounded-xl icon-container-orange">
                <Info className="w-5 h-5 sm:w-6 sm:h-6 text-white icon-shadow-adaptive" />
              </div>
              <h2 className="text-xl sm:text-2xl font-bold text-white text-shadow-adaptive">
                Important Guidelines
              </h2>
            </div>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 sm:gap-6">
              <div className="glass-1 rounded-lg sm:rounded-xl p-4 sm:p-6">
                <h4 className="font-bold text-white mb-3 flex items-center gap-2 text-shadow-adaptive">
                  <CheckCircle2 className="w-4 h-4 sm:w-5 sm:h-5 text-white/90 icon-shadow-adaptive-sm" />
                  Mod Challenges
                </h4>
                <ul className="space-y-2">
                  <li className="flex items-start gap-2">
                    <span className="text-white/70 mt-1 text-shadow-adaptive-sm">‚Ä¢</span>
                    <span className="text-sm sm:text-base text-white/80 text-shadow-adaptive-sm">
                      Unless specified in the Playlist description, mod challenges must use default settings
                    </span>
                  </li>
                  <li className="flex items-start gap-2">
                    <span className="text-white/70 mt-1 text-shadow-adaptive-sm">‚Ä¢</span>
                    <span className="text-sm sm:text-base text-white/80 text-shadow-adaptive-sm">
                      You can add other mods, even ones that change the main mod's difficulty
                    </span>
                  </li>
                </ul>
              </div>
              
              <div className="glass-1 rounded-lg sm:rounded-xl p-4 sm:p-6">
                <h4 className="font-bold text-white mb-3 flex items-center gap-2 text-shadow-adaptive">
                  <CheckCircle2 className="w-4 h-4 sm:w-5 sm:h-5 text-white/90 icon-shadow-adaptive-sm" />
                  Score Visibility
                </h4>
                <ul className="space-y-2">
                  <li className="flex items-start gap-2">
                    <span className="text-white/70 mt-1 text-shadow-adaptive-sm">‚Ä¢</span>
                    <span className="text-sm sm:text-base text-white/80 text-shadow-adaptive-sm">
                      Your winning score must be publicly visible on the official Playlist leaderboard
                    </span>
                  </li>
                  <li className="flex items-start gap-2">
                    <span className="text-white/70 mt-1 text-shadow-adaptive-sm">‚Ä¢</span>
                    <span className="text-sm sm:text-base text-white/80 text-shadow-adaptive-sm">
                      Screenshots of non-visible plays won't count
                    </span>
                  </li>
                </ul>
              </div>

              <div className="glass-1 rounded-lg sm:rounded-xl p-4 sm:p-6 md:col-span-2">
                <h4 className="font-bold text-white mb-3 flex items-center gap-2 text-shadow-adaptive">
                  <CheckCircle2 className="w-4 h-4 sm:w-5 sm:h-5 text-white/90 icon-shadow-adaptive-sm" />
                  Fair Play & Sportsmanship
                </h4>
                <p className="text-sm sm:text-base text-white/80 text-shadow-adaptive-sm">
                  Respect all participants and their achievements. Everyone is trying their best, and that deserves recognition. 
                  Keep the competition friendly and fun!
                </p>
              </div>
            </div>

            <div className="mt-6 glass-1 rounded-lg p-4 border border-orange-400/30">
              <div className="flex items-start gap-3">
                <AlertCircle className="w-5 h-5 text-orange-400 mt-0.5 flex-shrink-0 icon-shadow-adaptive-sm" />
                <p className="text-sm sm:text-base text-white/80 text-shadow-adaptive-sm">
                  <span className="font-bold text-white">Note:</span> Violation of these guidelines may result in exclusion from future events. 
                  Guidelines may be updated to ensure a positive experience for all participants.
                </p>
              </div>
            </div>
          </div>

          {/* Browser Extensions Section */}
          <div className="mt-8 sm:mt-10 lg:mt-12 mb-8 sm:mb-10">
            <div className="text-center mb-6 sm:mb-8">
              <div className="flex items-center justify-center gap-3 mb-4">
                <div className="p-2 sm:p-3 icon-gradient-blue rounded-lg sm:rounded-xl icon-container-blue">
                  <Download className="w-5 h-5 sm:w-6 sm:h-6 text-white icon-shadow-adaptive" />
                </div>
                <h2 className="text-2xl sm:text-3xl font-bold text-white text-shadow-adaptive">
                  Quick Access Tools
                </h2>
              </div>
              
              <p className="text-white/85 text-sm sm:text-base lg:text-lg max-w-2xl mx-auto text-shadow-adaptive px-4 sm:px-0">
                View your osu!Challengers stats directly on the osu! website with our browser extension!
              </p>
            </div>

            {/* Extension Preview Card */}
            <div className="glass-1 rounded-xl sm:rounded-2xl overflow-hidden mb-6 sm:mb-8 max-w-5xl mx-auto">
              <div className="flex flex-col lg:flex-row h-auto lg:h-96">
                {/* Screenshot Side - Fixed square on desktop */}
                <div className="relative w-full lg:w-96 h-64 sm:h-80 lg:h-96 flex-shrink-0 overflow-hidden">
                  <img 
                    src="/extension-preview.png" 
                    alt="osu!Challengers Extension Preview"
                    className="w-full h-full object-cover"
                  />
                </div>
                
                {/* Text Side */}
                <div className="p-6 sm:p-8 lg:p-10 flex flex-col justify-center items-center text-center flex-grow">
                  <div className="max-w-lg">
                    <h3 className="text-xl sm:text-2xl font-bold text-white mb-4 text-shadow-adaptive">
                      Stats on Your Profile
                    </h3>
                    <ul className="space-y-3 mb-6 text-left">
                      <li className="flex items-start gap-3">
                        <CheckCircle2 className="w-5 h-5 text-green-400 mt-0.5 flex-shrink-0 icon-shadow-adaptive-sm" />
                        <span className="text-sm sm:text-base text-white/90 text-shadow-adaptive-sm">
                          View your osu!Challengers performance directly on osu! profiles
                        </span>
                      </li>
                      <li className="flex items-start gap-3">
                        <CheckCircle2 className="w-5 h-5 text-green-400 mt-0.5 flex-shrink-0 icon-shadow-adaptive-sm" />
                        <span className="text-sm sm:text-base text-white/90 text-shadow-adaptive-sm">
                          Track your seasonal rank, total score, and top performances
                        </span>
                      </li>
                      <li className="flex items-start gap-3">
                        <CheckCircle2 className="w-5 h-5 text-green-400 mt-0.5 flex-shrink-0 icon-shadow-adaptive-sm" />
                        <span className="text-sm sm:text-base text-white/90 text-shadow-adaptive-sm">
                          Integrated directly into the osu! website design
                        </span>
                      </li>
                    </ul>
                    <p className="text-xs sm:text-sm text-white/70 text-shadow-adaptive-sm">
                      Developed by Paraliyzed_evo & Thunderbirdo
                    </p>
                  </div>
                </div>
              </div>
            </div>

            {/* Download Buttons */}
            <div className="flex flex-wrap items-center justify-center gap-4 sm:gap-6">
              <a
                href="https://addons.mozilla.org/en-US/firefox/addon/osu-challengers/"
                target="_blank"
                rel="noopener noreferrer"
                className="flex items-center gap-3 px-6 py-4 sm:px-8 sm:py-5 glass-2 rounded-xl sm:rounded-2xl hover:glass-3 transition-all duration-300 text-white text-shadow-adaptive transform hover:scale-105 hover:shadow-xl group"
              >
                <div className="p-2.5 sm:p-3 bg-gradient-to-b from-orange-500 to-orange-600 rounded-lg group-hover:from-orange-400 group-hover:to-orange-500 transition-all">
                  <Download className="w-5 h-5 sm:w-6 sm:h-6 icon-shadow-adaptive-sm" />
                </div>
                <div className="text-left">
                  <div className="font-bold text-base sm:text-lg">Firefox Extension</div>
                  <div className="text-xs sm:text-sm text-white/70">For Firefox Browser</div>
                </div>
              </a>
              
              <a
                href="https://chromewebstore.google.com/detail/osuchallengers/ghfcjealgjkjpndjlicmcabbgakphien"
                target="_blank"
                rel="noopener noreferrer"
                className="flex items-center gap-3 px-6 py-4 sm:px-8 sm:py-5 glass-2 rounded-xl sm:rounded-2xl hover:glass-3 transition-all duration-300 text-white text-shadow-adaptive transform hover:scale-105 hover:shadow-xl group"
              >
                <div className="p-2.5 sm:p-3 bg-gradient-to-b from-blue-500 to-blue-600 rounded-lg group-hover:from-blue-400 group-hover:to-blue-500 transition-all">
                  <Download className="w-5 h-5 sm:w-6 sm:h-6 icon-shadow-adaptive-sm" />
                </div>
                <div className="text-left">
                  <div className="font-bold text-base sm:text-lg">Chrome Extension</div>
                  <div className="text-xs sm:text-sm text-white/70">For Chrome & Edge</div>
                </div>
              </a>
            </div>
          </div>

          {/* Ruleset Integration Section */}
          <div className="mt-8 sm:mt-10 lg:mt-12 mb-8 sm:mb-10">
            <div className="text-center mb-6 sm:mb-8">
              <div className="flex items-center justify-center gap-3 mb-4">
                <div className="p-2 sm:p-3 bg-gradient-to-b from-purple-400 to-purple-600 rounded-lg sm:rounded-xl shadow-lg">
                  <Zap className="w-5 h-5 sm:w-6 sm:h-6 text-white drop-shadow-lg" />
                </div>
                <h2 className="text-2xl sm:text-3xl font-bold text-white drop-shadow-lg">
                  osu! lazer Ruleset
                </h2>
              </div>
              
              <p className="text-white/85 text-sm sm:text-base lg:text-lg max-w-2xl mx-auto drop-shadow px-4 sm:px-0">
                Access osu!Challengers directly from osu! lazer with our custom ruleset integration!
              </p>
            </div>

            {/* Main Ruleset Card - Vertical Layout */}
            <div className="bg-white/10 backdrop-blur-md rounded-xl sm:rounded-2xl overflow-hidden mb-6 sm:mb-8 max-w-5xl mx-auto shadow-2xl">
              {/* Screenshot at top - full width */}
              <div className="relative w-full bg-gradient-to-br from-gray-900 to-gray-800 p-4 sm:p-6">
                <img 
                  src="/ruleset-dropdown.png" 
                  alt="osu!Challengers Ruleset Dropdown Menu"
                  className="w-full h-auto rounded-lg"
                />
              </div>
              
              {/* Text content below */}
              <div className="p-6 sm:p-8 lg:p-10">
                <h3 className="text-xl sm:text-2xl font-bold text-white mb-6 text-center drop-shadow-lg">
                  Quick Access In-Game
                </h3>
                
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                  <div className="flex items-start gap-3">
                    <CheckCircle2 className="w-5 h-5 text-green-400 mt-0.5 flex-shrink-0 drop-shadow" />
                    <span className="text-sm sm:text-base text-white/90 drop-shadow">
                      Launch the latest challenge directly from osu! lazer
                    </span>
                  </div>
                  <div className="flex items-start gap-3">
                    <CheckCircle2 className="w-5 h-5 text-green-400 mt-0.5 flex-shrink-0 drop-shadow" />
                    <span className="text-sm sm:text-base text-white/90 drop-shadow">
                      Check your osu!Challengers profile
                    </span>
                  </div>
                  <div className="flex items-start gap-3">
                    <CheckCircle2 className="w-5 h-5 text-green-400 mt-0.5 flex-shrink-0 drop-shadow" />
                    <span className="text-sm sm:text-base text-white/90 drop-shadow">
                      Get notifications when new playlists go live
                    </span>
                  </div>
                  <div className="flex items-start gap-3">
                    <CheckCircle2 className="w-5 h-5 text-green-400 mt-0.5 flex-shrink-0 drop-shadow" />
                    <span className="text-sm sm:text-base text-white/90 drop-shadow">
                      One-click installer handles everything automatically
                    </span>
                  </div>
                </div>
                
                <p className="text-xs sm:text-sm text-white/70 text-center drop-shadow">
                  Developed by fuyukiS
                </p>
              </div>
            </div>

            {/* Notification Feature Highlight - Full Width Image */}
            <div className="bg-white/10 backdrop-blur-md rounded-xl sm:rounded-2xl overflow-hidden mb-6 sm:mb-8 max-w-5xl mx-auto shadow-2xl">
              {/* Header */}
              <div className="p-4 sm:p-6 border-b border-white/10">
                <div className="flex items-center gap-3 justify-center">
                  <div className="p-2 bg-gradient-to-b from-blue-400 to-blue-600 rounded-lg shadow-lg">
                    <AlertCircle className="w-5 h-5 text-white drop-shadow" />
                  </div>
                  <h4 className="text-lg sm:text-xl font-bold text-white drop-shadow-lg">
                    Never Miss a Challenge
                  </h4>
                </div>
              </div>
              
              {/* Image - Full Width */}
              <div className="relative w-full bg-gradient-to-br from-gray-900 to-gray-800 p-4 sm:p-6">
                <img 
                  src="/ruleset-notifications-2.png" 
                  alt="osu!Challengers Notifications and Settings"
                  className="w-full h-auto rounded-lg"
                />
              </div>
              
              {/* Description */}
              <div className="p-4 sm:p-6">
                <p className="text-sm sm:text-base text-white/90 leading-relaxed text-center drop-shadow">
                  Enable in-game notifications to get alerted when new osu!Challengers playlists go live. 
                  Customize your notification preferences in the ruleset settings panel.
                </p>
              </div>
            </div>

            {/* Download Button */}
            <div className="flex flex-col items-center justify-center gap-4">
  
            <a href={detectedOS.link}
              className="flex items-center gap-3 px-6 py-4 sm:px-8 sm:py-5 bg-white/10 backdrop-blur-md rounded-xl sm:rounded-2xl hover:bg-white/20 transition-all duration-300 text-white drop-shadow transform hover:scale-105 hover:shadow-xl group"
            >
              <div className="p-2.5 sm:p-3 bg-gradient-to-b from-purple-500 to-purple-600 rounded-lg group-hover:from-purple-400 group-hover:to-purple-500 transition-all shadow-lg">
                <Download className="w-5 h-5 sm:w-6 sm:h-6 drop-shadow" />
              </div>
              <div className="text-left">
                <div className="font-bold text-base sm:text-lg">
                  {detectedOS.os === 'unknown' 
                    ? 'Download Ruleset Installer' 
                    : `Download for ${detectedOS.os}`}
                </div>
                <div className="text-xs sm:text-sm text-white/70">
                  {detectedOS.os === 'unknown' 
                    ? 'OS could not be detected - Choose manually below'
                    : detectedOS.os === 'Windows' 
                      ? 'Automatic Installation' 
                      : 'Manual Installation Required'}
                </div>
              </div>
            </a>
            
            {detectedOS.os === 'unknown' && (
              <div className="flex flex-wrap gap-3 justify-center">
                
                <a  href="https://github.com/fuyukiSmkw/osu-challengers-ruleset/releases/latest/download/oCrs-installer.bat"
                  className="text-sm px-4 py-2 glass-1 rounded-lg hover:glass-2 transition-all text-white/90"
                >
                  Windows
                </a>
                
                <a  href="https://github.com/fuyukiSmkw/osu-challengers-ruleset/releases/latest/download/oCrs-installer.sh"
                  className="text-sm px-4 py-2 glass-1 rounded-lg hover:glass-2 transition-all text-white/90"
                >
                  macOS
                </a>
                
                <a  href="https://github.com/fuyukiSmkw/osu-challengers-ruleset/releases/latest/download/oCrs-installer.sh"
                  className="text-sm px-4 py-2 glass-1 rounded-lg hover:glass-2 transition-all text-white/90"
                >
                  Linux
                </a>
              </div>
            )}
            
            
            <a  href="https://github.com/fuyukiSmkw/osu-challengers-ruleset"
              target="_blank"
              rel="noopener noreferrer"
              className="text-sm text-white/70 hover:text-white/90 transition-colors drop-shadow underline"
            >
              View on GitHub for manual installation
            </a>
          </div>
          </div>

          {/* Footer CTA */}
          <div className="mt-8 sm:mt-10 text-center">
            <div className="inline-flex flex-col items-center gap-4 sm:gap-6 px-6 py-6 sm:px-10 sm:py-8 glass-2 rounded-2xl sm:rounded-3xl shadow-2xl">
              <div className="flex items-center gap-4">
                <h3 className="text-xl sm:text-2xl font-bold text-white text-shadow-adaptive">Ready to Compete?</h3>
              </div>
              <p className="text-sm sm:text-lg text-white/80 max-w-2xl leading-relaxed text-shadow-adaptive-sm">
                Jump into the current challenge and show what you've got! Every map is an opportunity to prove your skills and win amazing prizes.
              </p>
              <div className="flex items-center gap-3 text-white font-bold">
                <Star className="w-5 h-5 sm:w-6 sm:h-6 icon-shadow-adaptive" />
                <span className="text-base sm:text-lg text-shadow-adaptive">Good luck and have fun!</span>
                <Star className="w-5 h-5 sm:w-6 sm:h-6 icon-shadow-adaptive" />
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Custom CSS for animations */}
      <style jsx>{`
        @keyframes trophy-shake {
          0%, 100% { transform: translateX(0) rotate(0deg); }
          10% { transform: translateX(-2px) rotate(-1deg); }
          20% { transform: translateX(2px) rotate(1deg); }
          30% { transform: translateX(-2px) rotate(-1deg); }
          40% { transform: translateX(2px) rotate(1deg); }
          50% { transform: translateX(-1px) rotate(-0.5deg); }
          60% { transform: translateX(1px) rotate(0.5deg); }
          70% { transform: translateX(-1px) rotate(-0.5deg); }
          80% { transform: translateX(1px) rotate(0.5deg); }
          90% { transform: translateX(-0.5px) rotate(-0.25deg); }
        }

        @keyframes text-bounce {
          0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
          10% { transform: translateY(-5px); }
          30% { transform: translateY(-3px); }
          60% { transform: translateY(-2px); }
          90% { transform: translateY(-1px); }
        }

        .animate-trophy-shake {
          animation: trophy-shake 0.5s ease-in-out infinite;
        }

        .animate-text-bounce {
          animation: text-bounce 0.8s ease-in-out;
        }

        /* Subtle hint animation when trophy is being clicked */
        .trophy-clickable {
          transition: all 0.2s ease;
        }

        .trophy-clickable:hover {
          filter: brightness(1.2);
          transform: scale(1.05);
        }

        .trophy-clickable:active {
          transform: scale(0.95);
        }
      `}</style>
    </Layout>
  );
}


================================================
FILE: frontend/pages/leaderboard.js
================================================
import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import Layout from '../components/Layout';
import Loading from '../components/Loading';
import SeasonLeaderboard from '../components/SeasonLeaderboard';
import SeasonSelector from '../components/SeasonSelector';
import { Trophy, Info, BookOpen, TrendingUp, Target, BarChart3, Scale, Award } from 'lucide-react';
import { useAuth } from '../lib/AuthContext';

export default function SeasonLeaderboardPage() {
  const { user: currentUser, loading: authLoading } = useAuth();
  
  const [selectedSeason, setSelectedSeason] = useState(null);
  const [seasons, setSeasons] = useState([]);
  const [loading, setLoading] = useState(true);
  const router = useRouter();

  useEffect(() => {
    const fetchSeasons = async () => {
      try {
        const response = await fetch('/api/seasons');
        const data = await response.json();
        
        if (data.success) {
          const seasonsData = data.data?.seasons || data.seasons || [];
          setSeasons(seasonsData);
          
          // Set current season as default
          const currentSeason = seasonsData.find(season => season.is_current);
          if (currentSeason) {
            setSelectedSeason(currentSeason);
          } else if (data.seasons.length > 0) {
            setSelectedSeason(data.seasons[0]);
          }
        }
      } catch (error) {
        console.error('Error fetching seasons:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchSeasons();
  }, []);

  if (authLoading || loading) {
    return (
      <Layout>
        <Loading.FullPage message="Loading season data..." />
      </Layout>
    );
  }

  return (
    <Layout>
      <div className="min-h-screen py-4 sm:py-6 lg:py-8">
        <div className="max-w-7xl mx-auto px-3 sm:px-4 lg:px-6">
          {/* Header Section - Mobile First */}
          <div className="mb-8 sm:mb-10 lg:mb-12">
            <div className="mb-6 sm:mb-8">
              <div className="text-center sm:text-left">
                {/* Icon and Title - Stacked on mobile, inline on larger screens */}
                <div className="flex flex-col sm:flex-row items-center sm:items-start gap-3 sm:gap-4 mb-4">
                  <BarChart3 className="w-8 h-8 sm:w-10 sm:h-10 text-white icon-shadow-adaptive-lg" />
                  
                  <h1 className="text-2xl sm:text-3xl lg:text-4xl font-bold text-white text-shadow-adaptive-lg">
                    Season Leaderboard
                  </h1>
                </div>
                
                {/* Description - Mobile optimized */}
                <p className="text-white text-sm sm:text-base lg:text-lg max-w-none sm:max-w-3xl text-shadow-adaptive px-4 sm:px-0">
                  Rankings based on your placement in three categories: total score, accuracy, and participation streak.
                </p>
              </div>
            </div>

            {/* Season Selector - Mobile First */}
            {seasons.length > 0 && (
              <div className="mb-6 sm:mb-8">
                <SeasonSelector
                  seasons={seasons}
                  selectedSeason={selectedSeason}
                  onSeasonChange={setSelectedSeason}
                />
              </div>
            )}
          </div>

          {/* Stats Cards - Mobile Compact */}
          {selectedSeason && (
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 sm:gap-6 mb-6 sm:mb-10 lg:mb-12">
              {/* Current Season Card */}
              <div className="glass-1 rounded-lg sm:rounded-2xl p-3 sm:p-6">
                <div className="flex items-center justify-between mb-2 sm:mb-4">
                  <div className="p-1.5 sm:p-3 icon-gradient-orange rounded-md sm:rounded-xl icon-container-orange">
                    <Trophy className="w-4 h-4 sm:w-6 sm:h-6 text-white" />
                  </div>
                </div>
                <h3 className="text-sm sm:text-lg font-semibold text-white mb-1 sm:mb-2 text-shadow-adaptive-sm">
                  Current Season
                </h3>
                <p className="text-lg sm:text-2xl lg:text-3xl font-black text-transparent bg-clip-text" style={{backgroundImage: 'linear-gradient(to right, #f3eba4, #f3eba4)'}}>
                  {selectedSeason.name}
                </p>
                <p className="text-xs sm:text-sm text-white/85 mt-1 sm:mt-2 text-shadow-adaptive-sm">
                  {new Date(selectedSeason.start_date).toLocaleDateString()} - {new Date(selectedSeason.end_date).toLocaleDateString()}
                </p>
              </div>

              {/* Points System Card */}
              <div className="glass-1 rounded-lg sm:rounded-2xl p-3 sm:p-6">
                <div className="flex items-center justify-between mb-2 sm:mb-4">
                  <div className="p-1.5 sm:p-3 icon-gradient-purple rounded-md sm:rounded-xl icon-container-purple">
                    <Scale className="w-4 h-4 sm:w-6 sm:h-6 text-white" />
                  </div>
                </div>
                <h3 className="text-sm sm:text-lg font-semibold text-white mb-1 sm:mb-2 text-shadow-adaptive-sm">
                  Points System
                </h3>
                <div className="text-xs sm:text-sm text-white/85 leading-relaxed text-shadow-adaptive-sm">
                  <div className="space-y-1">
                    <div>Up to 70 pts from Score Placement</div>
                    <div>Up to 15 pts from Accuracy Placement</div>
                    <div>Up to 15 pts from Streak Placement</div>
                  </div>
                </div>
              </div>

              {/* How It Works Card */}
              <div className="glass-1 rounded-lg sm:rounded-2xl p-3 sm:p-6 sm:col-span-2 lg:col-span-1">
                <div className="flex items-center justify-between mb-2 sm:mb-4">
                  <div className="p-1.5 sm:p-3 icon-gradient-blue rounded-md sm:rounded-xl icon-container-blue">
                    <Target className="w-4 h-4 sm:w-6 sm:h-6 text-white" />
                  </div>
                </div>
                <h3 className="text-sm sm:text-lg font-semibold text-white mb-1 sm:mb-2 text-shadow-adaptive-sm">
                  How It Works
                </h3>
                <p className="text-xs sm:text-sm text-white/85 leading-relaxed text-shadow-adaptive-sm">
                  Your placement in each category (compared to all players) determines how many points you earn. Higher placement = more points!
                </p>
              </div>
            </div>
          )}


          {/* Leaderboard Component */}
          <SeasonLeaderboard 
            currentUser={currentUser}
            selectedSeason={selectedSeason}
          />

          {/* Additional Info - Updated for Points System */}
          <div className="mt-8 sm:mt-10 lg:mt-12 glass-1 rounded-xl sm:rounded-2xl p-3 sm:p-6 lg:p-8">
            <div className="flex items-center gap-2 sm:gap-3 mb-3 sm:mb-6">
              <div className="p-1.5 sm:p-3 icon-gradient-orange rounded-lg sm:rounded-xl icon-container-orange">
                <Info className="w-4 h-4 sm:w-6 sm:h-6 text-white" />
              </div>
              <h3 className="text-base sm:text-xl lg:text-2xl font-bold text-white text-shadow-adaptive">
                About the Points System
              </h3>
            </div>
            
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-3 sm:gap-6 lg:gap-8">
              {/* How Points Are Earned */}
              <div className="glass-1 rounded-lg sm:rounded-xl p-3 sm:p-6 shadow-lg">
                <h4 className="font-bold text-white mb-2 sm:mb-3 flex items-center gap-1.5 sm:gap-2 text-shadow-adaptive text-sm sm:text-base">
                  <BarChart3 className="w-3.5 h-3.5 sm:w-5 sm:h-5 text-white icon-shadow-adaptive-sm" />
                  How Points Are Earned
                </h4>
                <ul className="space-y-1 sm:space-y-2 text-xs sm:text-sm text-white/90">
                  <li className="flex items-start gap-1.5 sm:gap-2">
                    <span className="text-white text-shadow-adaptive-sm mt-0.5">‚Ä¢</span>
                    <span className="text-shadow-adaptive-sm"><strong>Total Score:</strong> Earn up to 70 points based on your placement among all players</span>
                  </li>
                  <li className="flex items-start gap-1.5 sm:gap-2">
                    <span className="text-white text-shadow-adaptive-sm mt-0.5">‚Ä¢</span>
                    <span className="text-shadow-adaptive-sm"><strong>Accuracy:</strong> Earn up to 15 points based on your placement in accuracy rankings</span>
                  </li>
                  <li className="flex items-start gap-1.5 sm:gap-2">
                    <span className="text-white text-shadow-adaptive-sm mt-0.5">‚Ä¢</span>
                    <span className="text-shadow-adaptive-sm"><strong>Streak:</strong> Earn up to 15 points based on your placement in consecutive challenge streaks</span>
                  </li>
                  <li className="flex items-start gap-1.5 sm:gap-2">
                    <span className="text-white text-shadow-adaptive-sm mt-0.5">‚Ä¢</span>
                    <span className="text-shadow-adaptive-sm">Higher placement = more points. All three categories combine for your final score out of 100.</span>
                  </li>
                </ul>
              </div>
              
              {/* Scoring Example */}
              <div className="glass-1 rounded-lg sm:rounded-xl p-3 sm:p-6 shadow-lg">
                <h4 className="font-bold text-white mb-2 sm:mb-3 flex items-center gap-1.5 sm:gap-2 text-shadow-adaptive text-sm sm:text-base">
                  <BookOpen className="w-3.5 h-3.5 sm:w-5 sm:h-5 text-white icon-shadow-adaptive-sm" />
                  Scoring Example
                </h4>
                <div className="text-xs sm:text-sm text-white/90 space-y-2">
                  <p className="text-shadow-adaptive-sm">
                    <strong>Example:</strong> If you rank in the top 80% for score, top 90% for accuracy, and top 70% for streak:
                  </p>
                  <div className="ml-4 space-y-1">
                    <div className="text-shadow-adaptive-sm">‚Ä¢ Total Score: 80% placement ‚Üí 56 points (out of 70)</div>
                    <div className="text-shadow-adaptive-sm">‚Ä¢ Accuracy: 90% placement ‚Üí 13.5 points (out of 15)</div>
                    <div className="text-shadow-adaptive-sm">‚Ä¢ Streak: 70% placement ‚Üí 10.5 points (out of 15)</div>
                    <div className="text-shadow-adaptive-sm font-bold border-t border-white/20 pt-1 mt-1">= <strong>80.0 total points</strong> (out of 100)</div>
                  </div>
                  <p className="text-shadow-adaptive-sm mt-2 text-white/70">
                    The better you rank in each category, the more points you earn. Your placement is calculated relative to all other players in the season.
                  </p>
                </div>
              </div>
              
              {/* Strategy Tips */}
              <div className="glass-1 rounded-lg sm:rounded-xl p-3 sm:p-6 shadow-lg">
                <h4 className="font-bold text-white mb-2 sm:mb-3 flex items-center gap-1.5 sm:gap-2 text-shadow-adaptive text-sm sm:text-base">
                  <TrendingUp className="w-3.5 h-3.5 sm:w-5 sm:h-5 text-white icon-shadow-adaptive-sm" />
                  Strategy Tips
                </h4>
                <ul className="space-y-1 sm:space-y-2 text-xs sm:text-sm text-white/90">
                  <li className="flex items-start gap-1.5 sm:gap-2">
                    <span className="text-white text-shadow-adaptive-sm mt-0.5">‚Ä¢</span>
                    <span className="text-shadow-adaptive-sm">Participate in every challenge to build your streak</span>
                  </li>
                  <li className="flex items-start gap-1.5 sm:gap-2">
                    <span className="text-white text-shadow-adaptive-sm mt-0.5">‚Ä¢</span>
                    <span className="text-shadow-adaptive-sm">Focus on accuracy, not just high scores</span>
                  </li>
                  <li className="flex items-start gap-1.5 sm:gap-2">
                    <span className="text-white text-shadow-adaptive-sm mt-0.5">‚Ä¢</span>
                    <span className="text-shadow-adaptive-sm">Consistency across all metrics is key to climbing the leaderboard</span>
                  </li>
                  <li className="flex items-start gap-1.5 sm:gap-2">
                    <span className="text-white text-shadow-adaptive-sm mt-0.5">‚Ä¢</span>
                    <span className="text-shadow-adaptive-sm">Even with lower raw scores, strong accuracy and streak can boost your ranking</span>
                  </li>
                </ul>
              </div>
              
              {/* Rankings Update Info */}
              <div className="glass-1 rounded-lg sm:rounded-xl p-3 sm:p-6 shadow-lg">
                <h4 className="font-bold text-white mb-2 sm:mb-3 flex items-center gap-1.5 sm:gap-2 text-shadow-adaptive text-sm sm:text-base">
                  <Award className="w-3.5 h-3.5 sm:w-5 sm:h-5 text-white icon-shadow-adaptive-sm" />
                  Rankings Update
                </h4>
                <ul className="space-y-1 sm:space-y-2 text-xs sm:text-sm text-white/90">
                  <li className="flex items-start gap-1.5 sm:gap-2">
                    <span className="text-white text-shadow-adaptive-sm mt-0.5">‚Ä¢</span>
                    <span className="text-shadow-adaptive-sm">Updates in real-time as scores are submitted</span>
                  </li>
                  <li className="flex items-start gap-1.5 sm:gap-2">
                    <span className="text-white text-shadow-adaptive-sm mt-0.5">‚Ä¢</span>
                    <span className="text-shadow-adaptive-sm">Your placement is recalculated with each update</span>
                  </li>
                  <li className="flex items-start gap-1.5 sm:gap-2">
                    <span className="text-white text-shadow-adaptive-sm mt-0.5">‚Ä¢</span>
                    <span className="text-shadow-adaptive-sm">New participants affect everyone's placement and points</span>
                  </li>
                  <li className="flex items-start gap-1.5 sm:gap-2">
                    <span className="text-white text-shadow-adaptive-sm mt-0.5">‚Ä¢</span>
                    <span className="text-shadow-adaptive-sm">Check back often to see how you compare!</span>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      </div>
    </Layout>
  );
}


================================================
FILE: frontend/pages/monitoring-admin.js
================================================
import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import { 
  Activity, 
  Database, 
  Clock, 
  AlertCircle, 
  CheckCircle, 
  Users, 
  Target,
  TrendingUp,
  Server,
  Monitor,
  Zap,
  BarChart3,
  DollarSign,
  Globe,
  ArrowUp,
  ArrowDown,
  Minus,
  Download,
  RefreshCw,
  Info,
  Timer
} from 'lucide-react';
import { useAPI } from '../hooks/useAPI';
import { auth } from '../lib/supabase';
import { useAuth } from '../lib/AuthContext';
import { formatDate } from '../lib/date-utils';

export default function AdminMonitoringPage() {
  const router = useRouter();
  const { user, loading, isAdmin } = useAuth();

  // API calls for data
  const { data: healthData, error: healthError } = useAPI('/api/health', {
    refreshInterval: 30000 // Check every 30 seconds
  });

  const { data: statsResponse } = useAPI('/api/stats', {
    refreshInterval: 60000 // Update every minute
  });

  // Extract the actual stats data from the API response
  const stats = statsResponse?.success ? statsResponse.data : statsResponse;

  useEffect(() => {
    console.log('=== STATS DEBUG ===');
    console.log('Raw stats response:', statsResponse);
    console.log('Extracted stats object:', stats);
    console.log('Recent activity exists:', !!stats?.recentActivity);
    console.log('Recent activity length:', stats?.recentActivity?.length);
    console.log('First activity item:', stats?.recentActivity?.[0]);
    console.log('==================');
  }, [statsResponse, stats]);

  const { data: apiCallData, refresh: refreshUsage } = useAPI('/api/admin/vercel-usage', {
    refreshInterval: 30000 // Update every 30 seconds
  });

  useEffect(() => {
    if (!loading) {
      if (!user || !user.admin) {
        router.push('/');
        return;
      }
    }
  }, [user, loading, router]);

  const getStatusColor = (status) => {
    switch (status) {
      case 'ok': return 'text-green-400';
      case 'error': return 'text-red-400';
      case 'checking': return 'text-yellow-400';
      default: return 'text-gray-400';
    }
  };

  const getStatusIcon = (status) => {
    switch (status) {
      case 'ok': return <CheckCircle className="w-5 h-5" />;
      case 'error': return <AlertCircle className="w-5 h-5" />;
      default: return <Activity className="w-5 h-5 animate-pulse" />;
    }
  };

  const getAlertIcon = (level) => {
    switch (level) {
      case 'critical': return <AlertCircle className="w-5 h-5 text-red-400" />;
      case 'warning': return <AlertCircle className="w-5 h-5 text-yellow-400" />;
      case 'info': return <Info className="w-5 h-5 text-blue-400" />;
      default: return <Info className="w-5 h-5 text-gray-400" />;
    }
  };

  const getTrendIcon = (trend) => {
    switch (trend) {
      case 'growing': return <ArrowUp className="w-4 h-4 text-red-400" />;
      case 'declining': return <ArrowDown className="w-4 h-4 text-green-400" />;
      default: return <Minus className="w-4 h-4 text-gray-400" />;
    }
  };

  const formatBytes = (bytes) => {
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    if (bytes === 0) return '0 Bytes';
    const i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
    return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
  };

  // Filter out non-critical alerts that are just informational
  const getRelevantAlerts = (alerts) => {
    if (!alerts) return [];
    
    // Filter out the informational tracking alerts unless they're warnings/critical
    return alerts.filter(alert => 
      alert.level === 'critical' || 
      alert.level === 'warning' || 
      (alert.type !== 'tracking' && alert.type !== 'environment')
    );
  };

  if (loading) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900 flex items-center justify-center">
        <div className="text-white text-xl">Checking admin access...</div>
      </div>
    );
  }

  if (!user || !user.admin) {
    return null;
  }

  const relevantAlerts = getRelevantAlerts(apiCallData?.alerts);

  return (
    <div className="min-h-screen bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900 p-6">
      <div className="max-w-7xl mx-auto">
        <div className="flex items-center justify-between mb-8">
          <h1 className="text-3xl font-bold text-white flex items-center gap-3">
            <Monitor className="w-8 h-8 text-purple-400" />
            Admin Monitoring Dashboard
          </h1>
          <div className="flex items-center gap-4">
            {/* Tracking Status Indicator */}
            {apiCallData?.debug && (
              <div className="flex items-center gap-2 px-3 py-1 bg-gray-800/50 rounded-lg border border-gray-600/50">
                <div className="w-2 h-2 bg-green-400 rounded-full animate-pulse"></div>
                <span className="text-sm text-gray-300">
                  Custom Tracking Active
                </span>
              </div>
            )}
            <button
              onClick={refreshUsage}
              className="px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg flex items-center gap-2 transition-colors"
            >
              <RefreshCw className="w-4 h-4" />
              Refresh
            </button>
          </div>
        </div>

        {/* System Status Grid */}
        <div className="grid grid-cols-1 md:grid-cols-4 gap-6 mb-8">
          <div className="bg-black/30 rounded-xl p-6 border border-purple-500/30">
            <div className="flex items-center justify-between mb-2">
              <span className="text-sm text-gray-400">API Status</span>
              <span className={getStatusColor(healthData?.checks?.api || 'checking')}>
                {getStatusIcon(healthData?.checks?.api || 'checking')}
              </span>
            </div>
            <p className={`font-semibold ${getStatusColor(healthData?.checks?.api || 'checking')}`}>
              {(healthData?.checks?.api || 'checking').toUpperCase()}
            </p>
          </div>

          <div className="bg-black/30 rounded-xl p-6 border border-purple-500/30">
            <div className="flex items-center justify-between mb-2">
              <span className="text-sm text-gray-400">Database</span>
              <span className={getStatusColor(healthData?.checks?.database || 'checking')}>
                {getStatusIcon(healthData?.checks?.database || 'checking')}
              </span>
            </div>
            <p className={`font-semibold ${getStatusColor(healthData?.checks?.database || 'checking')}`}>
              {(healthData?.checks?.database || 'checking').toUpperCase()}
            </p>
          </div>

          <div className="bg-black/30 rounded-xl p-6 border border-purple-500/30">
            <div className="flex items-center justify-between mb-2">
              <span className="text-sm text-gray-400">Uptime</span>
              <Clock className="w-5 h-5 text-blue-400" />
            </div>
            <p className="font-semibold text-white">
              {healthData ? `${Math.floor(healthData.uptime / 3600)}h ${Math.floor((healthData.uptime % 3600) / 60)}m` : '---'}
            </p>
          </div>

          <div className="bg-black/30 rounded-xl p-6 border border-purple-500/30">
            <div className="flex items-center justify-between mb-2">
              <span className="text-sm text-gray-400">Environment</span>
              <Server className="w-5 h-5 text-green-400" />
            </div>
            <p className="font-semibold text-white">
              {healthData?.checks?.environment?.toUpperCase() || 'UNKNOWN'}
            </p>
          </div>
        </div>

        {/* Statistics Grid */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
          <div className="bg-black/30 rounded-xl p-6 border border-blue-500/30">
            <div className="flex items-center gap-3 mb-2">
              <Users className="w-6 h-6 text-blue-400" />
              <span className="text-gray-400">Total Users</span>
            </div>
            <p className="text-2xl font-bold text-white">{stats?.totalUsers || 0}</p>
          </div>

          <div className="bg-black/30 rounded-xl p-6 border border-green-500/30">
            <div className="flex items-center gap-3 mb-2">
              <Target className="w-6 h-6 text-green-400" />
              <span className="text-gray-400">Active Challenges</span>
            </div>
            <p className="text-2xl font-bold text-white">{stats?.activeChallenges || 0}</p>
          </div>

          <div className="bg-black/30 rounded-xl p-6 border border-yellow-500/30">
            <div className="flex items-center gap-3 mb-2">
              <TrendingUp className="w-6 h-6 text-yellow-400" />
              <span className="text-gray-400">Scores Today</span>
            </div>
            <p className="text-2xl font-bold text-white">{stats?.scoresToday || 0}</p>
          </div>

          <div className="bg-black/30 rounded-xl p-6 border border-purple-500/30">
            <div className="flex items-center gap-3 mb-2">
              <Zap className="w-6 h-6 text-purple-400" />
              <span className="text-gray-400">API Calls</span>
            </div>
            <p className="text-2xl font-bold text-white">{apiCallData?.usage?.monthly?.total?.toLocaleString() || 0}</p>
            <p className="text-sm text-gray-400">This month</p>
          </div>
        </div>

        {/* Enhanced API Call Statistics */}
        {apiCallData && (
          <div className="space-y-8">
            {/* Alerts Section - Only show if there are relevant alerts */}
            {relevantAlerts.length > 0 && (
              <div className="bg-black/30 rounded-xl p-6 border border-red-500/30">
                <h3 className="text-xl font-bold mb-4 flex items-center gap-2 text-white">
                  <AlertCircle className="w-5 h-5 text-red-400" />
                  System Alerts ({relevantAlerts.length})
                </h3>
                <div className="space-y-3">
                  {relevantAlerts.slice(0, 5).map((alert, index) => (
                    <div key={index} className={`p-4 rounded-lg border ${
                      alert.level === 'critical' ? 'bg-red-900/30 border-red-500/50' :
                      alert.level === 'warning' ? 'bg-yellow-900/30 border-yellow-500/50' :
                      'bg-blue-900/30 border-blue-500/50'
                    }`}>
                      <div className="flex items-start justify-between">
                        <div className="flex items-start gap-3 flex-1">
                          {getAlertIcon(alert.level)}
                          <div className="flex-1">
                            <div className="font-semibold text-white">{alert.message}</div>
                            <div className="text-sm text-gray-400 mt-1">{alert.action}</div>
                            <div className="text-xs text-gray-500 mt-1 capitalize">{alert.type} ‚Ä¢ {alert.resource?.replace('_', ' ')}</div>
                          </div>
                        </div>
                        <span className={`px-2 py-1 rounded text-xs font-semibold ${
                          alert.level === 'critical' ? 'bg-red-600 text-red-100' :
                          alert.level === 'warning' ? 'bg-yellow-600 text-yellow-100' :
                          'bg-blue-600 text-blue-100'
                        }`}>
                          {alert.level.toUpperCase()}
                        </span>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {/* API Usage Analytics */}
            <div className="bg-black/30 rounded-xl p-6 border border-purple-500/30">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-xl font-bold flex items-center gap-2 text-white">
                  <BarChart3 className="w-5 h-5 text-purple-400" />
                  API Usage Analytics
                </h3>
                <div className="flex items-center gap-2">
                  <span className={`px-3 py-1 rounded-full text-sm font-semibold ${
                    apiCallData.status?.limitStatus === 'critical' ? 'bg-red-600 text-red-100' :
                    apiCallData.status?.limitStatus === 'warning' ? 'bg-yellow-600 text-yellow-100' :
                    apiCallData.status?.limitStatus === 'caution' ? 'bg-orange-600 text-orange-100' :
                    'bg-green-600 text-green-100'
                  }`}>
                    {apiCallData.status?.limitStatus?.toUpperCase() || 'OK'}
                  </span>
                </div>
              </div>

              {/* Key Metrics - Only data we can actually track */}
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
                <div className="bg-blue-900/30 rounded-lg p-4 border border-blue-500/50">
                  <div className="text-sm text-gray-400 mb-1">Total API Calls</div>
                  <div className="text-xl font-bold text-white">{apiCallData.usage?.monthly?.total?.toLocaleString() || 0}</div>
                  <div className="text-xs text-blue-400">This month</div>
                </div>

                <div className="bg-green-900/30 rounded-lg p-4 border border-green-500/50">
                  <div className="text-sm text-gray-400 mb-1">Bandwidth Used</div>
                  <div className="text-xl font-bold text-white">{formatBytes(apiCallData.usage?.monthly?.bandwidth || 0)}</div>
                  <div className="text-xs text-green-400">Data transferred</div>
                </div>

                <div className="bg-yellow-900/30 rounded-lg p-4 border border-yellow-500/50">
                  <div className="text-sm text-gray-400 mb-1">Avg Response</div>
                  <div className="text-xl font-bold text-white">{apiCallData.quickMetrics?.averageResponseTime || 0}ms</div>
                  <div className="text-xs text-yellow-400">Response time</div>
                </div>

                <div className="bg-gray-900/50 rounded-lg p-4 border border-gray-600/50">
                  <div className="text-sm text-gray-400 mb-1">Monthly Reset</div>
                  <div className="text-xl font-bold text-white">{apiCallData.usage?.monthly?.daysUntilReset || 0}</div>
                  <div className="text-xs text-gray-500">Days remaining</div>
                </div>
              </div>

              {/* Performance & Cost Overview */}
              <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                <div className="bg-gray-900/50 rounded-lg p-4">
                  <h4 className="text-lg font-semibold text-white mb-3 flex items-center gap-2">
                    <Activity className="w-5 h-5 text-blue-400" />
                    Performance
                  </h4>
                  <div className="space-y-2">
                    <div className="flex justify-between">
                      <span className="text-gray-400">Avg Response</span>
                      <span className="text-white">{apiCallData.quickMetrics?.averageResponseTime || 0}ms</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-gray-400">Error Rate</span>
                      <span className={`${parseFloat(apiCallData.quickMetrics?.errorRate || 0) > 5 ? 'text-red-400' : 'text-green-400'}`}>
                        {apiCallData.quickMetrics?.errorRate || 0}%
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-gray-400">Requests/Day</span>
                      <span className="text-white">{apiCallData.efficiency?.requestsPerDay?.toLocaleString() || 0}</span>
                    </div>
                  </div>
                </div>

                <div className="bg-gray-900/50 rounded-lg p-4">
                  <h4 className="text-lg font-semibold text-white mb-3 flex items-center gap-2">
                    <DollarSign className="w-5 h-5 text-green-400" />
                    Cost Estimate
                  </h4>
                  <div className="space-y-2">
                    <div className="flex justify-between">
                      <span className="text-gray-400">Current</span>
                      <span className={`${(apiCallData.costs?.estimated || 0) > 0 ? 'text-red-400' : 'text-green-400'}`}>
                        ${apiCallData.costs?.estimated?.toFixed(2) || '0.00'}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-gray-400">Projected</span>
                      <span className={`${(apiCallData.costAnalysis?.projected?.estimated || 0) > 0 ? 'text-yellow-400' : 'text-green-400'}`}>
                        ${apiCallData.costAnalysis?.projected?.estimated?.toFixed(2) || '0.00'}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-gray-400">Bandwidth/Req</span>
                      <span className="text-white">{formatBytes(apiCallData.efficiency?.bandwidthPerRequest || 0)}</span>
                    </div>
                  </div>
                </div>

                <div className="bg-gray-900/50 rounded-lg p-4">
                  <h4 className="text-lg font-semibold text-white mb-3 flex items-center gap-2">
                    <TrendingUp className="w-5 h-5 text-purple-400" />
                    Growth Trends
                  </h4>
                  <div className="space-y-2">
                    <div className="flex justify-between items-center">
                      <span className="text-gray-400">7-Day Growth</span>
                      <div className="flex items-center gap-1">
                        {getTrendIcon(apiCallData.trends?.growth?.trend)}
                        <span className={`font-semibold ${
                          (apiCallData.trends?.growth?.growth || 0) > 0 ? 'text-yellow-400' : 
                          (apiCallData.trends?.growth?.growth || 0) < 0 ? 'text-green-400' : 'text-gray-400'
                        }`}>
                          {apiCallData.trends?.growth?.growth > 0 ? '+' : ''}{apiCallData.trends?.growth?.growth || 0}%
                        </span>
                      </div>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-gray-400">Trend</span>
                      <span className="text-white capitalize">{apiCallData.trends?.growth?.trend || 'stable'}</span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-gray-400">Top Endpoint</span>
                      <span className="text-white text-xs font-mono">{apiCallData.quickMetrics?.topEndpoint?.endpoint?.split('/').pop() || 'N/A'}</span>
                    </div>
                  </div>
                </div>
              </div>

              {/* Internal vs External Calls */}
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <div className="bg-gray-900/50 rounded-lg p-4">
                  <h4 className="text-lg font-semibold text-white mb-3 flex items-center gap-2">
                    <Server className="w-5 h-5 text-blue-400" />
                    Internal API Calls
                  </h4>
                  <div className="text-2xl font-bold text-blue-400 mb-2">{apiCallData.usage?.breakdown?.internal?.total?.toLocaleString() || 0}</div>
                  <div className="text-sm text-gray-400 mb-3">Your Next.js API routes</div>
                  <div className="text-xs text-gray-500">{apiCallData.usage?.breakdown?.internal?.endpoints || 0} unique endpoints</div>
                </div>

                <div className="bg-gray-900/50 rounded-lg p-4">
                  <h4 className="text-lg font-semibold text-white mb-3 flex items-center gap-2">
                    <Globe className="w-5 h-5 text-green-400" />
                    External API Calls
                  </h4>
                  <div className="text-2xl font-bold text-green-400 mb-2">{apiCallData.usage?.breakdown?.external?.total?.toLocaleString() || 0}</div>
                  <div className="text-sm text-gray-400 mb-3">osu! API, etc.</div>
                  <div className="text-xs text-gray-500">{apiCallData.usage?.breakdown?.external?.apis || 0} different APIs</div>
                </div>
              </div>

              {/* External API Breakdown */}
              {apiCallData.usage?.breakdown?.external?.details && apiCallData.usage.breakdown.external.details.length > 0 && (
                <div className="mb-6">
                  <h4 className="text-lg font-semibold text-white mb-3 flex items-center gap-2">
                    <Globe className="w-5 h-5 text-green-400" />
                    External API Breakdown
                  </h4>
                  <div className="overflow-x-auto">
                    <table className="w-full text-sm">
                      <thead>
                        <tr className="border-b border-gray-700">
                          <th className="text-left py-3 px-4 text-gray-400">API</th>
                          <th className="text-left py-3 px-4 text-gray-400">Endpoint</th>
                          <th className="text-right py-3 px-4 text-gray-400">Calls</th>
                          <th className="text-right py-3 px-4 text-gray-400">Avg Duration</th>
                          <th className="text-right py-3 px-4 text-gray-400">Error Rate</th>
                          <th className="text-left py-3 px-4 text-gray-400">Last Called</th>
                        </tr>
                      </thead>
                      <tbody>
                        {apiCallData.usage.breakdown.external.details.slice(0, 10).map((api, index) => (
                          <tr key={index} className="border-b border-gray-800">
                            <td className="py-3 px-4">
                              <span className={`px-2 py-1 rounded text-xs font-semibold ${
                                api.apiName === 'osu-api' ? 'bg-blue-600 text-blue-100' :
                                api.apiName === 'osu-auth' ? 'bg-purple-600 text-purple-100' :
                                'bg-gray-600 text-gray-100'
                              }`}>
                                {api.apiName}
                              </span>
                            </td>
                            <td className="py-3 px-4 font-mono text-xs text-white">{api.endpoint}</td>
                            <td className="py-3 px-4 text-right font-semibold text-white">{api.count?.toLocaleString()}</td>
                            <td className="py-3 px-4 text-right text-gray-400">
                              {api.totalDuration && api.count ? `${Math.round(api.totalDuration / api.count)}ms` : 'N/A'}
                            </td>
                            <td className="py-3 px-4 text-right text-gray-400">
                              {api.errors && api.count ? `${((api.errors / api.count) * 100).toFixed(1)}%` : '0%'}
                            </td>
                            <td className="py-3 px-4 text-xs text-gray-400">
                              {api.lastCall ? formatDate(api.lastCall, 'relative') : 'Never'}
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                </div>
              )}

              {/* Performance Insights */}
              {apiCallData.performance?.slowestEndpoints && apiCallData.performance.slowestEndpoints.length > 0 && (
                <div className="mb-6">
                  <h4 className="text-lg font-semibold text-white mb-3 flex items-center gap-2">
                    <Timer className="w-5 h-5 text-yellow-400" />
                    Performance Insights
                  </h4>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <h5 className="text-sm font-semibold text-gray-300 mb-2">Slowest Endpoints</h5>
                      <div className="space-y-2">
                        {apiCallData.performance.slowestEndpoints.slice(0, 5).map((endpoint, index) => (
                          <div key={index} className="flex justify-between items-center p-2 bg-gray-800/50 rounded">
                            <span className="text-xs font-mono text-white truncate">{endpoint.endpoint}</span>
                            <span className="text-sm text-yellow-400">{Math.round(endpoint.avgDuration)}ms</span>
                          </div>
                        ))}
                      </div>
                    </div>
                    
                    {apiCallData.performance.peakHours && (
                      <div>
                        <h5 className="text-sm font-semibold text-gray-300 mb-2">Peak Hours</h5>
                        <div className="space-y-2">
                          {apiCallData.performance.peakHours.slice(0, 5).map((hour, index) => (
                            <div key={index} className="flex justify-between items-center p-2 bg-gray-800/50 rounded">
                              <span className="text-sm text-white">{hour.hour}:00</span>
                              <span className="text-sm text-blue-400">{hour.calls} calls</span>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                </div>
              )}

              {/* Last updated info only */}
              <div className="flex items-center justify-end">
                <div className="text-xs text-gray-500">
                  Last updated: {apiCallData.status?.timestamp ? formatDate(apiCallData.status.timestamp, 'time') : 'Never'}
                </div>
              </div>
            </div>

            {/* Daily Trends Chart */}
            {apiCallData.trends?.daily && apiCallData.trends.daily.length > 0 && (
              <div className="bg-black/30 rounded-xl p-6 border border-purple-500/30">
                <h3 className="text-xl font-bold mb-4 flex items-center gap-2 text-white">
                  <TrendingUp className="w-5 h-5 text-green-400" />
                  Usage Trends (Last 30 Days)
                </h3>
                <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                  <div>
                    <h4 className="text-sm font-semibold text-gray-300 mb-3">Daily API Calls</h4>
                    <div className="space-y-1">
                      {apiCallData.trends.daily.slice(-7).map((day, index) => {
                        const total = (day.internal || 0) + (day.external || 0);
                        const maxTotal = Math.max(...apiCallData.trends.daily.map(d => (d.internal || 0) + (d.external || 0)));
                        const percentage = maxTotal > 0 ? (total / maxTotal) * 100 : 0;
                        
                        return (
                          <div key={index} className="flex items-center gap-3">
                            <span className="text-xs text-gray-400 w-16">{formatDate(day.date, 'short')}</span>
                            <div className="flex-1 bg-gray-800 rounded-full h-2">
                              <div 
                                className="bg-gradient-to-r from-blue-500 to-purple-500 h-2 rounded-full transition-all"
                                style={{ width: `${percentage}%` }}
                              />
                            </div>
                            <span className="text-xs text-white w-12 text-right">{total.toLocaleString()}</span>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                  
                  <div>
                    <h4 className="text-sm font-semibold text-gray-300 mb-3">Usage Distribution</h4>
                    <div className="space-y-3">
                      <div className="flex justify-between items-center">
                        <span className="text-sm text-gray-400">Internal Calls</span>
                        <span className="text-sm text-white">
                          {apiCallData.usage?.breakdown?.internal?.total ? 
                            `${((apiCallData.usage.breakdown.internal.total / apiCallData.usage.monthly.total) * 100).toFixed(1)}%` : '0%'}
                        </span>
                      </div>
                      <div className="flex justify-between items-center">
                        <span className="text-sm text-gray-400">External Calls</span>
                        <span className="text-sm text-white">
                          {apiCallData.usage?.breakdown?.external?.total ? 
                            `${((apiCallData.usage.breakdown.external.total / apiCallData.usage.monthly.total) * 100).toFixed(1)}%` : '0%'}
                        </span>
                      </div>
                      <div className="flex justify-between items-center">
                        <span className="text-sm text-gray-400">Bandwidth</span>
                        <span className="text-sm text-white">{formatBytes(apiCallData.usage?.monthly?.bandwidth || 0)}</span>
                      </div>
                      <div className="flex justify-between items-center">
                        <span className="text-sm text-gray-400">Avg Response Time</span>
                        <span className="text-sm text-white">{apiCallData.quickMetrics?.averageResponseTime || 0}ms</span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>
        )}

        {/* Recent Activity */}
        {stats?.recentActivity && (
          <div className="bg-black/30 rounded-xl p-6 border border-purple-500/30">
            <h3 className="text-xl font-bold mb-4 flex items-center gap-2 text-white">
              <Activity className="w-5 h-5 text-purple-400" />
              Recent Activity
            </h3>
            <div className="space-y-3">
              {stats.recentActivity.map((activity, index) => (
                <div key={index} className="flex items-center justify-between p-3 bg-gray-900/50 rounded-lg">
                  <div>
                    <span className="text-white font-semibold">{activity.users?.username}</span>
                    <span className="text-gray-400 ml-2">scored {activity.score.toLocaleString()}</span>
                    <span className="text-gray-400 ml-1">on {activity.playlists?.challenges?.custom_name || activity.playlists?.challenges?.name}</span>
                  </div>
                  <div className="text-sm text-gray-400">
                    {formatDate(activity.submitted_at, 'relative')}
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}


================================================
FILE: frontend/pages/partners.js
================================================
import { useState, useEffect, useRef, useCallback, memo } from 'react';
import Layout from '../components/Layout';
import PartnerCard from '../components/PartnerCard';
import TeamCard from '../components/TeamCard';
import ExpandedPartnerModal from '../components/ExpandedPartnerModal';
import ExpandedTeamModal from '../components/ExpandedTeamModal';
import Loading from '../components/Loading';
import { Users, Heart, Sparkles, AlertCircle, UserCheck } from 'lucide-react';

// Memoized error component
const ErrorDisplay = memo(function ErrorDisplay({ error, onRetry, title }) {
  return (
    <div className="glass-1 rounded-2xl sm:rounded-3xl p-8 sm:p-12 text-center max-w-2xl mx-auto mb-8 sm:mb-12">
      <div className="w-16 h-16 bg-red-500/20 rounded-full flex items-center justify-center mx-auto mb-4">
        <AlertCircle className="w-8 h-8 text-red-400" />
      </div>
      <p className="text-red-400 mb-6 font-medium text-shadow-adaptive-sm">{error}</p>
      <button 
        onClick={onRetry}
        className="bg-gradient-to-b from-red-500 to-red-600 hover:from-red-600 hover:to-red-700 text-white font-semibold px-6 py-3 rounded-full transition-all hover:shadow-lg transform hover:scale-105"
      >
        Try Again
      </button>
    </div>
  );
});

// Memoized empty state component
const EmptyState = memo(function EmptyState({ icon: Icon, title, description }) {
  return (
    <div className="glass-1 rounded-2xl sm:rounded-3xl p-8 sm:p-16 text-center max-w-2xl mx-auto mb-8 sm:mb-12">
      <div className="w-20 h-20 glass-1 rounded-full flex items-center justify-center mx-auto mb-6">
        <Icon className="w-10 h-10 text-white/60" />
      </div>
      <h3 className="text-xl sm:text-2xl font-bold text-white mb-3 text-shadow-adaptive">{title}</h3>
      <p className="text-white/80 text-sm sm:text-base text-shadow-adaptive-sm">
        {description}
      </p>
    </div>
  );
});

export default function Partners() {
  const [partners, setPartners] = useState([]);
  const [team, setTeam] = useState([]);
  const [loading, setLoading] = useState(true);
  const [teamLoading, setTeamLoading] = useState(true);
  const [error, setError] = useState(null);
  const [teamError, setTeamError] = useState(null);
  
  // Morphing animation state for partners
  const [expandedPartner, setExpandedPartner] = useState(null);
  const [partnerStartPosition, setPartnerStartPosition] = useState(null);
  const partnerCardRefs = useRef({});

  // Morphing animation state for team
  const [expandedTeamMember, setExpandedTeamMember] = useState(null);
  const [teamStartPosition, setTeamStartPosition] = useState(null);
  const teamCardRefs = useRef({});

  useEffect(() => {
    // Start both fetches in parallel
    const fetchData = async () => {
      await Promise.allSettled([fetchPartners(), fetchTeam()]);
    };
    fetchData();
  }, []);

  const fetchPartners = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await fetch('/api/partners');
      
      if (!response.ok) {
        throw new Error('Failed to fetch partners');
      }
      
      const data = await response.json();
      
      if (data.success) {
        const partnersData = data.data?.partners || data.partners || data.data || [];
        setPartners(Array.isArray(partnersData) ? partnersData : []);
      } else {
        throw new Error(data.error || 'Failed to load partners');
      }
    } catch (err) {
      console.error('Error fetching partners:', err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, []);

  const fetchTeam = useCallback(async () => {
    try {
      setTeamLoading(true);
      setTeamError(null);
      const response = await fetch('/api/team');
      
      if (!response.ok) {
        throw new Error('Failed to fetch team');
      }
      
      const data = await response.json();
      
      if (data.success) {
        const teamData = data.data?.team || data.team || data.data || [];
        setTeam(Array.isArray(teamData) ? teamData : []);
      } else {
        throw new Error(data.error || 'Failed to load team');
      }
    } catch (err) {
      console.error('Error fetching team:', err);
      setTeamError(err.message);
    } finally {
      setTeamLoading(false);
    }
  }, []);

  const handleExpandPartner = useCallback((partner) => {
    const cardElement = partnerCardRefs.current[partner.id];
    if (cardElement) {
      const rect = cardElement.getBoundingClientRect();
      setPartnerStartPosition({
        x: rect.left + rect.width / 2 - 300,
        y: rect.top + rect.height / 2 - 250,
      });
    }
    setExpandedPartner(partner);
  }, []);

  const handleClosePartnerModal = useCallback(() => {
    setExpandedPartner(null);
    setPartnerStartPosition(null);
  }, []);

  const handleExpandTeamMember = useCallback((member) => {
    const cardElement = teamCardRefs.current[member.id];
    if (cardElement) {
      const rect = cardElement.getBoundingClientRect();
      setTeamStartPosition({
        x: rect.left + rect.width / 2 - 300,
        y: rect.top + rect.height / 2 - 250,
      });
    }
    setExpandedTeamMember(member);
  }, []);

  const handleCloseTeamModal = useCallback(() => {
    setExpandedTeamMember(null);
    setTeamStartPosition(null);
  }, []);

  if (loading && teamLoading) {
    return (
      <Layout>
        <Loading.FullPage message="Loading partners and team..." />
      </Layout>
    );
  }

  return (
    <Layout>
      <div className="min-h-screen py-4 sm:py-6 lg:py-8">
        <div className="max-w-7xl mx-auto px-3 sm:px-4 lg:px-6">
          {/* Header */}
          <div className="mb-8 sm:mb-10 lg:mb-12">
            <div className="text-center">
              <div className="flex flex-col sm:flex-row items-center justify-center gap-3 sm:gap-4 mb-4 sm:mb-6">
                <div className="relative">
                  <Users className="w-8 h-8 sm:w-10 sm:h-10 text-white icon-shadow-adaptive-lg" />
                  <Heart className="w-4 h-4 sm:w-5 sm:h-5 text-red-500 absolute -top-1 -right-1 animate-pulse" />
                </div>
                <h1 className="text-2xl sm:text-3xl lg:text-4xl font-bold text-white text-shadow-adaptive-lg">
                  Our Partners
                </h1>
              </div>
              
              {/* Description */}
              <p className="text-white/85 text-sm sm:text-base lg:text-lg max-w-2xl mx-auto text-shadow-adaptive px-4 sm:px-0 leading-relaxed">
                Meet the incredible creators and communities that make osu!Challengers possible! 
              </p>
            </div>
          </div>

          {/* Partners Grid */}
          {error ? (
            <ErrorDisplay error={error} onRetry={fetchPartners} />
          ) : partners.length === 0 ? (
            <EmptyState 
              icon={Users} 
              title="No Partners Yet" 
              description="Check out these awesome creators and communities that are part of the osu!Challengers family. Click on any partner to learn more about them!" 
            />
          ) : (
            <div className="relative mb-8 sm:mb-12">
              {/* Background decoration */}
              <div className="absolute -inset-4 bg-gradient-to-br from-purple-100/50 via-transparent to-pink-100/50 rounded-3xl blur-2xl"></div>
              
              {/* Main container */}
              <div className="relative glass-1 rounded-2xl sm:rounded-3xl p-6 sm:p-8">
                {/* Inner decorative border */}
                <div className="absolute inset-4 rounded-2xl border border-purple-100/30 pointer-events-none"></div>
                
                {/* Discord-style icon grid with morphing support */}
                <div className="relative grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4 sm:gap-6">
                  {partners.map((partner) => (
                    <PartnerCard 
                      key={partner.id} 
                      partner={partner}
                      size="medium"
                      onClick={handleExpandPartner}
                      isExpanded={expandedPartner?.id === partner.id}
                      cardRef={(el) => partnerCardRefs.current[partner.id] = el}
                    />
                  ))}
                </div>
              </div>
            </div>
          )}

          {/* Meet the Team Section */}
          <div className="mb-8 sm:mb-12">
            <div className="flex flex-col sm:flex-row items-center justify-center gap-3 sm:gap-4 mb-6 sm:mb-8">
              <div className="relative">
                <UserCheck className="w-8 h-8 sm:w-10 sm:h-10 text-white icon-shadow-adaptive-lg" />
                <Sparkles className="w-4 h-4 sm:w-5 sm:h-5 text-yellow-400 absolute -top-1 -right-1 animate-pulse" />
              </div>
              <h2 className="text-2xl sm:text-3xl lg:text-4xl font-bold text-white text-shadow-adaptive-lg">
                Meet the Team
              </h2>
            </div>

            <div className="text-center mb-6 sm:mb-8">
              <p className="text-white/85 text-sm sm:text-base lg:text-lg max-w-2xl mx-auto text-shadow-adaptive px-4 sm:px-0 leading-relaxed">
                The passionate individuals who make osu!Challengers possible. Click on any team member to learn more about them!
              </p>
            </div>

            {/* Team Grid */}
            {teamError ? (
              <ErrorDisplay error={teamError} onRetry={fetchTeam} />
            ) : team.length === 0 ? (
              <EmptyState 
                icon={UserCheck} 
                title="Team Information Coming Soon" 
                description="We're working on introducing you to the amazing people behind osu!Challengers." 
              />
            ) : (
              <div className="relative">
                {/* Background decoration */}
                <div className="absolute -inset-4 bg-gradient-to-br from-blue-100/50 via-transparent to-green-100/50 rounded-3xl blur-2xl"></div>
                
                {/* Main container */}
                <div className="relative glass-1 rounded-2xl sm:rounded-3xl p-6 sm:p-8">
                  {/* Inner decorative border */}
                  <div className="absolute inset-4 rounded-2xl border border-blue-100/30 pointer-events-none"></div>
                  
                  {/* Team grid - optimized for performance */}
                  <div className="relative grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4 sm:gap-6">
                    {team.map((member) => (
                      <TeamCard 
                        key={`team-${member.id}`} 
                        member={member}
                        size="medium"
                        onClick={handleExpandTeamMember}
                        isExpanded={expandedTeamMember?.id === member.id}
                        cardRef={(el) => teamCardRefs.current[member.id] = el}
                      />
                    ))}
                  </div>
                </div>
              </div>
            )}
          </div>

          {/* Partnership Invitation Footer */}
          <div className="mt-8 sm:mt-12 text-center">
            <div className="glass-1 rounded-xl sm:rounded-2xl p-6 sm:p-8 max-w-2xl mx-auto">
              <div className="flex items-center justify-center gap-3 mb-4">
                <Heart className="w-6 h-6 text-red-400 animate-pulse" />
                <h3 className="text-xl sm:text-2xl font-bold text-white text-shadow-adaptive">
                  Interested in Partnering?
                </h3>
                <Heart className="w-6 h-6 text-red-400 animate-pulse" />
              </div>
              
              <p className="text-white/80 text-sm sm:text-base leading-relaxed text-shadow-adaptive-sm mb-6">
                We're always looking to collaborate with awesome creators, communities, and developers in the osu! space. 
                If you'd like to partner with us, we'd love to hear from you!
              </p>
              
              <div className="border-t border-white/20 pt-4">
                <p className="text-white/70 text-sm text-shadow-adaptive-sm mb-2">
                  Contact us at:
                </p>
                <p className="text-white font-mono text-lg font-semibold text-shadow-adaptive">
                  challengersnexus@gmail.com
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Expanded Modals */}
      <ExpandedPartnerModal
        partner={expandedPartner}
        isVisible={!!expandedPartner}
        onClose={handleClosePartnerModal}
        startPosition={partnerStartPosition}
      />

      <ExpandedTeamModal
        member={expandedTeamMember}
        isVisible={!!expandedTeamMember}
        onClose={handleCloseTeamModal}
        startPosition={teamStartPosition}
      />
    </Layout>
  );
}


================================================
FILE: frontend/pages/settings.js
================================================
import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import Layout from '../components/Layout';
import { useAuth } from '../lib/AuthContext';
import { useSettings } from '../lib/SettingsContext';
import AppearanceTab from '../components/settings/AppearanceTab';
import DonorPerksTab from '../components/settings/DonorPerksTab';
import { Settings, Palette, Gift, Save, X, Loader2 } from 'lucide-react';
import toast from 'react-hot-toast';

export default function SettingsPage() {
  const { user, loading: authLoading } = useAuth();
  const { settings, tempSettings, saving, updateSettings, cancelPreview } = useSettings();
  const [activeTab, setActiveTab] = useState('appearance');
  const [hasChanges, setHasChanges] = useState(false);
  const router = useRouter();

  // Redirect if not logged in
  useEffect(() => {
    if (!authLoading && !user) {
      router.push('/');
    }
  }, [user, authLoading, router]);

  // Track if there are unsaved changes
  useEffect(() => {
    setHasChanges(!!tempSettings);
  }, [tempSettings]);

  const handleSave = async () => {
    if (!tempSettings) return;
    
    const result = await updateSettings(tempSettings, false);
    
    if (result.success) {
      toast.success('Settings saved successfully!');
      setHasChanges(false);
    } else {
      toast.error(result.error || 'Failed to save settings');
    }
  };

  const handleCancel = () => {
    cancelPreview();
    setHasChanges(false);
    toast('Changes discarded');
  };

  if (authLoading || !user) {
    return (
      <Layout>
        <div className="min-h-screen flex items-center justify-center">
          <Loader2 className="w-8 h-8 animate-spin text-white/70" />
        </div>
      </Layout>
    );
  }

  // Only appearance and donor tabs remain
  const tabs = [
    { id: 'appearance', name: 'Appearance', icon: Palette },
    // { id: 'donor', name: 'Donor Perks', icon: Gift }
  ];

  return (
    <Layout>
      <div className="min-h-screen py-4 sm:py-8">
        <div className="max-w-6xl mx-auto px-3 sm:px-4">
          {/* Header */}
          <div className="mb-6 sm:mb-8">
            <h1 className="text-2xl sm:text-4xl font-bold text-white text-shadow-adaptive flex items-center gap-3">
              <Settings className="w-6 h-6 sm:w-8 sm:h-8 icon-shadow-adaptive" />
              Settings
            </h1>
            <p className="text-white/80 mt-2 text-shadow-adaptive-sm text-sm sm:text-base">
              Customize your osu!Challengers experience
            </p>
          </div>

          <div className="grid grid-cols-1 lg:grid-cols-4 gap-4 sm:gap-6">
            {/* Sidebar Navigation - Fixed Width */}
            <div className="lg:col-span-1">
              <div className="glass-1 rounded-xl sm:rounded-2xl p-4 sm:p-6 space-y-2">
                {tabs.map((tab) => {
                const Icon = tab.icon;
                const isActive = activeTab === tab.id;
                
                return (
                    <button
                    key={tab.id}
                    onClick={() => setActiveTab(tab.id)}
                    className={`w-full flex items-center gap-3 px-4 py-3 rounded-lg transition-all min-w-0 border-3 ${
                        isActive 
                        ? 'glass-2 text-white shadow-lg border-white/20' 
                        : 'hover:glass-1 text-white/80 hover:text-white border-transparent hover:border-white/10'
                    }`}
                    style={{ minWidth: '140px' }}
                    >
                    <Icon className={`w-5 h-5 flex-shrink-0 ${isActive ? 'icon-shadow-adaptive' : 'icon-shadow-adaptive-sm'}`} />
                    <span className="font-medium text-shadow-adaptive-sm truncate">{tab.name}</span>
                    </button>
                );
                })}
              </div>

              {/* Save/Cancel Actions - Desktop */}
              {hasChanges && (
                <div className="mt-4 glass-1 rounded-xl sm:rounded-2xl p-4 space-y-3 hidden lg:block">
                  <button
                    onClick={handleSave}
                    disabled={saving}
                    className="w-full btn-primary flex items-center justify-center gap-2"
                  >
                    {saving ? (
                      <>
                        <Loader2 className="w-4 h-4 animate-spin" />
                        Saving...
                      </>
                    ) : (
                      <>
                        <Save className="w-4 h-4" />
                        Save Changes
                      </>
                    )}
                  </button>
                  <button
                    onClick={handleCancel}
                    disabled={saving}
                    className="w-full btn-secondary flex items-center justify-center gap-2"
                  >
                    <X className="w-4 h-4" />
                    Discard
                  </button>
                </div>
              )}
            </div>

            {/* Content Area */}
            <div className="lg:col-span-3">
              <div className="glass-1 rounded-xl sm:rounded-2xl p-4 sm:p-8">
                {activeTab === 'appearance' && <AppearanceTab />}
                {activeTab === 'donor' && <DonorPerksTab />}
              </div>
            </div>
          </div>

          {/* Mobile Save/Cancel Actions */}
          {hasChanges && (
            <div className="fixed bottom-0 left-0 right-0 p-4 glass-1 border-t border-white/20 flex gap-3 lg:hidden z-50">
              <button
                onClick={handleSave}
                disabled={saving}
                className="flex-1 btn-primary flex items-center justify-center gap-2 text-sm"
              >
                {saving ? (
                  <>
                    <Loader2 className="w-4 h-4 animate-spin" />
                    Saving...
                  </>
                ) : (
                  <>
                    <Save className="w-4 h-4" />
                    Save
                  </>
                )}
              </button>
              <button
                onClick={handleCancel}
                disabled={saving}
                className="flex-1 btn-secondary flex items-center justify-center gap-2 text-sm"
              >
                <X className="w-4 h-4" />
                Discard
              </button>
            </div>
          )}
        </div>
      </div>
    </Layout>
  );
}


================================================
FILE: frontend/pages/thank-you.js
================================================
import { useEffect, useState } from 'react';
import { useRouter } from 'next/router';
import Link from 'next/link';
import Layout from '../components/Layout';
import { CheckCircle, Heart, Home, Trophy, Twitter, Copy, Sparkles, ArrowRight, Gift } from 'lucide-react';
import toast, { Toaster } from 'react-hot-toast';

export default function ThankYouPage() {
  const router = useRouter();
  const [verified, setVerified] = useState(false);
  const [loading, setLoading] = useState(true);
  const [animationComplete, setAnimationComplete] = useState(false);
  const { session_id, amount } = router.query;

  useEffect(() => {
    if (session_id) {
      verifyPayment();
      // Trigger animation after a short delay
      setTimeout(() => {
        setAnimationComplete(true);
      }, 500);
    }
  }, [session_id]);

  const verifyPayment = async () => {
    try {
      const response = await fetch(`/api/verify-payment?session_id=${session_id}`);
      const data = await response.json();
      
      if (data.success) {
        setVerified(true);
      }
    } catch (error) {
      console.error('Error verifying payment:', error);
    } finally {
      setLoading(false);
    }
  };

  const shareOnTwitter = () => {
    const text = `I just supported @osuChallengers to help keep the challenges running! üéÆ‚ù§Ô∏è`;
    const url = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent('https://osuchallengers.com')}`;
    window.open(url, '_blank');
  };

  const copyShareLink = () => {
    const url = 'https://osuchallengers.com/donate';
    navigator.clipboard.writeText(url);
    toast.success('Link copied!', {
      style: {
        background: 'rgba(255, 255, 255, 0.1)',
        backdropFilter: 'blur(10px)',
        color: '#fff',
        border: '1px solid rgba(255, 255, 255, 0.2)',
      },
    });
  };

  const formattedAmount = amount ? (parseInt(amount) / 100).toFixed(2) : '0.00';

  return (
    <Layout>
      <Toaster position="top-center" />
      
      <div className="min-h-screen py-8 sm:py-12 lg:py-16 flex items-center">
        <div className="max-w-4xl mx-auto px-3 sm:px-4 lg:px-6 w-full">
          {/* Success Card */}
          <div className={`glass-2 rounded-2xl sm:rounded-3xl p-6 sm:p-8 lg:p-12 transform transition-all duration-700 ${
            animationComplete ? 'scale-100 opacity-100' : 'scale-95 opacity-0'
          }`}>
            <div className="text-center">
              {/* Success Icon */}
              <div className="relative inline-flex mb-6 sm:mb-8">
                <div className={`relative p-6 sm:p-8 rounded-full transition-all duration-1000 ${
                  animationComplete ? 'rotate-0 scale-100' : 'rotate-180 scale-0'
                }`}>
                  <div className="p-6 icon-gradient-green rounded-full icon-container-green">
                    <CheckCircle className="w-12 h-12 sm:w-16 sm:h-16 text-white icon-shadow-adaptive-lg" />
                  </div>
                </div>
                {animationComplete && (
                  <>
                    <Sparkles className="absolute top-0 right-0 w-6 h-6 text-yellow-400 animate-pulse icon-shadow-adaptive-sm" />
                    <Sparkles className="absolute bottom-0 left-0 w-5 h-5 text-yellow-400 animate-pulse icon-shadow-adaptive-sm" style={{ animationDelay: '0.5s' }} />
                  </>
                )}
              </div>

              {/* Thank You Message */}
              <h1 className="text-2xl sm:text-3xl lg:text-4xl font-bold text-white mb-4 text-shadow-adaptive-lg">
                Thank You for Your Support!
              </h1>
              
              <div className="flex items-center justify-center gap-2 mb-8">
                <p className="text-lg sm:text-xl text-white/90 text-shadow-adaptive">
                  Your donation of
                </p>
                <span className="px-4 py-2 glass-3 rounded-full font-bold text-xl sm:text-2xl text-white text-shadow-adaptive">
                  ${formattedAmount}
                </span>
                <p className="text-lg sm:text-xl text-white/90 text-shadow-adaptive">
                  has been received
                </p>
              </div>

              {/* Impact Cards */}
              <div className="grid sm:grid-cols-2 gap-4 mb-8 max-w-2xl mx-auto">
                <div className="glass-1 rounded-xl p-4 sm:p-6">
                  <div className="flex items-center gap-3 mb-3">
                    <div className="p-2 icon-gradient-purple rounded-lg icon-container-purple">
                      <Trophy className="w-5 h-5 text-white icon-shadow-adaptive-sm" />
                    </div>
                    <h3 className="font-semibold text-white text-shadow-adaptive">Challenges Supported</h3>
                  </div>
                  <p className="text-sm text-white/80 text-shadow-adaptive-sm">
                    You're helping maintain live challenges for our community
                  </p>
                </div>

                <div className="glass-1 rounded-xl p-4 sm:p-6">
                  <div className="flex items-center gap-3 mb-3">
                    <div className="p-2 icon-gradient-orange rounded-lg icon-container-orange">
                      <Gift className="w-5 h-5 text-white icon-shadow-adaptive-sm" />
                    </div>
                    <h3 className="font-semibold text-white text-shadow-adaptive">Community Hero</h3>
                  </div>
                  <p className="text-sm text-white/80 text-shadow-adaptive-sm">
                    Your generosity keeps the platform free and accessible to all
                  </p>
                </div>
              </div>

              {/* Action Buttons */}
              <div className="flex flex-col sm:flex-row items-center justify-center gap-4">
                <Link href="/">
                  <button className="flex items-center gap-2 px-6 py-3 glass-2 hover:glass-3 rounded-full transition-all hover:scale-105 font-medium text-white text-shadow-adaptive-sm">
                    <Home className="w-5 h-5 icon-shadow-adaptive-sm" />
                    Back to Home
                  </button>
                </Link>
              </div>

              {/* Receipt Note */}
              <div className="mt-8 text-center">
                <p className="text-xs sm:text-sm text-white/60 text-shadow-adaptive-sm">
                  A receipt has been sent to your email address
                </p>
              </div>
            </div>
          </div>

          {/* Animated Background Elements */}
          <div className="fixed inset-0 pointer-events-none overflow-hidden">
            <div className={`absolute top-20 left-10 w-32 h-32 bg-purple-500/10 rounded-full blur-3xl transition-all duration-1000 ${
              animationComplete ? 'opacity-100 scale-100' : 'opacity-0 scale-0'
            }`} style={{ animationDelay: '0.2s' }}></div>
            <div className={`absolute bottom-20 right-10 w-40 h-40 bg-pink-500/10 rounded-full blur-3xl transition-all duration-1000 ${
              animationComplete ? 'opacity-100 scale-100' : 'opacity-0 scale-0'
            }`} style={{ animationDelay: '0.4s' }}></div>
            <div className={`absolute top-40 right-20 w-24 h-24 bg-blue-500/10 rounded-full blur-3xl transition-all duration-1000 ${
              animationComplete ? 'opacity-100 scale-100' : 'opacity-0 scale-0'
            }`} style={{ animationDelay: '0.6s' }}></div>
          </div>
        </div>
      </div>
    </Layout>
  );
}


================================================
FILE: frontend/pages/admin/challenges.js
================================================
import { useState, useEffect, useCallback } from 'react';
import Link from 'next/link';
import Layout from '../../components/Layout';
import SeasonSelector from '../../components/SeasonSelector';
import RulesetManager from '../../components/RulesetManager';
import { 
  Loader2, Settings, Search, Filter, Edit2, Save, RotateCcw, 
  CheckCircle, AlertCircle, Users, Calendar, Clock, MapPin,
  ChevronLeft, ChevronRight, X, Eye, EyeOff, Crown, Target, Trash2
} from 'lucide-react';
import { useAuth } from '../../lib/AuthContext';
import { useRouter } from 'next/router';

// Import the name generator directly
import { generateRulesetName } from '../../lib/ruleset-name-generator';

// Helper function to generate ruleset names
const generateRulesetDisplayName = (challenge) => {
  if (!challenge.has_ruleset || !challenge.required_mods || challenge.required_mods.length === 0) {
    return null;
  }

  try {
    return generateRulesetName(
      challenge.required_mods, 
      challenge.ruleset_match_type || 'exact'
    );
  } catch (error) {
    console.warn('Error generating ruleset name:', error);
    
    // Fallback: simple concatenation of mod acronyms
    const modNames = challenge.required_mods.map(mod => mod.acronym).join('');
    const prefix = challenge.ruleset_match_type === 'at_least' ? 'AtLeast:' : 
                   challenge.ruleset_match_type === 'any_of' ? 'Any:' : '';
    return `${prefix}${modNames}`;
  }
};

export default function AdminChallenges() {
  const { user, loading, isAdmin } = useAuth();
  const [challenges, setChallenges] = useState([]);
  const [loadingChallenges, setLoadingChallenges] = useState(true);
  const [summary, setSummary] = useState({});
  const [pagination, setPagination] = useState({});
  const [result, setResult] = useState(null);
  
  // Editing state
  const [editingChallenge, setEditingChallenge] = useState(null);
  const [editingName, setEditingName] = useState('');
  const [savingChanges, setSavingChanges] = useState(new Set());
  
  // Delete state
  const [challengeToDelete, setChallengeToDelete] = useState(null);
  const [deleteConfirmText, setDeleteConfirmText] = useState('');
  const [deleting, setDeleting] = useState(false);
  
  // Ruleset management state
  const [showRulesetManager, setShowRulesetManager] = useState(false);
  const [selectedChallengeForRuleset, setSelectedChallengeForRuleset] = useState(null);
  
  // Filters and search
  const [filters, setFilters] = useState({
    search: '',
    status: '',
    season_id: '',
    hasCustomName: '',
    hasRuleset: '',
    limit: 25,
    offset: 0
  });

  const router = useRouter();

  // Stabilize loadChallenges with useCallback to prevent dependency issues
  const loadChallenges = useCallback(async () => {
    console.log('üîÑ Loading challenges with filters:', filters);

    try {
      setLoadingChallenges(true);

      const params = new URLSearchParams();
      Object.entries(filters).forEach(([key, value]) => {
        if (value !== '' && value !== null && value !== undefined) {
          params.append(key, value.toString());
        }
      });

      console.log('üì° Making API request to:', `/api/admin/challenges?${params}`);
      const response = await fetch(`/api/admin/challenges?${params}`);

      console.log('üì• API response status:', response.status);

      if (!response.ok) {
        console.error('‚ùå API response not ok:', response.status, response.statusText);
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      const responseData = data.data || data;

      console.log('üìä API response data:', {
        success: data.success,
        challengeCount: responseData.challenges?.length || 0,
        summary: responseData.summary,
        pagination: responseData.pagination
      });

      if (data.success) {
        setChallenges(responseData.challenges || []);
        setPagination(responseData.pagination || {});
        setSummary(responseData.summary || {});
        console.log('‚úÖ Challenges loaded successfully');
      } else {
        console.error('‚ùå API returned error:', data.error);
        setResult({
          success: false,
          error: data.error || 'Failed to load challenges'
        });
      }
    } catch (error) {
      console.error('üö® Network/API error:', error);
      setResult({
        success: false,
        error: `Network error: ${error.message}`
      });
    } finally {
      setLoadingChallenges(false);
    }
  }, [filters]); // Only depend on filters

  // Auth check - NO API calls here, just redirect logic
  useEffect(() => {
    if (!loading) {
      if (!user) {
        router.push('/');
        return;
      }
      
      if (!isAdmin) {
        router.push('/admin');
        return;
      }
      
      // Don't call loadChallenges here - let the filters useEffect handle it
    }
  }, [user, loading, isAdmin, router]);

  // Load challenges when filters change OR when auth is ready
  useEffect(() => {
    // Only load if user is authenticated and admin
    if (user && isAdmin && !loading) {
      loadChallenges();
    }
  }, [user, isAdmin, loading, loadChallenges]); // Include loadChallenges in deps since it's now stable

  const updateFilters = useCallback((newFilters) => {
    setFilters(prev => ({
      ...prev,
      ...newFilters,
      offset: 0 // Reset to first page when filters change
    }));
  }, []);

  const changePage = useCallback((newOffset) => {
    setFilters(prev => ({ ...prev, offset: newOffset }));
  }, []);

  const startEditing = useCallback((challenge) => {
    setEditingChallenge(challenge.room_id);
    setEditingName(challenge.custom_name || challenge.name);
  }, []);

  const cancelEditing = useCallback(() => {
    setEditingChallenge(null);
    setEditingName('');
  }, []);

  // Delete functions
  const startDelete = useCallback((challenge) => {
    setChallengeToDelete(challenge);
    setDeleteConfirmText('');
  }, []);

  const cancelDelete = useCallback(() => {
    setChallengeToDelete(null);
    setDeleteConfirmText('');
  }, []);

  const confirmDelete = async () => {
    if (!challengeToDelete) return;
    
    const expectedText = `DELETE ${challengeToDelete.room_id}`;
    if (deleteConfirmText !== expectedText) {
      setResult({
        success: false,
        error: `Please type "${expectedText}" to confirm deletion`
      });
      return;
    }

    setDeleting(true);
    
    try {
      const response = await fetch('/api/admin/challenges', {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          roomId: challengeToDelete.room_id
        })
      });

      const data = await response.json();

      if (response.ok && data.success) {
        setResult({
          success: true,
          message: data.message
        });

        // Remove from local state
        setChallenges(prev => prev.filter(c => c.room_id !== challengeToDelete.room_id));
        
        // Update summary
        setSummary(prev => ({
          ...prev,
          total: Math.max(0, prev.total - 1),
          active: challengeToDelete.is_active ? Math.max(0, prev.active - 1) : prev.active,
          inactive: !challengeToDelete.is_active ? Math.max(0, prev.inactive - 1) : prev.inactive,
          withCustomNames: challengeToDelete.custom_name ? Math.max(0, prev.withCustomNames - 1) : prev.withCustomNames,
          withoutCustomNames: !challengeToDelete.custom_name ? Math.max(0, prev.withoutCustomNames - 1) : prev.withoutCustomNames,
          withRulesets: challengeToDelete.has_ruleset ? Math.max(0, prev.withRulesets - 1) : prev.withRulesets,
          withoutRulesets: !challengeToDelete.has_ruleset ? Math.max(0, prev.withoutRulesets - 1) : prev.withoutRulesets
        }));

        cancelDelete();
      } else {
        setResult({
          success: false,
          error: data.error || 'Failed to delete challenge'
        });
      }
    } catch (error) {
      console.error('Error deleting challenge:', error);
      setResult({
        success: false,
        error: 'Network error. Please try again.'
      });
    } finally {
      setDeleting(false);
    }
  };

  // Ruleset management functions
  const handleManageRuleset = useCallback((challenge) => {
    setSelectedChallengeForRuleset(challenge);
    setShowRulesetManager(true);
  }, []);

  const handleRulesetSuccess = useCallback((message) => {
    setResult({
      success: true,
      message: message
    });
    setShowRulesetManager(false);
    setSelectedChallengeForRuleset(null);
    
    // Refresh challenges list
    setTimeout(() => {
      loadChallenges();
    }, 1000);
  }, [loadChallenges]);

  const saveChallengeName = async (roomId) => {
    if (!editingName.trim()) {
      setResult({
        success: false,
        error: 'Name cannot be empty'
      });
      return;
    }

    setSavingChanges(prev => new Set([...prev, roomId]));
    
    try {
      const response = await fetch('/api/admin/challenges', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          roomId,
          customName: editingName.trim()
        })
      });

      const data = await response.json();

      if (response.ok && data.success) {
        setResult({
          success: true,
          message: `Successfully updated "${data.challenge.custom_name || data.challenge.name}"`
        });

        // Update local state
        setChallenges(prev => prev.map(challenge => 
          challenge.room_id === roomId 
            ? { ...challenge, ...data.challenge }
            : challenge
        ));

        setEditingChallenge(null);
        setEditingName('');
        
        // Update summary
        setSummary(prev => ({
          ...prev,
          withCustomNames: prev.withCustomNames + (data.changes.oldValue ? 0 : 1)
        }));
      } else {
        setResult({
          success: false,
          error: data.error || 'Failed to update challenge name'
        });
      }
    } catch (error) {
      console.error('Error updating challenge name:', error);
      setResult({
        success: false,
        error: 'Network error. Please try again.'
      });
    } finally {
      setSavingChanges(prev => {
        const newSet = new Set(prev);
        newSet.delete(roomId);
        return newSet;
      });
    }
  };

  const resetChallengeName = async (roomId) => {
    setSavingChanges(prev => new Set([...prev, roomId]));
    
    try {
      const response = await fetch('/api/admin/challenges', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          roomId,
          action: 'reset_name'
        })
      });

      const data = await response.json();

      if (response.ok && data.success) {
        setResult({
          success: true,
          message: `Reset "${data.challenge.name}" to original name`
        });

        // Update local state
        setChallenges(prev => prev.map(challenge => 
          challenge.room_id === roomId 
            ? { ...challenge, ...data.challenge }
            : challenge
        ));
        
        // Update summary
        setSummary(prev => ({
          ...prev,
          withCustomNames: Math.max(0, prev.withCustomNames - 1),
          withoutCustomNames: prev.withoutCustomNames + 1
        }));
      } else {
        setResult({
          success: false,
          error: data.error || 'Failed to reset challenge name'
        });
      }
    } catch (error) {
      console.error('Error resetting challenge name:', error);
      setResult({
        success: false,
        error: 'Network error. Please try again.'
      });
    } finally {
      setSavingChanges(prev => {
        const newSet = new Set(prev);
        newSet.delete(roomId);
        return newSet;
      });
    }
  };

  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric',
      year: 'numeric'
    });
  };

  const getDisplayName = (challenge) => {
    return challenge.custom_name || challenge.name;
  };

  // Show loading while checking auth
  if (loading) {
    return (
      <Layout>
        <div className="max-w-2xl mx-auto px-4 py-8 flex items-center justify-center">
          <div className="glass-card-enhanced rounded-2xl p-8">
            <Loader2 className="w-8 h-8 animate-spin text-primary-500 mx-auto" />
            <p className="text-neutral-600 mt-4 text-center">Checking admin access...</p>
          </div>
        </div>
      </Layout>
    );
  }

  // Don't render anything if user is not admin (redirect will happen)
  if (!user || !isAdmin) {
    return null;
  }

  return (
    <Layout>
      <div className="max-w-7xl mx-auto px-4 py-8">
        <div className="mb-12">
          <div className="flex items-start justify-between mb-8">
            <div>
              <div className="flex items-center gap-4 mb-4">
                <Link href="/admin" className="text-primary-600 hover:text-primary-700 transition-colors">
                  <ChevronLeft className="w-8 h-8 icon-adaptive-shadow" />
                </Link>
                
                <div className="relative">
                  <Settings className="w-10 h-10 text-primary-600 icon-adaptive-shadow" />
                </div>
                
                {/* Header with adaptive text shadow */}
                <h1 
                  className="text-4xl font-bold text-neutral-800 text-white/90 text-adaptive-shadow"
                  data-text="Challenge Management"
                >
                  Challenge Management
                </h1>
              </div>
              
              {/* Description */}
              <p className="text-neutral-600 text-lg max-w-3xl text-white/85 text-adaptive-shadow">
                Edit challenge names, manage rulesets, and configure display settings across all seasons. 
                Challenges are sorted by date ended (most recent first).
              </p>
            </div>
          </div>
        </div>

        {/* Enhanced Summary Cards */}
        <div className="grid grid-cols-2 md:grid-cols-5 gap-4 mb-8">
          <div className="bg-gradient-to-r from-blue-50 to-blue-100 p-4 rounded-xl border border-blue-200">
            <div className="text-2xl font-bold text-blue-700">{summary.total || 0}</div>
            <div className="text-sm text-blue-600">Total Challenges</div>
          </div>
          <div className="bg-gradient-to-r from-green-50 to-green-100 p-4 rounded-xl border border-green-200">
            <div className="text-2xl font-bold text-green-700">{summary.active || 0}</div>
            <div className="text-sm text-green-600">Active</div>
          </div>
          <div className="bg-gradient-to-r from-purple-50 to-purple-100 p-4 rounded-xl border border-purple-200">
            <div className="text-2xl font-bold text-purple-700">{summary.withCustomNames || 0}</div>
            <div className="text-sm text-purple-600">Custom Names</div>
          </div>
          <div className="bg-gradient-to-r from-yellow-50 to-yellow-100 p-4 rounded-xl border border-yellow-200">
            <div className="text-2xl font-bold text-yellow-700">{summary.withRulesets || 0}</div>
            <div className="text-sm text-yellow-600">With Rulesets</div>
          </div>
          <div className="bg-gradient-to-r from-orange-50 to-orange-100 p-4 rounded-xl border border-orange-200">
            <div className="text-2xl font-bold text-orange-700">{summary.inactive || 0}</div>
            <div className="text-sm text-orange-600">Inactive</div>
          </div>
        </div>

        {/* Enhanced Filters */}
        <div className="bg-white rounded-xl border border-neutral-200 p-6 mb-6">
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
            
            {/* Status Filter */}
            <div>
              <label className="block text-sm font-medium text-neutral-700 mb-2">
                Status
              </label>
              <select
                value={filters.status}
                onChange={(e) => updateFilters({ status: e.target.value })}
                className="w-full px-3 py-2 border border-neutral-300 rounded-lg focus:outline-none focus:border-primary-500 focus:ring-2 focus:ring-primary-200"
              >
                <option value="">All Challenges</option>
                <option value="active">Active Only</option>
                <option value="inactive">Inactive Only</option>
              </select>
            </div>
            
            {/* Custom Name Filter */}
            <div>
              <label className="block text-sm font-medium text-neutral-700 mb-2">
                Name Type
              </label>
              <select
                value={filters.hasCustomName}
                onChange={(e) => updateFilters({ hasCustomName: e.target.value })}
                className="w-full px-3 py-2 border border-neutral-300 rounded-lg focus:outline-none focus:border-primary-500 focus:ring-2 focus:ring-primary-200"
              >
                <option value="">All Names</option>
                <option value="true">Custom Names Only</option>
                <option value="false">Original Names Only</option>
              </select>
            </div>
            
            {/* Ruleset Filter */}
            <div>
              <label className="block text-sm font-medium text-neutral-700 mb-2">
                Ruleset
              </label>
              <select
                value={filters.hasRuleset}
                onChange={(e) => updateFilters({ hasRuleset: e.target.value })}
                className="w-full px-3 py-2 border border-neutral-300 rounded-lg focus:outline-none focus:border-primary-500 focus:ring-2 focus:ring-primary-200"
              >
                <option value="">All Challenges</option>
                <option value="true">With Rulesets</option>
                <option value="false">No Rulesets</option>
              </select>
            </div>
            
            {/* Season Filter */}
            <div>
              <label className="block text-sm font-medium text-neutral-700 mb-2">
                Season
              </label>
              <SeasonSelector 
                onSeasonChange={(season) => updateFilters({ season_id: season?.id || '' })}
                currentSeasonId={filters.season_id}
                showAllOption={true}
              />
            </div>
          </div>
        </div>

        {/* Results */}
        {result && (
          <div className={`mb-6 p-4 rounded-lg flex items-start gap-3 ${
            result.success 
              ? 'bg-green-50 border border-green-200' 
              : 'bg-red-50 border border-red-200'
          }`}>
            {result.success ? (
              <CheckCircle className="w-5 h-5 text-green-600 flex-shrink-0 mt-0.5" />
            ) : (
              <AlertCircle className="w-5 h-5 text-red-600 flex-shrink-0 mt-0.5" />
            )}
            <div className="flex-1">
              <p className={result.success ? 'text-green-800' : 'text-red-800'}>
                {result.message || result.error}
              </p>
            </div>
            <button 
              onClick={() => setResult(null)}
              className="text-neutral-400 hover:text-neutral-600"
            >
              <X className="w-5 h-5" />
            </button>
          </div>
        )}

        {/* Table */}
        <div className="bg-white rounded-xl border border-neutral-200 overflow-hidden">
          {loadingChallenges ? (
            <div className="flex items-center justify-center py-12">
              <Loader2 className="w-8 h-8 animate-spin text-primary-500" />
            </div>
          ) : challenges.length === 0 ? (
            <div className="text-center py-12">
              <Filter className="w-12 h-12 mx-auto mb-3 text-neutral-300" />
              <p className="text-neutral-500">No challenges found matching your filters</p>
              <button 
                onClick={() => updateFilters({ search: '', status: '', season_id: '', hasCustomName: '', hasRuleset: '' })}
                className="mt-2 text-primary-600 hover:text-primary-700 text-sm font-medium"
              >
                Clear all filters
              </button>
            </div>
          ) : (
            <>
              <div className="overflow-x-auto">
                <table className="w-full">
                  <thead className="bg-neutral-50">
                    <tr>
                      <th className="px-6 py-3 text-left text-xs font-medium text-neutral-500 uppercase tracking-wider">
                        Room ID
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-neutral-500 uppercase tracking-wider">
                        Challenge Name
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-neutral-500 uppercase tracking-wider">
                        Status
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-neutral-500 uppercase tracking-wider">
                        Participants
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-neutral-500 uppercase tracking-wider">
                        Date Ended
                      </th>
                      <th className="px-6 py-3 text-center text-xs font-medium text-neutral-500 uppercase tracking-wider">
                        Actions
                      </th>
                    </tr>
                  </thead>
                  <tbody className="divide-y divide-neutral-100">
                    {challenges.map((challenge) => {
                      const isEditing = editingChallenge === challenge.room_id;
                      const isSaving = savingChanges.has(challenge.room_id);
                      const rulesetName = generateRulesetDisplayName(challenge);
                      
                      return (
                        <tr key={challenge.id} className="hover:bg-neutral-50 transition-colors">
                          <td className="px-6 py-4 text-sm font-mono text-neutral-600">
                            {challenge.room_id}
                          </td>
                          <td className="px-6 py-4">
                            {isEditing ? (
                              <div className="flex items-center gap-2">
                                <input
                                  type="text"
                                  value={editingName}
                                  onChange={(e) => setEditingName(e.target.value)}
                                  className="flex-1 px-3 py-2 text-sm border border-blue-300 rounded-md focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-200"
                                  placeholder="Enter challenge name..."
                                  maxLength="500"
                                  disabled={isSaving}
                                />
                                <button
                                  onClick={() => saveChallengeName(challenge.room_id)}
                                  disabled={isSaving || !editingName.trim()}
                                  className="px-3 py-2 bg-green-500 hover:bg-green-600 disabled:bg-gray-300 text-white rounded-md text-xs font-medium transition-colors flex items-center gap-1"
                                >
                                  {isSaving ? <Loader2 className="w-3 h-3 animate-spin" /> : <Save className="w-3 h-3" />}
                                </button>
                                <button
                                  onClick={cancelEditing}
                                  disabled={isSaving}
                                  className="px-3 py-2 bg-gray-500 hover:bg-gray-600 disabled:bg-gray-300 text-white rounded-md text-xs font-medium transition-colors"
                                >
                                  <X className="w-3 h-3" />
                                </button>
                              </div>
                            ) : (
                              <div className="flex items-center gap-2">
                                <div className="flex-1">
                                  <div className="font-medium text-neutral-800">
                                    {getDisplayName(challenge)}
                                    {challenge.custom_name && (
                                      <span className="ml-2 text-xs text-purple-600 font-medium bg-purple-100 px-2 py-0.5 rounded-full">
                                        Custom
                                      </span>
                                    )}
                                    {/* Ruleset indicator with generated name */}
                                    {challenge.has_ruleset && rulesetName && (
                                      <span className="ml-2 inline-flex items-center gap-1 text-xs bg-yellow-100 text-yellow-800 px-2 py-1 rounded-full font-medium">
                                        <Crown className="w-3 h-3" />
                                        {rulesetName}
                                      </span>
                                    )}
                                  </div>
                                  {challenge.custom_name && (
                                    <div className="text-sm text-neutral-500 mt-1">
                                      Original: {challenge.name}
                                    </div>
                                  )}
                                  {challenge.seasons && (
                                    <div className="text-xs text-neutral-400 mt-1">
                                      {challenge.seasons.name}
                                    </div>
                                  )}
                                </div>
                              </div>
                            )}
                          </td>
                          <td className="px-6 py-4">
                            <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
                              challenge.is_active 
                                ? 'bg-green-100 text-green-800' 
                                : 'bg-gray-100 text-gray-800'
                            }`}>
                              {challenge.is_active ? 'Active' : 'Inactive'}
                            </span>
                          </td>
                          <td className="px-6 py-4 text-sm text-neutral-600">
                            <div className="flex items-center gap-1">
                              <Users className="w-4 h-4 text-neutral-400" />
                              {challenge.participant_count || 0}
                            </div>
                          </td>
                          <td className="px-6 py-4 text-sm text-neutral-500">
                            <div className="flex items-center gap-1">
                              <Clock className="w-4 h-4 text-neutral-400" />
                              {challenge.end_date ? formatDate(challenge.end_date) : 'Still active'}
                            </div>
                          </td>
                          <td className="px-6 py-4">
                            <div className="flex items-center justify-center gap-2">
                              {!isEditing && (
                                <>
                                  {/* Ruleset Management Button */}
                                  <button
                                    onClick={() => handleManageRuleset(challenge)}
                                    disabled={isSaving}
                                    className="p-2 text-yellow-600 hover:text-yellow-700 hover:bg-yellow-50 rounded-md transition-colors disabled:opacity-50"
                                    title="Manage Ruleset"
                                  >
                                    <Target className="w-4 h-4" />
                                  </button>
                                  
                                  <button
                                    onClick={() => startEditing(challenge)}
                                    disabled={isSaving}
                                    className="p-2 text-blue-500 hover:text-blue-700 hover:bg-blue-50 rounded-md transition-colors disabled:opacity-50"
                                    title="Edit challenge name"
                                  >
                                    <Edit2 className="w-4 h-4" />
                                  </button>
                                  {challenge.custom_name && (
                                    <button
                                      onClick={() => resetChallengeName(challenge.room_id)}
                                      disabled={isSaving}
                                      className="p-2 text-orange-500 hover:text-orange-700 hover:bg-orange-50 rounded-md transition-colors disabled:opacity-50"
                                      title="Reset to original name"
                                    >
                                      {isSaving ? (
                                        <Loader2 className="w-4 h-4 animate-spin" />
                                      ) : (
                                        <RotateCcw className="w-4 h-4" />
                                      )}
                                    </button>
                                  )}
                                  
                                  {/* Delete Button */}
                                  <button
                                    onClick={() => startDelete(challenge)}
                                    disabled={isSaving}
                                    className="p-2 text-red-500 hover:text-red-700 hover:bg-red-50 rounded-md transition-colors disabled:opacity-50"
                                    title="Delete challenge"
                                  >
                                    <Trash2 className="w-4 h-4" />
                                  </button>
                                  
                                  <Link href={`/challenges/${challenge.room_id}`}>
                                    <button
                                      className="p-2 text-neutral-500 hover:text-neutral-700 hover:bg-neutral-50 rounded-md transition-colors"
                                      title="View challenge"
                                    >
                                      <Eye className="w-4 h-4" />
                                    </button>
                                  </Link>
                                </>
                              )}
                            </div>
                          </td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>

              {/* Pagination */}
              {pagination.totalPages > 1 && (
                <div className="px-6 py-4 border-t border-neutral-200">
                  <div className="flex items-center justify-between">
                    <div className="text-sm text-neutral-700">
                      Showing {pagination.offset + 1} to {Math.min(pagination.offset + pagination.limit, pagination.total)} of {pagination.total} challenges
                    </div>
                    <div className="flex items-center gap-2">
                      <button
                        onClick={() => changePage(Math.max(0, pagination.offset - pagination.limit))}
                        disabled={!pagination.hasPrev}
                        className="px-3 py-2 border border-neutral-300 rounded-md text-sm font-medium text-neutral-700 hover:bg-neutral-50 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-1"
                      >
                        <ChevronLeft className="w-4 h-4" />
                        Previous
                      </button>
                      <span className="px-3 py-2 text-sm text-neutral-600">
                        Page {pagination.currentPage} of {pagination.totalPages}
                      </span>
                      <button
                        onClick={() => changePage(pagination.offset + pagination.limit)}
                        disabled={!pagination.hasNext}
                        className="px-3 py-2 border border-neutral-300 rounded-md text-sm font-medium text-neutral-700 hover:bg-neutral-50 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-1"
                      >
                        Next
                        <ChevronRight className="w-4 h-4" />
                      </button>
                    </div>
                  </div>
                </div>
              )}
            </>
          )}
        </div>

        {/* Delete Confirmation Modal */}
        {challengeToDelete && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
            <div className="bg-white rounded-xl max-w-md w-full p-6">
              <div className="flex items-start gap-4 mb-4">
                <div className="flex-shrink-0 w-10 h-10 bg-red-100 rounded-full flex items-center justify-center">
                  <AlertCircle className="w-6 h-6 text-red-600" />
                </div>
                <div className="flex-1">
                  <h3 className="text-lg font-semibold text-neutral-900 mb-2">
                    Delete Challenge
                  </h3>
                  <p className="text-neutral-600 mb-4">
                    You are about to permanently delete:
                  </p>
                  <div className="bg-red-50 border border-red-200 rounded-lg p-3 mb-4">
                    <div className="font-medium text-red-800">
                      {getDisplayName(challengeToDelete)} (Room #{challengeToDelete.room_id})
                    </div>
                    <div className="text-sm text-red-600 mt-1">
                      {challengeToDelete.participant_count || 0} participants ‚Ä¢ {challengeToDelete.is_active ? 'Active' : 'Inactive'}
                    </div>
                  </div>
                  <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-3 mb-4">
                    <div className="text-sm text-yellow-800">
                      <strong>Warning:</strong> This action cannot be undone. All associated playlists, scores, and user participation data will be permanently deleted.
                    </div>
                  </div>
                  <div className="mb-4">
                    <label className="block text-sm font-medium text-neutral-700 mb-2">
                      Type <code className="bg-gray-100 px-1 rounded text-red-600 font-mono">DELETE {challengeToDelete.room_id}</code> to confirm:
                    </label>
                    <input
                      type="text"
                      value={deleteConfirmText}
                      onChange={(e) => setDeleteConfirmText(e.target.value)}
                      className="w-full px-3 py-2 border border-neutral-300 rounded-lg focus:outline-none focus:border-red-500 focus:ring-2 focus:ring-red-200"
                      placeholder={`DELETE ${challengeToDelete.room_id}`}
                      disabled={deleting}
                    />
                  </div>
                </div>
              </div>
              
              <div className="flex gap-3 justify-end">
                <button
                  onClick={cancelDelete}
                  disabled={deleting}
                  className="px-4 py-2 text-neutral-700 border border-neutral-300 rounded-lg hover:bg-neutral-50 disabled:opacity-50 transition-colors"
                >
                  Cancel
                </button>
                <button
                  onClick={confirmDelete}
                  disabled={deleting || deleteConfirmText !== `DELETE ${challengeToDelete.room_id}`}
                  className="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2"
                >
                  {deleting ? (
                    <>
                      <Loader2 className="w-4 h-4 animate-spin" />
                      Deleting...
                    </>
                  ) : (
                    <>
                      <Trash2 className="w-4 h-4" />
                      Delete Challenge
                    </>
                  )}
                </button>
              </div>
            </div>
          </div>
        )}

        {/* Ruleset Manager Modal */}
        {showRulesetManager && selectedChallengeForRuleset && (
          <RulesetManager
            challengeId={selectedChallengeForRuleset.id}
            onClose={() => {
              setShowRulesetManager(false);
              setSelectedChallengeForRuleset(null);
            }}
            onSuccess={handleRulesetSuccess}
          />
        )}
      </div>
    </Layout>
  );
}


================================================
FILE: frontend/pages/admin/schedules.js
================================================
import { useState, useEffect, useCallback } from 'react';
import Link from 'next/link';
import Layout from '../../components/Layout';
import { 
  Loader2, Calendar, Clock, ChevronLeft, ChevronRight, X, Eye, 
  CheckCircle, AlertCircle, XCircle, Pause, Play, Trash2, Edit2,
  Save, RotateCcw, ExternalLink, Target, Music, MessageSquare
} from 'lucide-react';
import { useAuth } from '../../lib/AuthContext';
import { useRouter } from 'next/router';

export default function AdminScheduledChallenges() {
  const { user, loading: authLoading, isAdmin } = useAuth();
  const router = useRouter();
  
  const [schedules, setSchedules] = useState([]);
  const [loading, setLoading] = useState(true);
  const [pagination, setPagination] = useState({});
  const [result, setResult] = useState(null);
  
  // Filters
  const [filters, setFilters] = useState({
    status: 'pending',
    limit: 25,
    offset: 0
  });
  
  // Edit modal state
  const [editingSchedule, setEditingSchedule] = useState(null);
  const [editForm, setEditForm] = useState({});
  const [saving, setSaving] = useState(false);
  
  // Delete confirmation
  const [deleteConfirm, setDeleteConfirm] = useState(null);
  const [deleting, setDeleting] = useState(false);

  // Load schedules
  const loadSchedules = useCallback(async () => {
    setLoading(true);
    
    try {
      const params = new URLSearchParams();
      Object.entries(filters).forEach(([key, value]) => {
        if (value !== '' && value !== null && value !== undefined) {
          params.append(key, value.toString());
        }
      });

      const response = await fetch(`/api/admin/schedules?${params}`, {
        credentials: 'include'
      });

      if (!response.ok) {
        throw new Error('Failed to load schedules');
      }

      const data = await response.json();
      
      if (data.success) {
        setSchedules(data.data?.schedules || data.schedules || []);
        setPagination(data.data?.pagination || data.pagination || {});
      } else {
        throw new Error(data.error || 'Failed to load schedules');
      }
    } catch (error) {
      console.error('Error loading schedules:', error);
      setResult({
        success: false,
        error: error.message
      });
    } finally {
      setLoading(false);
    }
  }, [filters]);

  // Auth check
  useEffect(() => {
    if (!authLoading) {
      if (!user) {
        router.push('/');
        return;
      }
      if (!isAdmin) {
        router.push('/admin');
        return;
      }
    }
  }, [user, authLoading, isAdmin, router]);

  // Load on filter change
  useEffect(() => {
    if (user && isAdmin && !authLoading) {
      loadSchedules();
    }
  }, [user, isAdmin, authLoading, loadSchedules]);

  const updateFilters = (newFilters) => {
    setFilters(prev => ({
      ...prev,
      ...newFilters,
      offset: 0
    }));
  };

  const changePage = (newOffset) => {
    setFilters(prev => ({ ...prev, offset: newOffset }));
  };

  // Cancel a schedule
  const handleCancel = async (schedule) => {
    if (!deleteConfirm || deleteConfirm.id !== schedule.id) {
      setDeleteConfirm(schedule);
      return;
    }

    setDeleting(true);
    
    try {
      const response = await fetch('/api/admin/schedules', {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ id: schedule.id })
      });

      const data = await response.json();

      if (response.ok && data.success) {
        setResult({
          success: true,
          message: 'Schedule cancelled successfully'
        });
        setDeleteConfirm(null);
        loadSchedules();
      } else {
        throw new Error(data.error || 'Failed to cancel schedule');
      }
    } catch (error) {
      console.error('Error cancelling schedule:', error);
      setResult({
        success: false,
        error: error.message
      });
    } finally {
      setDeleting(false);
    }
  };

  // Helper: Convert UTC date string to local datetime-local input value
  const utcToLocalInput = (utcDateString) => {
    const date = new Date(utcDateString);
    // Get local ISO string by adjusting for timezone offset
    const offset = date.getTimezoneOffset();
    const localDate = new Date(date.getTime() - offset * 60 * 1000);
    return localDate.toISOString().slice(0, 16);
  };

  // Helper: Convert local datetime-local input value to UTC ISO string
  const localInputToUtc = (localDateString) => {
    // The input value is in local time, so we just create a date and convert to ISO
    return new Date(localDateString).toISOString();
  };

  // Open edit modal
  const handleEdit = (schedule) => {
    setEditingSchedule(schedule);
    setEditForm({
      scheduled_time: utcToLocalInput(schedule.scheduled_time),
      room_name: schedule.room_data?.name || '',
      chat_messages: schedule.chat_messages?.join('\n') || '',
      // Ruleset config
      has_ruleset: !!schedule.ruleset_config,
      ruleset_match_type: schedule.ruleset_config?.ruleset_match_type || 'at_least',
      required_mods_display: schedule.ruleset_config?.required_mods?.map(m => m.acronym).join(', ') || ''
    });
  };

  // Save edit
  const handleSaveEdit = async () => {
    if (!editingSchedule) return;
    
    setSaving(true);
    
    try {
      const updates = {
        id: editingSchedule.id
      };

      // Only include changed fields - convert local input back to UTC
      const newScheduledTime = localInputToUtc(editForm.scheduled_time);
      if (newScheduledTime !== editingSchedule.scheduled_time) {
        updates.scheduled_time = newScheduledTime;
      }

      // Update room name if changed
      if (editForm.room_name !== editingSchedule.room_data?.name) {
        updates.room_data = {
          ...editingSchedule.room_data,
          name: editForm.room_name
        };
      }

      // Update chat messages if changed
      const newChatMessages = editForm.chat_messages.split('\n').filter(m => m.trim());
      if (JSON.stringify(newChatMessages) !== JSON.stringify(editingSchedule.chat_messages)) {
        updates.chat_messages = newChatMessages;
      }

      const response = await fetch('/api/admin/schedules', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(updates)
      });

      const data = await response.json();

      if (response.ok && data.success) {
        setResult({
          success: true,
          message: 'Schedule updated successfully'
        });
        setEditingSchedule(null);
        loadSchedules();
      } else {
        throw new Error(data.error || 'Failed to update schedule');
      }
    } catch (error) {
      console.error('Error updating schedule:', error);
      setResult({
        success: false,
        error: error.message
      });
    } finally {
      setSaving(false);
    }
  };

  // Format date for display
  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  // Get time until scheduled
  const getTimeUntil = (dateString) => {
    const now = new Date();
    const scheduled = new Date(dateString);
    const diff = scheduled - now;
    
    if (diff < 0) return 'Overdue';
    
    const hours = Math.floor(diff / (1000 * 60 * 60));
    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
    
    if (hours > 24) {
      const days = Math.floor(hours / 24);
      return `${days}d ${hours % 24}h`;
    }
    return `${hours}h ${minutes}m`;
  };

  // Status badge
  const getStatusBadge = (status) => {
    const badges = {
      pending: { color: 'bg-yellow-100 text-yellow-800', icon: Clock, label: 'Pending' },
      completed: { color: 'bg-green-100 text-green-800', icon: CheckCircle, label: 'Completed' },
      failed: { color: 'bg-red-100 text-red-800', icon: XCircle, label: 'Failed' },
      cancelled: { color: 'bg-gray-100 text-gray-800', icon: Pause, label: 'Cancelled' }
    };
    
    const badge = badges[status] || badges.pending;
    const Icon = badge.icon;
    
    return (
      <span className={`inline-flex items-center gap-1 px-2.5 py-0.5 rounded-full text-xs font-medium ${badge.color}`}>
        <Icon className="w-3 h-3" />
        {badge.label}
      </span>
    );
  };

  // Loading state
  if (authLoading) {
    return (
      <Layout>
        <div className="max-w-2xl mx-auto px-4 py-8 flex items-center justify-center">
          <div className="glass-card-enhanced rounded-2xl p-8">
            <Loader2 className="w-8 h-8 animate-spin text-primary-500 mx-auto" />
            <p className="text-neutral-600 mt-4 text-center">Checking admin access...</p>
          </div>
        </div>
      </Layout>
    );
  }

  if (!user || !isAdmin) {
    return null;
  }

  return (
    <Layout>
      <div className="min-h-screen py-8">
        <div className="max-w-7xl mx-auto px-4">
          {/* Header - matching admin panel style */}
          <div className="mb-12">
            <div className="flex items-start justify-between mb-8">
              <div>
                <div className="flex items-center gap-4 mb-4">
                  <Link href="/admin" className="text-primary-600 hover:text-primary-700 transition-colors">
                    <ChevronLeft className="w-8 h-8 icon-adaptive-shadow" />
                  </Link>
                  
                  <div className="relative">
                    <Calendar className="w-10 h-10 text-primary-600 icon-adaptive-shadow" />
                  </div>
                  
                  {/* Header with adaptive text shadow */}
                  <h1 
                    className="text-4xl font-bold text-neutral-800 text-white/90 text-adaptive-shadow"
                    data-text="Scheduled Challenges"
                  >
                    Scheduled Challenges
                  </h1>
                </div>
                
                {/* Description */}
                <p className="text-neutral-600 text-lg max-w-3xl text-white/85 text-adaptive-shadow">
                  View and manage scheduled challenge creations. Cancel or edit pending schedules before they execute.
                </p>
              </div>
            </div>
          </div>

          {/* Filters - matching admin panel style */}
          <div className="glass-card-enhanced rounded-2xl p-6 mb-6 border border-neutral-200/60 bg-gradient-to-br from-white/80 to-neutral-50/80 backdrop-blur-lg">
            <div className="flex flex-wrap gap-4 items-end justify-between">
              <div>
                <label className="block text-sm font-medium text-neutral-700 mb-2">Status</label>
                <select
                  value={filters.status}
                  onChange={(e) => updateFilters({ status: e.target.value })}
                  className="px-4 py-2.5 border border-neutral-300/60 rounded-xl focus:outline-none focus:ring-2 focus:ring-primary-200 focus:border-primary-500 bg-white/80 backdrop-blur-sm transition-all"
                >
                  <option value="">All</option>
                  <option value="pending">Pending</option>
                  <option value="completed">Completed</option>
                  <option value="failed">Failed</option>
                  <option value="cancelled">Cancelled</option>
                </select>
              </div>
              
              <button
                onClick={loadSchedules}
                className="flex items-center gap-2 bg-gradient-to-r from-primary-600 to-blue-600 hover:from-primary-700 hover:to-blue-700 text-white px-5 py-2.5 rounded-xl font-medium transition-all shadow-lg hover:shadow-xl transform hover:scale-105"
              >
                <RotateCcw className="w-4 h-4" />
                Refresh
              </button>
            </div>
          </div>

        {/* Results notification */}
        {result && (
          <div className={`mb-6 p-4 rounded-lg flex items-start gap-3 ${
            result.success 
              ? 'bg-green-50 border border-green-200' 
              : 'bg-red-50 border border-red-200'
          }`}>
            {result.success ? (
              <CheckCircle className="w-5 h-5 text-green-600 flex-shrink-0 mt-0.5" />
            ) : (
              <AlertCircle className="w-5 h-5 text-red-600 flex-shrink-0 mt-0.5" />
            )}
            <div className="flex-1">
              <p className={result.success ? 'text-green-800' : 'text-red-800'}>
                {result.message || result.error}
              </p>
            </div>
            <button onClick={() => setResult(null)} className="text-neutral-400 hover:text-neutral-600">
              <X className="w-5 h-5" />
            </button>
          </div>
        )}

        {/* Table - matching admin panel style */}
        <div className="glass-card-enhanced rounded-2xl border border-neutral-200/60 bg-white/80 backdrop-blur-lg overflow-hidden">
          {loading ? (
            <div className="flex items-center justify-center py-12">
              <Loader2 className="w-8 h-8 animate-spin text-primary-500" />
            </div>
          ) : schedules.length === 0 ? (
            <div className="text-center py-12">
              <div className="w-16 h-16 mx-auto mb-4 bg-gradient-to-br from-neutral-300 to-neutral-400 rounded-2xl flex items-center justify-center">
                <Calendar className="w-8 h-8 text-white" />
              </div>
              <p className="text-neutral-600 font-medium mb-2">No scheduled challenges found</p>
              <p className="text-sm text-neutral-500">Schedules created from the playlist scheduler will appear here.</p>
            </div>
          ) : (
            <>
              <div className="overflow-x-auto">
                <table className="w-full">
                  <thead className="bg-neutral-50">
                    <tr>
                      <th className="px-6 py-3 text-left text-xs font-medium text-neutral-500 uppercase">ID</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-neutral-500 uppercase">Room Name</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-neutral-500 uppercase">Scheduled For</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-neutral-500 uppercase">Status</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-neutral-500 uppercase">Details</th>
                      <th className="px-6 py-3 text-center text-xs font-medium text-neutral-500 uppercase">Actions</th>
                    </tr>
                  </thead>
                  <tbody className="divide-y divide-neutral-100">
                    {schedules.map((schedule) => (
                      <tr key={schedule.id} className="hover:bg-neutral-50 transition-colors">
                        <td className="px-6 py-4 text-sm font-mono text-neutral-600">
                          #{schedule.id}
                        </td>
                        <td className="px-6 py-4">
                          <div className="font-medium text-neutral-800">
                            {schedule.room_data?.name || 'Unnamed'}
                          </div>
                          <div className="flex items-center gap-3 mt-1 text-sm text-neutral-500">
                            <span className="flex items-center gap-1">
                              <Music className="w-3 h-3" />
                              {schedule.room_data?.playlist?.length || 0} maps
                            </span>
                            {schedule.chat_messages?.length > 0 && (
                              <span className="flex items-center gap-1">
                                <MessageSquare className="w-3 h-3" />
                                {schedule.chat_messages.length} msgs
                              </span>
                            )}
                            {schedule.ruleset_config && (
                              <span className="flex items-center gap-1 text-yellow-600">
                                <Target className="w-3 h-3" />
                                Ruleset
                              </span>
                            )}
                          </div>
                        </td>
                        <td className="px-6 py-4">
                          <div className="text-sm text-neutral-800">
                            {formatDate(schedule.scheduled_time)}
                          </div>
                          {schedule.status === 'pending' && (
                            <div className="text-xs text-neutral-500 mt-1">
                              In {getTimeUntil(schedule.scheduled_time)}
                            </div>
                          )}
                        </td>
                        <td className="px-6 py-4">
                          {getStatusBadge(schedule.status)}
                          {schedule.error_message && (
                            <div className="text-xs text-red-600 mt-1 max-w-xs truncate" title={schedule.error_message}>
                              {schedule.error_message}
                            </div>
                          )}
                        </td>
                        <td className="px-6 py-4 text-sm">
                          {schedule.created_room_id && (
                            <a
                              href={`https://osu.ppy.sh/multiplayer/rooms/${schedule.created_room_id}`}
                              target="_blank"
                              rel="noopener noreferrer"
                              className="flex items-center gap-1 text-primary-600 hover:text-primary-700"
                            >
                              Room #{schedule.created_room_id}
                              <ExternalLink className="w-3 h-3" />
                            </a>
                          )}
                          {schedule.executed_at && (
                            <div className="text-xs text-neutral-500 mt-1">
                              Executed: {formatDate(schedule.executed_at)}
                            </div>
                          )}
                        </td>
                        <td className="px-6 py-4">
                          <div className="flex items-center justify-center gap-2">
                            {schedule.status === 'pending' && (
                              <>
                                <button
                                  onClick={() => handleEdit(schedule)}
                                  className="p-2 text-blue-500 hover:text-blue-700 hover:bg-blue-50 rounded-md transition-colors"
                                  title="Edit schedule"
                                >
                                  <Edit2 className="w-4 h-4" />
                                </button>
                                <button
                                  onClick={() => handleCancel(schedule)}
                                  className={`p-2 rounded-md transition-colors ${
                                    deleteConfirm?.id === schedule.id
                                      ? 'bg-red-500 text-white hover:bg-red-600'
                                      : 'text-red-500 hover:text-red-700 hover:bg-red-50'
                                  }`}
                                  title={deleteConfirm?.id === schedule.id ? 'Click again to confirm' : 'Cancel schedule'}
                                  disabled={deleting}
                                >
                                  {deleting && deleteConfirm?.id === schedule.id ? (
                                    <Loader2 className="w-4 h-4 animate-spin" />
                                  ) : (
                                    <Trash2 className="w-4 h-4" />
                                  )}
                                </button>
                              </>
                            )}
                            {schedule.created_room_id && (
                              <Link href={`/challenges/${schedule.created_room_id}`}>
                                <button
                                  className="p-2 text-neutral-500 hover:text-neutral-700 hover:bg-neutral-50 rounded-md transition-colors"
                                  title="View challenge"
                                >
                                  <Eye className="w-4 h-4" />
                                </button>
                              </Link>
                            )}
                          </div>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>

              {/* Pagination */}
              {pagination.total > pagination.limit && (
                <div className="px-6 py-4 border-t border-neutral-200">
                  <div className="flex items-center justify-between">
                    <div className="text-sm text-neutral-700">
                      Showing {pagination.offset + 1} to {Math.min(pagination.offset + pagination.limit, pagination.total)} of {pagination.total}
                    </div>
                    <div className="flex items-center gap-2">
                      <button
                        onClick={() => changePage(Math.max(0, pagination.offset - pagination.limit))}
                        disabled={!pagination.hasPrev}
                        className="px-3 py-2 border border-neutral-300 rounded-md text-sm font-medium text-neutral-700 hover:bg-neutral-50 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-1"
                      >
                        <ChevronLeft className="w-4 h-4" />
                        Previous
                      </button>
                      <button
                        onClick={() => changePage(pagination.offset + pagination.limit)}
                        disabled={!pagination.hasNext}
                        className="px-3 py-2 border border-neutral-300 rounded-md text-sm font-medium text-neutral-700 hover:bg-neutral-50 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-1"
                      >
                        Next
                        <ChevronRight className="w-4 h-4" />
                      </button>
                    </div>
                  </div>
                </div>
              )}
            </>
          )}
        </div>

        {/* Edit Modal */}
        {editingSchedule && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
            <div className="bg-white rounded-xl max-w-lg w-full p-6">
              <div className="flex items-center justify-between mb-6">
                <h2 className="text-xl font-bold text-neutral-800">Edit Schedule #{editingSchedule.id}</h2>
                <button
                  onClick={() => setEditingSchedule(null)}
                  className="text-neutral-400 hover:text-neutral-600"
                >
                  <X className="w-6 h-6" />
                </button>
              </div>

              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-neutral-700 mb-1">
                    Scheduled Time
                  </label>
                  <input
                    type="datetime-local"
                    value={editForm.scheduled_time}
                    onChange={(e) => setEditForm(prev => ({ ...prev, scheduled_time: e.target.value }))}
                    className="w-full px-4 py-2 border border-neutral-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500"
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium text-neutral-700 mb-1">
                    Room Name
                  </label>
                  <input
                    type="text"
                    value={editForm.room_name}
                    onChange={(e) => setEditForm(prev => ({ ...prev, room_name: e.target.value }))}
                    className="w-full px-4 py-2 border border-neutral-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500"
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium text-neutral-700 mb-1">
                    Chat Messages (one per line)
                  </label>
                  <textarea
                    value={editForm.chat_messages}
                    onChange={(e) => setEditForm(prev => ({ ...prev, chat_messages: e.target.value }))}
                    rows={4}
                    className="w-full px-4 py-2 border border-neutral-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500"
                    placeholder="Enter chat messages, one per line..."
                  />
                </div>

                {editForm.has_ruleset && (
                  <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
                    <div className="flex items-center gap-2 text-yellow-800 font-medium mb-2">
                      <Target className="w-4 h-4" />
                      Ruleset Configuration
                    </div>
                    <div className="text-sm text-yellow-700">
                      <p><strong>Match Type:</strong> {editForm.ruleset_match_type}</p>
                      <p><strong>Required Mods:</strong> {editForm.required_mods_display || 'None'}</p>
                    </div>
                    <p className="text-xs text-yellow-600 mt-2">
                      Note: Ruleset configuration cannot be edited here. Cancel and recreate if needed.
                    </p>
                  </div>
                )}

                <div className="bg-neutral-50 rounded-lg p-4">
                  <h4 className="font-medium text-neutral-700 mb-2">Playlist Preview</h4>
                  <div className="text-sm text-neutral-600">
                    {editingSchedule.room_data?.playlist?.length || 0} beatmaps configured
                  </div>
                  <p className="text-xs text-neutral-500 mt-1">
                    Playlist cannot be edited. Cancel and recreate if needed.
                  </p>
                </div>
              </div>

              <div className="flex justify-end gap-3 mt-6 pt-4 border-t border-neutral-200">
                <button
                  onClick={() => setEditingSchedule(null)}
                  disabled={saving}
                  className="px-4 py-2 text-neutral-700 border border-neutral-300 rounded-lg hover:bg-neutral-50 disabled:opacity-50"
                >
                  Cancel
                </button>
                <button
                  onClick={handleSaveEdit}
                  disabled={saving}
                  className="px-4 py-2 bg-primary-600 text-white rounded-lg hover:bg-primary-700 disabled:opacity-50 flex items-center gap-2"
                >
                  {saving ? (
                    <>
                      <Loader2 className="w-4 h-4 animate-spin" />
                      Saving...
                    </>
                  ) : (
                    <>
                      <Save className="w-4 h-4" />
                      Save Changes
                    </>
                  )}
                </button>
              </div>
            </div>
          </div>
        )}

        {/* Cancel Confirmation Toast */}
        {deleteConfirm && (
          <div className="fixed bottom-4 right-4 bg-red-600 text-white px-4 py-3 rounded-lg shadow-lg flex items-center gap-3 z-40">
            <AlertCircle className="w-5 h-5" />
            <span>Click cancel button again to confirm</span>
            <button
              onClick={() => setDeleteConfirm(null)}
              className="text-red-200 hover:text-white"
            >
              <X className="w-4 h-4" />
            </button>
          </div>
        )}
        </div>
      </div>
    </Layout>
  );
}


================================================
FILE: frontend/pages/api/create-payment-intent.js
================================================
import Stripe from 'stripe';
import { supabaseAdmin } from '../../lib/supabase-admin';
import { withOptionalAuth } from '../../lib/auth-middleware';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);

async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const userId = req.user?.id || null;
    const username = req.user?.username || 'Guest';
    
    const {
      amount,
      currency = 'usd',
      isRecurring,
      email,
      message,
      isAnonymous,
      metadata = {}
    } = req.body;

    if (!amount || amount < 100 || amount > 100000) {
      return res.status(400).json({ 
        error: 'Invalid amount. Must be between $1.00 and $1,000.00' 
      });
    }

    const session = await stripe.checkout.sessions.create({
      payment_method_types: ['card'],
      line_items: [
        {
          price_data: {
            currency: currency,
            product_data: {
              name: isRecurring ? 'Monthly Support for osu!Challengers' : 'One-time Support for osu!Challengers',
              description: 'Thank you for supporting osu!Challengers!',
            },
            unit_amount: amount,
            ...(isRecurring && {
              recurring: {
                interval: 'month',
                interval_count: 1
              }
            })
          },
          quantity: 1,
        },
      ],
      mode: isRecurring ? 'subscription' : 'payment',
      success_url: `${process.env.NEXT_PUBLIC_APP_URL}/thank-you?session_id={CHECKOUT_SESSION_ID}&amount=${amount}`,
      cancel_url: `${process.env.NEXT_PUBLIC_APP_URL}/donate`,
      metadata: {
        userId: userId ? userId.toString() : 'guest',
        email: email || '',
        message: message || '',
        isAnonymous: isAnonymous ? 'true' : 'false',
        username: username
      },
      ...(email && { customer_email: email })
    });

    res.status(200).json({ sessionId: session.id });
  } catch (error) {
    console.error('Stripe error:', error);
    res.status(500).json({ error: error.message });
  }
}

export default withOptionalAuth(handler);


================================================
FILE: frontend/pages/api/debug-api-tracking.js
================================================
import apiTracker from '../../lib/api-tracker';
import { supabaseAdmin } from '../../lib/supabase-admin';

export default async function handler(req, res) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const currentMonth = new Date().toISOString().slice(0, 7); // "2025-06"
    
    console.log('üîç Starting comprehensive API tracking diagnostic...');
    
    // 1. Check if tables exist
    const tableChecks = {};
    
    const tables = [
      'api_usage_monthly',
      'api_endpoint_performance', 
      'api_daily_stats',
      'api_locks'
    ];

    for (const table of tables) {
      try {
        const { data, error } = await supabaseAdmin
          .from(table)
          .select('id')
          .limit(1);
        tableChecks[table] = error ? `Error: ${error.message}` : 'EXISTS';
      } catch (e) {
        tableChecks[table] = `Exception: ${e.message}`;
      }
    }

    // 2. Get current memory state
    const memoryState = {
      initialized: apiTracker.memoryCache.initialized,
      externalEndpoints: apiTracker.memoryCache.external.size,
      internalEndpoints: apiTracker.memoryCache.internal.size,
      dailyEntries: apiTracker.memoryCache.daily.size,
      pendingWrites: {
        monthly: apiTracker.pendingWrites.monthly,
        daily: apiTracker.pendingWrites.daily,
        endpoints: apiTracker.pendingWrites.endpoints.size,
        endpointsList: Array.from(apiTracker.pendingWrites.endpoints)
      },
      lastSyncTime: apiTracker.memoryCache.lastSyncTime,
      timeSinceLastSync: apiTracker.memoryCache.lastSyncTime ? 
        Math.floor((Date.now() - apiTracker.memoryCache.lastSyncTime) / 1000) : 'never'
    };

    // 3. Analyze memory cache keys for issues
    const keyAnalysis = {
      internal: {
        total: apiTracker.memoryCache.internal.size,
        sample: [],
        issues: []
      },
      external: {
        total: apiTracker.memoryCache.external.size,
        sample: [],
        issues: [],
        byApiName: {}
      }
    };

    // Analyze internal keys
    let internalCount = 0;
    for (const [key, stats] of apiTracker.memoryCache.internal.entries()) {
      if (internalCount < 5) {
        keyAnalysis.internal.sample.push({
          key,
          endpoint: stats.endpoint,
          method: stats.method,
          count: stats.count,
          lastCall: stats.lastCall
        });
      }
      
      // Check for key format issues
      const expectedKey = `${stats.method}:${stats.endpoint}`;
      if (key !== expectedKey) {
        keyAnalysis.internal.issues.push({
          key,
          expected: expectedKey,
          issue: 'KEY_FORMAT_MISMATCH'
        });
      }
      
      internalCount++;
    }

    // Analyze external keys
    let externalCount = 0;
    for (const [key, stats] of apiTracker.memoryCache.external.entries()) {
      if (externalCount < 10) {
        keyAnalysis.external.sample.push({
          key,
          endpoint: stats.endpoint,
          method: stats.method,
          apiName: stats.apiName,
          count: stats.count,
          lastCall: stats.lastCall,
          recentCallsCount: stats.recentCalls?.length || 0
        });
      }
      
      // Count by API name
      if (!keyAnalysis.external.byApiName[stats.apiName]) {
        keyAnalysis.external.byApiName[stats.apiName] = 0;
      }
      keyAnalysis.external.byApiName[stats.apiName]++;
      
      // Check for key format issues
      const expectedKey = `${stats.apiName}:${stats.method}:${stats.endpoint}`;
      if (key !== expectedKey) {
        keyAnalysis.external.issues.push({
          key,
          expected: expectedKey,
          issue: 'KEY_FORMAT_MISMATCH',
          apiName: stats.apiName
        });
      }
      
      externalCount++;
    }

    // 4. Get database records for comparison
    let dbRecordsBefore = [];
    try {
      const { data: dbData, error: dbError } = await supabaseAdmin
        .from('api_endpoint_performance')
        .select('*')
        .eq('month', currentMonth)
        .order('last_called', { ascending: false })
        .limit(200);
      
      if (dbError) {
        console.error('Database query error:', dbError);
      } else {
        dbRecordsBefore = dbData || [];
      }
    } catch (e) {
      console.error('Database query exception:', e);
    }

    // 5. Check monthly usage data
    let monthlyUsage = null;
    try {
      const { data: monthlyData, error: monthlyError } = await supabaseAdmin
        .from('api_usage_monthly')
        .select('*')
        .eq('month', currentMonth)
        .single();
      
      if (!monthlyError && monthlyData) {
        monthlyUsage = monthlyData;
      }
    } catch (e) {
      console.error('Monthly usage query error:', e);
    }

    // 6. Force a sync and check results
    console.log('üîÑ Forcing database sync...');
    let syncResult = null;
    try {
      await apiTracker.syncToDatabase();
      syncResult = { success: true, message: 'Sync completed successfully' };
      console.log('‚úÖ Sync completed');
    } catch (syncError) {
      syncResult = { success: false, error: syncError.message };
      console.error('‚ùå Sync failed:', syncError);
    }

    // 7. Get updated database records after sync
    let dbRecordsAfter = [];
    try {
      const { data: dbDataAfter, error: dbErrorAfter } = await supabaseAdmin
        .from('api_endpoint_performance')
        .select('*')
        .eq('month', currentMonth)
        .order('last_called', { ascending: false })
        .limit(200);
      
      if (!dbErrorAfter) {
        dbRecordsAfter = dbDataAfter || [];
      }
    } catch (e) {
      console.error('Post-sync database query exception:', e);
    }

    // 8. Test a simple database operation (no upsert conflicts)
    let manualTestResult = null;
    try {
      const testRecord = {
        month: currentMonth,
        endpoint: '/api/v2/test-debug-endpoint',
        method: 'GET',
        type: 'external',
        api_name: 'test-api',
        call_count: 1,
        total_duration: 100,
        error_count: 0,
        last_called: new Date().toISOString(),
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };

      // Use simple insert instead of upsert to avoid constraint issues
      const { data: insertData, error: insertError } = await supabaseAdmin
        .from('api_endpoint_performance')
        .insert([testRecord])
        .select();

      if (insertError) {
        manualTestResult = {
          success: false,
          error: insertError.message,
          data: null
        };
      } else {
        manualTestResult = {
          success: true,
          error: null,
          data: insertData
        };

        // Clean up test record
        if (insertData?.[0]?.id) {
          await supabaseAdmin
            .from('api_endpoint_performance')
            .delete()
            .eq('id', insertData[0].id);
        }
      }
    } catch (e) {
      manualTestResult = {
        success: false,
        error: e.message,
        data: null
      };
    }

    // 9. Generate recommendations based on findings
    const recommendations = [];

    // Key format issues
    if (keyAnalysis.external.issues.length > 0) {
      recommendations.push({
        type: 'critical',
        category: 'Key Format',
        message: `${keyAnalysis.external.issues.length} external endpoints have incorrect key format`,
        action: 'Run apiTracker.fixLegacyKeys() to correct key formats',
        details: keyAnalysis.external.issues.slice(0, 5)
      });
    }

    if (keyAnalysis.internal.issues.length > 0) {
      recommendations.push({
        type: 'warning',
        category: 'Key Format',
        message: `${keyAnalysis.internal.issues.length} internal endpoints have incorrect key format`,
        action: 'Check internal endpoint key generation logic'
      });
    }

    // Sync issues
    if (!syncResult?.success) {
      recommendations.push({
        type: 'critical',
        category: 'Database Sync',
        message: 'Database sync failed',
        action: 'Check database connection and constraints',
        error: syncResult?.error
      });
    }

    // Pending writes stuck
    if (memoryState.pendingWrites.endpoints > 10) {
      recommendations.push({
        type: 'warning',
        category: 'Performance',
        message: `${memoryState.pendingWrites.endpoints} endpoints pending sync`,
        action: 'Check if sync process is working correctly'
      });
    }

    // Memory vs database discrepancy
    const memoryTotal = keyAnalysis.internal.total + keyAnalysis.external.total;
    const dbTotal = dbRecordsAfter.length;
    if (Math.abs(memoryTotal - dbTotal) > 10) {
      recommendations.push({
        type: 'warning',
        category: 'Data Consistency',
        message: `Memory cache (${memoryTotal}) and database (${dbTotal}) have significant differences`,
        action: 'Investigate sync process and key format issues'
      });
    }

    // 10. Calculate statistics
    const statistics = {
      memory: {
        totalEndpoints: memoryTotal,
        internal: keyAnalysis.internal.total,
        external: keyAnalysis.external.total,
        dailyEntries: memoryState.dailyEntries,
        pendingWrites: memoryState.pendingWrites.endpoints
      },
      database: {
        totalRecords: dbRecordsAfter.length,
        byType: {
          internal: dbRecordsAfter.filter(r => r.type === 'internal').length,
          external: dbRecordsAfter.filter(r => r.type === 'external').length
        },
        byApiName: {}
      },
      sync: {
        beforeCount: dbRecordsBefore.length,
        afterCount: dbRecordsAfter.length,
        recordsAdded: dbRecordsAfter.length - dbRecordsBefore.length,
        lastSyncAgo: memoryState.timeSinceLastSync
      }
    };

    // Count database records by API name
    dbRecordsAfter.forEach(record => {
      const apiName = record.api_name || 'internal';
      if (!statistics.database.byApiName[apiName]) {
        statistics.database.byApiName[apiName] = 0;
      }
      statistics.database.byApiName[apiName]++;
    });

    return res.status(200).json({
      diagnostic: {
        timestamp: new Date().toISOString(),
        month: currentMonth,
        
        // Core status
        tableChecks,
        memoryState,
        syncResult,
        manualTest: manualTestResult,
        
        // Detailed analysis
        keyAnalysis,
        statistics,
        
        // Sample data
        sampleData: {
          memoryExternal: keyAnalysis.external.sample,
          memoryInternal: keyAnalysis.internal.sample,
          databaseRecent: dbRecordsAfter.slice(0, 5)
        },
        
        // Monthly usage
        monthlyUsage,
        
        // Actionable recommendations
        recommendations,
        
        // System info
        systemInfo: {
          nodeEnv: process.env.NODE_ENV,
          timestamp: Date.now(),
          uptime: process.uptime ? process.uptime() : 'unknown'
        }
      }
    });

  } catch (error) {
    console.error('Diagnostic error:', error);
    return res.status(500).json({
      error: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined,
      timestamp: new Date().toISOString()
    });
  }
}


================================================
FILE: frontend/pages/api/debug-room.js
================================================
import { trackedOsuAPI } from '../../lib/osu-api';

async function handler(req, res) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const { roomId, includeScores = 'true' } = req.query;

  if (!roomId) {
    return res.status(400).json({ error: 'Room ID is required' });
  }

  try {
    // Log initial usage
    trackedOsuAPI.logUsage('Before room fetch');

    const roomInfo = await trackedOsuAPI.getRoom(roomId);

    // Log usage after room fetch
    trackedOsuAPI.logUsage('After room fetch');

    let scoresInfo = null;
    
    // Fetch scores if requested and if playlists exist
    if (includeScores === 'true' && roomInfo.playlist && roomInfo.playlist.length > 0) {
      try {
        const firstPlaylist = roomInfo.playlist[0];
        console.log(`Fetching scores for playlist ${firstPlaylist.id}...`);
        
        // Get first few scores to debug the structure
        const scoresResponse = await trackedOsuAPI.getRoomScores(roomId, firstPlaylist.id, 5);
        
        trackedOsuAPI.logUsage('After scores fetch');
        
        scoresInfo = {
          playlistId: firstPlaylist.id,
          totalScores: scoresResponse.scores?.length || 0,
          hasMoreScores: !!scoresResponse.cursor_string,
          rawScoresResponse: scoresResponse,
          // Detailed analysis of first score if available
          firstScoreAnalysis: scoresResponse.scores && scoresResponse.scores.length > 0 ? {
            allKeys: Object.keys(scoresResponse.scores[0]),
            dateTimeFields: Object.keys(scoresResponse.scores[0]).filter(key => 
              key.includes('date') || key.includes('time') || key.includes('at') || key.includes('created') || key.includes('submitted')
            ),
            scoreStructure: scoresResponse.scores[0],
            // Check specific timestamp fields
            timestamps: {
              created_at: scoresResponse.scores[0].created_at,
              ended_at: scoresResponse.scores[0].ended_at,
              started_at: scoresResponse.scores[0].started_at,
              submitted_at: scoresResponse.scores[0].submitted_at,
            }
          } : null,
          // Sample of all scores with just key fields
          scoresSample: scoresResponse.scores?.slice(0, 3).map(score => ({
            id: score.id,
            user_id: score.user_id,
            username: score.user?.username,
            total_score: score.total_score,
            score: score.score,
            accuracy: score.accuracy,
            created_at: score.created_at,
            ended_at: score.ended_at,
            started_at: score.started_at,
            position: score.position,
            allDateFields: Object.keys(score).filter(key => 
              key.includes('date') || key.includes('time') || key.includes('at')
            ).reduce((obj, key) => {
              obj[key] = score[key];
              return obj;
            }, {})
          })) || []
        };
        
      } catch (scoresError) {
        console.error('Error fetching scores:', scoresError);
        scoresInfo = {
          error: 'Failed to fetch scores',
          details: scoresError.message
        };
      }
    }

    // Return comprehensive debug information
    res.status(200).json({
      success: true,
      roomId,
      // Room information
      roomInfo: {
        id: roomInfo.id,
        name: roomInfo.name,
        host: roomInfo.host?.username,
        playlistCount: roomInfo.playlist?.length || 0,
        rawResponse: roomInfo
      },
      // Playlist structure
      playlistInfo: roomInfo.playlist?.[0] ? {
        id: roomInfo.playlist[0].id,
        beatmap_id: roomInfo.playlist[0].beatmap_id,
        structure: Object.keys(roomInfo.playlist[0]),
        sample: roomInfo.playlist[0]
      } : null,
      // Scores analysis
      scoresInfo,
      // API usage tracking
      apiUsage: trackedOsuAPI.getCurrentUsage(),
      // Quick summary for easy reading
      summary: {
        roomExists: !!roomInfo.id,
        hasPlaylists: (roomInfo.playlist?.length || 0) > 0,
        scoresChecked: includeScores === 'true',
        scoresFound: scoresInfo?.totalScores || 0,
        timestampFieldsFound: scoresInfo?.firstScoreAnalysis?.dateTimeFields || []
      }
    });

  } catch (error) {
    console.error('Debug API error:', error);
    
    // Log usage even on error
    trackedOsuAPI.logUsage('After error');
    
    res.status(500).json({ 
      error: 'Failed to fetch room data',
      details: error.message,
      // Include API usage stats even on error for debugging
      apiUsage: trackedOsuAPI.getCurrentUsage()
    });
  }
}

export default handler;


================================================
FILE: frontend/pages/api/health.js
================================================
import { supabase } from '../../lib/supabase';
import { handleAPIResponse, handleAPIError } from '../../lib/api-utils';
import { memoryCache, createCacheKey, CACHE_DURATIONS } from '../../lib/memory-cache';

async function handler(req, res) {
  try {
    const cacheKey = createCacheKey('health', 'check');

    // VERY SHORT CACHE FOR HEALTH CHECKS
    const cached = memoryCache.get(cacheKey);
    if (cached) {
      return handleAPIResponse(res, cached, { 
        cache: true, 
        cacheTime: 60 
      });
    }

    const checks = {
      api: 'ok',
      database: 'unknown',
      timestamp: new Date().toISOString(),
      version: process.env.npm_package_version || '1.0.0',
      environment: process.env.NODE_ENV
    };

    // Test database connection
    const { error } = await supabase
      .from('challenges')
      .select('id')
      .limit(1);

    checks.database = error ? 'error' : 'ok';

    // Overall health status
    const isHealthy = checks.api === 'ok' && checks.database === 'ok';

    const responseData = {
      status: isHealthy ? 'healthy' : 'unhealthy',
      checks,
      uptime: process.uptime(),
    };

    // Cache for 1 minute
    memoryCache.set(cacheKey, responseData, CACHE_DURATIONS.HEALTH);

    return handleAPIResponse(res, responseData, { 
      status: isHealthy ? 200 : 503,
      cache: true,
      cacheTime: 60
    });

  } catch (error) {
    console.error('Health check error:', error);
    
    res.status(503).json({
      status: 'unhealthy',
      checks: {
        api: 'error',
        database: 'error',
        error: error.message,
        timestamp: new Date().toISOString()
      }
    });
  }
}

export default handler;


================================================
FILE: frontend/pages/api/stats.js
================================================
import { supabase } from '../../lib/supabase';
import { withOptionalAuth } from '../../lib/auth-middleware';
import { handleAPIResponse, handleAPIError } from '../../lib/api-utils';
import { memoryCache, createCacheKey, CACHE_DURATIONS } from '../../lib/memory-cache';
import { generateETag, checkETag } from '../../lib/api-utils';

async function handler(req, res) {
  if (req.method !== 'GET') {
    return res.status(405).json({ 
      success: false,
      error: { message: 'Method not allowed' }
    });
  }

  try {
    const isAdmin = req.user?.admin || false;
    const cacheKey = createCacheKey('stats', isAdmin ? 'admin' : 'public');

    // TRY MEMORY CACHE FIRST
    const cached = memoryCache.get(cacheKey);
    if (cached) {
      console.log('üìä Serving stats from memory cache');
      const etag = generateETag(cached);
      if (checkETag(req, etag)) {
        return res.status(304).end();
      }
      
      return handleAPIResponse(res, cached, { 
        cache: true, 
        cacheTime: 300,
        enableETag: true 
      });
    }

    // Get basic stats (visible to all users)
    const [
      { count: activeChallenges },
      { count: totalUsers },
      { count: scoresToday },
      { data: recentActivity }
    ] = await Promise.all([
      // Active challenges count
      supabase
        .from('challenges')
        .select('*', { count: 'exact', head: true })
        .eq('is_active', true),
      
      // Total users count
      supabase
        .from('users')
        .select('*', { count: 'exact', head: true }),
      
      // Scores submitted today
      supabase
        .from('scores')
        .select('*', { count: 'exact', head: true })
        .gte('submitted_at', new Date().toISOString().split('T')[0]),
      
      // Recent activity (last 5 scores)
      supabase
      .from('scores')
      .select(`
        score,
        accuracy,
        submitted_at,
        users (username),
        playlists (
          beatmap_title,
          challenges (name, custom_name)
        )
      `)
      .not('submitted_at', 'is', null)
      .order('submitted_at', { ascending: false })
      .limit(5)
    ]);

    const basicStats = {
      activeChallenges: activeChallenges || 0,
      totalUsers: totalUsers || 0,
      scoresToday: scoresToday || 0,
      recentActivity: recentActivity || [],
      lastUpdate: new Date().toISOString()
    };

    // If user is admin, add detailed stats
    if (isAdmin) {
      const [
        { count: totalChallenges },
        { count: totalScores },
        { count: totalPlaylists },
        { data: topUsers },
        { data: challengeStats }
      ] = await Promise.all([
        // Total challenges
        supabase
          .from('challenges')
          .select('*', { count: 'exact', head: true }),
        
        // Total scores
        supabase
          .from('scores')
          .select('*', { count: 'exact', head: true }),
        
        // Total playlists
        supabase
          .from('playlists')
          .select('*', { count: 'exact', head: true }),
        
        // Top users by score count
        supabase
          .rpc('get_user_score_counts')
          .limit(10),
        
        // Challenge participation stats
        supabase
          .from('challenges')
          .select(`
            id,
            name,
            custom_name,
            created_at,
            playlists (
              scores (count)
            )
          `)
          .eq('is_active', true)
      ]);

      basicStats.adminStats = {
        totalChallenges: totalChallenges || 0,
        totalScores: totalScores || 0,
        totalPlaylists: totalPlaylists || 0,
        topUsers: topUsers || [],
        challengeStats: challengeStats || []
      };
    }

    // Cache for 5 minutes
    memoryCache.set(cacheKey, basicStats, CACHE_DURATIONS.STATS);

    return handleAPIResponse(res, basicStats, { 
      cache: true, 
      cacheTime: 300,
      enableETag: true 
    });

  } catch (error) {
    console.error('Stats API error:', error);
    res.status(500).json({
      success: false,
      error: { 
        message: 'Failed to fetch statistics',
        code: 'STATS_ERROR'
      }
    });
  }
}

export default withOptionalAuth(handler);


================================================
FILE: frontend/pages/api/team.js
================================================
// frontend/pages/api/team.js (rename from team/index.js)
import { supabase } from '../../lib/supabase';
import { supabaseAdmin } from '../../lib/supabase-admin';
import { withAdminAuth } from '../../lib/auth-middleware';
import { handleAPIResponse, handleAPIError, validateRequest } from '../../lib/api-utils';
import { memoryCache, createCacheKey, CACHE_DURATIONS } from '../../lib/memory-cache';
import { generateETag, checkETag } from '../../lib/api-utils';
import { invalidateAfterUpdate } from '../../lib/cache-invalidation';

async function handler(req, res) {
  if (req.method === 'GET') {
    return handleGetTeam(req, res);
  } else if (req.method === 'POST') {
    return withAdminAuth(handleCreateTeamMember)(req, res);
  } else {
    return handleAPIError(res, new Error('Method not allowed'), { status: 405 });
  }
}

async function handleGetTeam(req, res) {
  try {
    validateRequest(req, {
      method: 'GET',
      query: {
        active_only: { type: 'string', enum: ['true', 'false'] }
      }
    });

    const { active_only = 'true' } = req.query;
    const cacheKey = createCacheKey('team_list', 'all', { active_only });

    // TRY MEMORY CACHE FIRST
    const cached = memoryCache.get(cacheKey);
    if (cached) {
      console.log('ü§ñ Serving team from memory cache');
      const etag = generateETag(cached);
      if (checkETag(req, etag)) {
        return res.status(304).end();
      }
      
      return handleAPIResponse(res, cached, { 
        cache: true, 
        cacheTime: 1800,
        enableETag: true 
      });
    }

    console.log(`üìã Fetching team list (active_only: ${active_only})`);

    let query = supabase
      .from('team_members')
      .select('*');

    // Apply filters
    if (active_only === 'true') {
      query = query.eq('is_active', true);
    }

    // Order by display_order, then by created_at
    query = query.order('display_order', { ascending: true })
                 .order('created_at', { ascending: true });

    const { data, error } = await query;

    if (error) {
      throw error;
    }

    const responseData = {
      success: true,
      team: data || [],
      count: data?.length || 0
    };

    // Cache for 30 minutes
    memoryCache.set(cacheKey, responseData, CACHE_DURATIONS.TEAM);

    console.log(`‚úÖ Fetched ${data?.length || 0} team members`);

    return handleAPIResponse(res, responseData, { 
      cache: true, 
      cacheTime: 1800,
      enableETag: true 
    });

  } catch (error) {
    console.error('Get team error:', error);
    return handleAPIError(res, error);
  }
}

async function handleCreateTeamMember(req, res) {
  try {
    validateRequest(req, {
      method: 'POST',
      body: {
        name: { required: true, type: 'string', maxLength: 255 },
        role: { required: true, type: 'string', maxLength: 255 },
        bio: { type: 'string', maxLength: 1000 },
        avatar_url: { type: 'string' },
        osu_username: { type: 'string', maxLength: 255 },
        osu_user_id: { type: 'number' },
        social_links: { type: 'object' },
        is_active: { type: 'boolean' },
        display_order: { type: 'number', min: 0 }
      }
    });

    const { 
      name, 
      role, 
      bio, 
      avatar_url, 
      osu_username, 
      osu_user_id,
      social_links = {},
      is_active = true, 
      display_order = 0 
    } = req.body;

    // Validate avatar URL if provided
    if (avatar_url) {
      try {
        new URL(avatar_url);
      } catch (urlError) {
        throw new Error('Invalid URL format for avatar_url');
      }
    }

    // Check for duplicate name
    const { data: existing } = await supabase
      .from('team_members')
      .select('id')
      .eq('name', name)
      .single();

    if (existing) {
      throw new Error('A team member with this name already exists');
    }

    // Create team member
    const { data: teamMember, error: createError } = await supabaseAdmin
      .from('team_members')
      .insert({
        name,
        role,
        bio: bio || null,
        avatar_url: avatar_url || null,
        osu_username: osu_username || null,
        osu_user_id: osu_user_id || null,
        social_links,
        is_active,
        display_order,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .select()
      .single();

    if (createError) {
      throw createError;
    }

    console.log(`‚úÖ Created new team member: ${name} (ID: ${teamMember.id})`);

    // INVALIDATE TEAM CACHE AFTER CREATION
    invalidateAfterUpdate('team');

    return handleAPIResponse(res, {
      success: true,
      teamMember,
      message: 'Team member created successfully'
    }, { status: 201 });

  } catch (error) {
    console.error('Create team member error:', error);
    return handleAPIError(res, error);
  }
}

export default handler;


================================================
FILE: frontend/pages/api/test-tracking.js
================================================
import apiTracker from '../../lib/api-tracker';

function handler(req, res) {
  console.log('üß™ Testing tracking...');
  
  // Manual tracking test
  apiTracker.trackInternal('/api/test-tracking', 'GET', 100, true);
  
  const stats = apiTracker.getUsageStats();
  
  res.json({
    success: true,
    stats,
    hasGlobalTracker: typeof global.vercelApiTracker !== 'undefined'
  });
}

export default handler;


================================================
FILE: frontend/pages/api/update-challenge.js
================================================
import { supabaseAdmin } from '../../lib/supabase-admin';
import { trackedOsuAPI } from '../../lib/osu-api'; 
import apiTracker from '../../lib/api-tracker';
import { handleAPIError, validateRequest } from '../../lib/api-utils';
import { markChallengeUpdated } from '../../lib/update-tracker';
import pLimit from 'p-limit';

// Helper function to process mods
function processModsData(mods) {
  if (!mods || !Array.isArray(mods) || mods.length === 0) {
    return {
      legacy: 'None',
      detailed: []
    };
  }
  
  try {
    const detailedMods = mods.map(mod => ({
      acronym: mod.acronym || 'Unknown',
      settings: mod.settings || {}
    }));
    
    const legacyString = mods.map(mod => mod.acronym).join('');
    
    return {
      legacy: legacyString || 'None',
      detailed: detailedMods
    };
  } catch (error) {
    console.warn('Error processing mods data:', error, mods);
    return {
      legacy: 'Error',
      detailed: []
    };
  }
}

// Atomic update function
async function executeAtomicUpdateWithMods(challengeData, playlistsData, scoresData, participationData) {
  const { data, error } = await supabaseAdmin.rpc('update_challenge_atomic_with_mods', {
    challenge_data: challengeData,
    playlists_data: playlistsData,
    scores_data: scoresData,
    participation_data: participationData
  });
  
  if (error) {
    throw new Error(`Atomic update with mods failed: ${error.message}`);
  }
  
  return data;
}

// Process playlists in parallel
async function processPlaylistsInParallel(roomData, roomIdNum, requestId, maxRetries = 3) {
  console.log(`üöÄ Request ${requestId}: Processing ${roomData.playlist?.length || 0} playlists`);
  
  if (!roomData.playlist || roomData.playlist.length === 0) {
    return {
      playlistsData: [],
      scoresData: [],
      usersData: [],
      totalApiCallsForPlaylists: 0,
      playlistsProcessed: 0,
      scoresProcessed: 0
    };
  }

  const concurrencyLimit = pLimit(4);
  const batchSize = 8;
  
  let totalApiCallsForPlaylists = 0;
  let playlistsProcessed = 0;
  let scoresProcessed = 0;
  
  const allPlaylistsData = [];
  const allScoresData = [];
  const allUsersData = [];
  const userMap = new Map();

  const processPlaylist = async (playlist, index) => {
    try {
      const currentLimitStatus = apiTracker.checkLimits();
      if (currentLimitStatus === 'critical') {
        console.warn(`üö® Request ${requestId}: Hit critical limit at playlist ${index + 1}`);
        return null;
      }

      const covers = playlist.beatmap?.beatmapset?.covers || {};
      const playlistRecord = {
        playlist_id: playlist.id,
        beatmap_id: playlist.beatmap_id,
        beatmap_title: playlist.beatmap?.beatmapset?.title || 'Unknown',
        beatmap_artist: playlist.beatmap?.beatmapset?.artist || 'Unknown',
        beatmap_version: playlist.beatmap?.version || 'Unknown',
        beatmap_difficulty: playlist.beatmap?.difficulty_rating || 0,
        beatmap_cover_url: covers.cover || null,
        beatmap_card_url: covers.card || null,
        beatmap_list_url: covers.list || null,
        beatmap_slimcover_url: covers.slimcover || null,
      };

      let scores;
      let scoreRetryCount = 0;
      
      while (scoreRetryCount < maxRetries) {
        try {
          scores = await trackedOsuAPI.getAllRoomScores(roomIdNum, playlist.id);
          break;
        } catch (scoreError) {
          scoreRetryCount++;
          if (scoreRetryCount >= maxRetries) {
            console.error(`‚ùå Request ${requestId}: Failed to fetch scores for playlist ${playlist.id}`);
            throw scoreError;
          }
          await new Promise(resolve => setTimeout(resolve, 500 * scoreRetryCount));
        }
      }
      
      const apiCalls = Math.ceil((scores?.length || 0) / 50);
      const playlistScoresData = [];
      const playlistUsersData = [];
      
      if (scores && scores.length > 0) {
        for (const score of scores) {
          try {
            const userKey = score.user_id.toString();
            if (!userMap.has(userKey)) {
              const userData = {
                osu_id: score.user_id,
                username: score.user?.username || 'Unknown',
                avatar_url: score.user?.avatar_url || null,
                country: score.user?.country_code || null,
                updated_at: new Date().toISOString()
              };
              userMap.set(userKey, userData);
              playlistUsersData.push(userData);
            }

            const modData = processModsData(score.mods);
            const scoreValue = score.total_score || score.score || 0;
            
            const scoreRecord = {
              playlist_id: playlist.id,
              user_osu_id: score.user_id,
              score: scoreValue,
              accuracy: score.accuracy * 100,
              max_combo: score.max_combo,
              mods: modData.legacy,
              mods_detailed: modData.detailed,
              rank_position: score.position || 999,
              submitted_at: score.ended_at || score.started_at || new Date().toISOString()
            };
            
            playlistScoresData.push(scoreRecord);
          } catch (scoreProcessError) {
            console.error(`‚ùå Request ${requestId}: Error processing score:`, scoreProcessError);
          }
        }
      }

      console.log(`‚úÖ Request ${requestId}: Playlist ${index + 1}/${roomData.playlist.length} done (${scores?.length || 0} scores)`);

      return {
        playlistRecord,
        scoresData: playlistScoresData,
        usersData: playlistUsersData,
        apiCalls,
        scoreCount: scores?.length || 0
      };

    } catch (error) {
      console.error(`‚ùå Request ${requestId}: Error processing playlist ${index + 1}:`, error);
      return null;
    }
  };

  const playlists = roomData.playlist;
  for (let batchStart = 0; batchStart < playlists.length; batchStart += batchSize) {
    const batchEnd = Math.min(batchStart + batchSize, playlists.length);
    const batch = playlists.slice(batchStart, batchEnd);
    
    console.log(`üì¶ Request ${requestId}: Batch ${Math.floor(batchStart / batchSize) + 1}`);
    
    const batchPromises = batch.map((playlist, batchIndex) => 
      concurrencyLimit(() => processPlaylist(playlist, batchStart + batchIndex))
    );
    
    const batchResults = await Promise.allSettled(batchPromises);
    
    for (const result of batchResults) {
      if (result.status === 'fulfilled' && result.value) {
        const { playlistRecord, scoresData, usersData, apiCalls, scoreCount } = result.value;
        
        allPlaylistsData.push(playlistRecord);
        allScoresData.push(...scoresData);
        allUsersData.push(...usersData);
        totalApiCallsForPlaylists += apiCalls;
        playlistsProcessed++;
        scoresProcessed += scoreCount;
      }
    }
    
    if (batchEnd < playlists.length) {
      await new Promise(resolve => setTimeout(resolve, 200));
    }
  }

  const uniqueUsersData = Array.from(userMap.values());

  console.log(`üéØ Request ${requestId}: Complete - ${playlistsProcessed}/${playlists.length} playlists, ${scoresProcessed} scores`);

  return {
    playlistsData: allPlaylistsData,
    scoresData: allScoresData,
    usersData: uniqueUsersData,
    totalApiCallsForPlaylists,
    playlistsProcessed,
    scoresProcessed
  };
}

// Execute database update with retries
async function executeOptimizedAtomicUpdate(challengeData, playlistsData, scoresData, usersData, requestId) {
  const maxRetries = 3;
  let retryCount = 0;
  
  while (retryCount < maxRetries) {
    try {
      console.log(`üíæ Request ${requestId}: Database transaction (attempt ${retryCount + 1})`);
      
      const result = await executeAtomicUpdateWithMods(
        challengeData,
        playlistsData,
        scoresData,
        usersData
      );
      
      console.log(`‚úÖ Request ${requestId}: Transaction complete`);
      return result;
      
    } catch (transactionError) {
      retryCount++;
      console.error(`‚ùå Request ${requestId}: Transaction failed (attempt ${retryCount})`);
      
      if (retryCount >= maxRetries) {
        throw new Error(`Transaction failed after ${maxRetries} attempts: ${transactionError.message}`);
      }
      
      const delay = Math.min(1000 * Math.pow(2, retryCount), 5000);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

// Calculate ruleset winner
async function updateChallengeRulesetWinner(challengeId, requestId) {
  try {
    console.log(`üèÜ Request ${requestId}: Calculating ruleset winner for ${challengeId}`);
    
    const { data: challenge, error: challengeError } = await supabaseAdmin
      .from('challenges')
      .select('id, room_id, has_ruleset, required_mods, ruleset_match_type')
      .eq('id', challengeId)
      .single();

    if (challengeError || !challenge) {
      console.warn(`‚ö†Ô∏è Request ${requestId}: Challenge ${challengeId} not found`);
      return { success: false, error: 'Challenge not found' };
    }

    if (!challenge.has_ruleset) {
      console.log(`üìù Request ${requestId}: No ruleset, skipping`);
      return { success: true, has_ruleset: false };
    }

    const { data: winnerResult, error: winnerError } = await supabaseAdmin
      .rpc('update_challenge_ruleset_winner', { challenge_id_param: challengeId });

    if (winnerError) {
      console.error(`‚ùå Request ${requestId}: Ruleset winner error:`, winnerError);
      return { success: false, error: winnerError.message };
    }

    if (winnerResult?.winner_updated) {
      console.log(`üèÜ Request ${requestId}: Winner: ${winnerResult.winner_username}`);
    }

    return {
      success: true,
      has_ruleset: true,
      winner_result: winnerResult
    };

  } catch (error) {
    console.error(`‚ùå Request ${requestId}: Ruleset calculation error:`, error);
    return { success: false, error: error.message };
  }
}

// MAIN HANDLER
async function handler(req, res) {
  const requestId = Math.random().toString(36).substr(2, 9);
  const totalStartTime = Date.now();

  try {
    validateRequest(req, {
      method: 'POST',
      body: {
        roomId: { required: true }
      }
    });

    const { roomId } = req.body;
    const roomIdNum = parseInt(roomId);
    
    if (isNaN(roomIdNum) || roomIdNum <= 0) {
      throw new Error('Invalid room ID');
    }

    // Check API limits
    const limitStatus = apiTracker.checkLimits();
    if (limitStatus === 'critical') {
      throw new Error('API usage critical');
    }

    console.log(`üîÑ Request ${requestId}: Updating challenge ${roomIdNum}`);

    // 1. Fetch room data
    let roomData;
    let retryCount = 0;
    const maxRetries = 3;
    
    while (retryCount < maxRetries) {
      try {
        roomData = await trackedOsuAPI.getRoom(roomIdNum);
        break;
      } catch (apiError) {
        retryCount++;
        if (retryCount >= maxRetries) throw apiError;
        await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
      }
    }
    
    if (!roomData?.id) {
      throw new Error('Room not found');
    }

    // 2. Prepare challenge data
    let backgroundImageUrl = null;
    if (roomData.playlist?.length > 0) {
      const firstBeatmap = roomData.playlist[0];
      backgroundImageUrl = firstBeatmap.beatmap?.beatmapset?.covers?.cover || null;
    }

    const challengeData = {
      room_id: roomIdNum,
      name: roomData.name,
      host: roomData.host?.username || 'Unknown',
      room_type: roomData.type || 'playlists',
      start_date: roomData.starts_at,
      end_date: roomData.ends_at,
      participant_count: roomData.participant_count || 0,
      is_active: roomData.active || false,
      background_image_url: backgroundImageUrl,
      updated_at: new Date().toISOString(),
      custom_name: null 
    };

    // Auto-rename inactive challenges based on type (set custom_name)
    if (challengeData.is_active === false && roomData.playlist && roomData.playlist.length > 0) {
      try {
        let customName = null;
        
        if (roomData.playlist.length === 1) {
          // Weekly challenge: rename to [song title] - [artist]
          const firstMap = roomData.playlist[0];
          const metadata = firstMap.beatmap?.beatmapset;

          if (metadata && metadata.title && metadata.artist) {
            customName = `${metadata.title} - ${metadata.artist}`;
            console.log(`Request ${requestId}: Weekly challenge ended. Setting custom name: "${customName}"`);
          }
        } else {
          // Cycle End challenge: rename to "osu!Challengers CE - [month]"
          const startDate = new Date(roomData.starts_at || challengeData.start_date);
          const monthName = startDate.toLocaleString('en-US', { month: 'long' });
          customName = `osu!Challengers CE - ${monthName}`;
          console.log(`Request ${requestId}: Cycle End challenge ended. Setting custom name: "${customName}"`);
        }
        
        // Add custom_name to challengeData
        if (customName) {
          challengeData.custom_name = customName;
        }
      } catch (err) {
        console.warn(`Request ${requestId}: Failed to generate custom name:`, err.message);
      }
    }

    // 3. Process playlists and scores
    const {
      playlistsData,
      scoresData,
      usersData,
      totalApiCallsForPlaylists,
      playlistsProcessed,
      scoresProcessed
    } = await processPlaylistsInParallel(roomData, roomIdNum, requestId);

    // 4. Update database
    let challengeDbId = null;
    try {
      const result = await executeOptimizedAtomicUpdate(
        challengeData,
        playlistsData,
        scoresData,
        usersData,
        requestId
      );
      challengeDbId = result.challenge_id;
    } catch (transactionError) {
      throw new Error(`Database update failed: ${transactionError.message}`);
    }

    // 5. Calculate ruleset winner
    let rulesetResult = { success: false, has_ruleset: false };
    if (challengeDbId) {
      try {
        rulesetResult = await updateChallengeRulesetWinner(challengeDbId, requestId);
      } catch (rulesetError) {
        console.warn(`‚ö†Ô∏è Request ${requestId}: Ruleset failed:`, rulesetError);
      }
    }
    
    const totalTime = Date.now() - totalStartTime;

    // 6. Mark as updated
    markChallengeUpdated(roomIdNum);

    const finalUsage = apiTracker.getUsageStats();
    
    console.log(`‚úÖ Request ${requestId}: Complete in ${Math.round(totalTime)}ms`);

    return res.status(200).json({ 
      success: true, 
      challenge: challengeData,
      message: 'Challenge updated successfully',
      stats: {
        playlistsProcessed,
        scoresProcessed,
        totalPlaylists: roomData.playlist?.length || 0,
        uniqueUsers: usersData.length
      },
      performance: {
        totalTimeMs: Math.round(totalTime)
      },
      apiUsage: {
        percentage: finalUsage.usage?.functions?.percentage || '0',
        remaining: finalUsage.usage?.functions?.remaining || 100000
      },
      ruleset: rulesetResult,
      requestId
    });

  } catch (error) {
    console.error(`‚ùå Request error:`, error);
    return handleAPIError(res, error);
  }
}

export default handler;


================================================
FILE: frontend/pages/api/verify-payment.js
================================================
import Stripe from 'stripe';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);

export default async function handler(req, res) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const { session_id } = req.query;

  if (!session_id) {
    return res.status(400).json({ error: 'Session ID is required' });
  }

  try {
    // Retrieve the session from Stripe
    const session = await stripe.checkout.sessions.retrieve(session_id);

    if (session.payment_status === 'paid') {
      res.status(200).json({ 
        success: true, 
        amount: session.amount_total,
        currency: session.currency,
        customerEmail: session.customer_email
      });
    } else {
      res.status(200).json({ 
        success: false, 
        message: 'Payment not completed' 
      });
    }
  } catch (error) {
    console.error('Error verifying payment:', error);
    res.status(500).json({ 
      error: 'Failed to verify payment',
      message: error.message 
    });
  }
}


================================================
FILE: frontend/pages/api/admin/api-calls.js
================================================
import { withAdminAuth } from '../../../lib/auth-middleware';
import { handleAPIResponse, handleAPIError } from '../../../lib/api-utils';

async function handler(req, res) {
  if (req.method !== 'GET') {
    return res.status(405).json({ 
      success: false,
      error: { message: 'Method not allowed' }
    });
  }

  try {
    // Get stats from global storage (or your preferred storage)
    const apiCallStats = global.apiCallStats || new Map();
    
    // Convert Map to object for JSON response
    const statsArray = Array.from(apiCallStats.entries()).map(([key, stats]) => ({
      endpoint: stats.endpoint,
      method: stats.method,
      totalCalls: stats.count,
      firstCall: stats.firstCall,
      lastCall: stats.lastCall,
      avgResponseTime: stats.avgResponseTime || null,
      errorRate: stats.errorCount ? (stats.errorCount / stats.count * 100).toFixed(2) + '%' : '0%',
      recentCalls: stats.calls.slice(-10) // Last 10 calls
    }));

    // Sort by most called endpoints
    statsArray.sort((a, b) => b.totalCalls - a.totalCalls);

    // Calculate totals
    const totalApiCalls = statsArray.reduce((sum, stat) => sum + stat.totalCalls, 0);
    const uniqueEndpoints = statsArray.length;
    const totalErrors = statsArray.reduce((sum, stat) => {
      const errorCount = stat.recentCalls.filter(call => !call.success).length;
      return sum + errorCount;
    }, 0);

    return handleAPIResponse(res, {
      data: {
        summary: {
          totalApiCalls,
          uniqueEndpoints,
          totalErrors,
          errorRate: totalApiCalls > 0 ? (totalErrors / totalApiCalls * 100).toFixed(2) + '%' : '0%',
          generatedAt: new Date().toISOString()
        },
        endpoints: statsArray,
        systemInfo: {
          uptime: process.uptime(),
          memoryUsage: process.memoryUsage(),
          nodeVersion: process.version,
          platform: process.platform
        }
      }
    });

  } catch (error) {
    console.error('API tracking error:', error);
    res.status(500).json({
      success: false,
      error: { 
        message: 'Failed to fetch API call statistics',
        code: 'API_TRACKING_ERROR'
      }
    });
  }
}

export default handler;


================================================
FILE: frontend/pages/api/admin/bulk-update-challenges.js
================================================
import { supabaseAdmin } from '../../../lib/supabase-admin';
import { trackedOsuAPI } from '../../../lib/osu-api';
import apiTracker from '../../../lib/api-tracker';
import { validateRequest, handleAPIError } from '../../../lib/api-utils';
import { withAdminAuth } from '../../../lib/auth-middleware';

async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const { dryRun = false, limit = null } = req.body;

  try {
    // Get all challenges from database
    let query = supabaseAdmin
      .from('challenges')
      .select('id, room_id, name, is_active')
      .order('created_at', { ascending: false });
    
    if (limit) {
      query = query.limit(limit);
    }

    const { data: challenges, error: challengesError } = await query;

    if (challengesError) {
      return res.status(500).json({ error: 'Failed to fetch challenges', details: challengesError });
    }

    if (!challenges || challenges.length === 0) {
      return res.status(200).json({ message: 'No challenges found to update' });
    }

    console.log(`Found ${challenges.length} challenges to ${dryRun ? 'analyze' : 'update'}`);

    const results = [];
    let totalUpdated = 0;
    let totalFailed = 0;
    let totalApiCalls = 0;

    for (const [index, challenge] of challenges.entries()) {
      console.log(`\n=== Processing ${index + 1}/${challenges.length}: ${challenge.name} (Room ${challenge.room_id}) ===`);
      
      // Check API limits before each challenge
      const limitStatus = apiTracker.checkLimits();
      const usageStats = apiTracker.getUsageStats();
      
      console.log(`API usage before challenge: ${usageStats.usage?.functions?.percentage || '0'}%`);
      
      if (limitStatus === 'critical') {
        console.warn('üö® Hit critical API limit. Stopping bulk update.');
        results.push({
          challengeId: challenge.id,
          roomId: challenge.room_id,
          status: 'skipped',
          reason: 'API limit reached'
        });
        break;
      }

      try {
        if (dryRun) {
          // Just check if the room exists and count scores
          const roomData = await trackedOsuAPI.getRoom(challenge.room_id);
          totalApiCalls += 1;
          
          let estimatedScores = 0;
          if (roomData?.playlist) {
            for (const playlist of roomData.playlist) {
              // Just get first page to estimate total
              const scoresResponse = await trackedOsuAPI.getRoomScores(challenge.room_id, playlist.id, 1);
              estimatedScores += scoresResponse.total || 0;
              totalApiCalls += 1;
            }
          }
          
          results.push({
            challengeId: challenge.id,
            roomId: challenge.room_id,
            name: challenge.name,
            status: 'analyzed',
            playlistCount: roomData?.playlist?.length || 0,
            estimatedScores: estimatedScores
          });
          
        } else {
          // Actually update the challenge
          const updateResponse = await fetch(`${req.headers.origin || 'http://localhost:3000'}/api/update-challenge`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ roomId: challenge.room_id })
          });

          if (updateResponse.ok) {
            const updateData = await updateResponse.json();
            totalUpdated++;
            totalApiCalls += updateData.apiUsage?.estimatedExternalCalls || 0;
            
            results.push({
              challengeId: challenge.id,
              roomId: challenge.room_id,
              name: challenge.name,
              status: 'updated',
              apiUsage: updateData.apiUsage
            });
            
            console.log(`‚úÖ Successfully updated challenge ${challenge.room_id}`);
          } else {
            totalFailed++;
            const errorData = await updateResponse.json();
            
            results.push({
              challengeId: challenge.id,
              roomId: challenge.room_id,
              name: challenge.name,
              status: 'failed',
              error: errorData.error
            });
            
            console.error(`‚ùå Failed to update challenge ${challenge.room_id}:`, errorData.error);
          }
        }

        // Small delay between requests to be nice to the API
        await new Promise(resolve => setTimeout(resolve, 1000));

      } catch (error) {
        totalFailed++;
        results.push({
          challengeId: challenge.id,
          roomId: challenge.room_id,
          name: challenge.name,
          status: 'error',
          error: error.message
        });
        
        console.error(`‚ùå Error processing challenge ${challenge.room_id}:`, error.message);
      }
    }

    const finalUsage = apiTracker.getUsageStats();
    
    return handleAPIResponse(res, {
      summary: {
        totalChallenges: challenges.length,
        totalUpdated,
        totalFailed,
        totalApiCalls,
        dryRun
      },
      apiUsage: {
        initial: apiTracker.getUsageStats(),
        final: finalUsage,
        percentage: finalUsage.usage?.functions?.percentage || '0'
      },
      results
    }, { cache: false });

  } catch (error) {
    console.error('Bulk update error:', error);
    res.status(500).json({ 
      error: 'Internal server error',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
}

export default withAdminAuth(handler);


================================================
FILE: frontend/pages/api/admin/challenges.js
================================================
import { supabase } from '../../../lib/supabase';
import { supabaseAdmin } from '../../../lib/supabase-admin';
import { withAdminAuth } from '../../../lib/auth-middleware';
import { validateRequest, handleAPIError, handleAPIResponse } from '../../../lib/api-utils';

async function handler(req, res) {
  console.log('üîç Admin challenges API called:', {
    method: req.method,
    query: req.query,
    timestamp: new Date().toISOString()
  });

  if (req.method === 'GET') {
    return withAdminAuth(handleGetAllChallenges)(req, res);
  } else if (req.method === 'PUT') {
    return withAdminAuth(handleUpdateChallengeName)(req, res);
  } else if (req.method === 'POST' && req.body.action === 'reset_name') {
    return withAdminAuth(handleResetChallengeName)(req, res);
  } else if (req.method === 'DELETE') {
    return withAdminAuth(handleDeleteChallenge)(req, res);
  } else {
    console.log('‚ùå Method not allowed:', req.method);
    return res.status(405).json({ 
      success: false,
      error: 'Method not allowed' 
    });
  }
}

// Get all challenges for admin name management
async function handleGetAllChallenges(req, res) {
  console.log('üìä Getting all challenges for admin:', {
    user: req.user?.username || 'unknown',
    filters: req.query
  });

  try {
    const { 
      limit = 50, 
      offset = 0,
      search = '',
      status = '', // 'active', 'inactive', or '' for all
      season_id = '',
      hasCustomName = '', // 'true', 'false', or '' for all
      hasRuleset = '', // 'true', 'false', or '' for all
      dateFrom = '',
      dateTo = ''
    } = req.query;

    console.log('üîç Query parameters:', {
      limit, offset, search, status, season_id, hasCustomName, hasRuleset, dateFrom, dateTo
    });

    // Validation
    const parsedLimit = Math.min(parseInt(limit) || 50, 100);
    const parsedOffset = parseInt(offset) || 0;

    console.log('‚úÖ Building Supabase query...');

    let query = supabase
      .from('challenges')
      .select(`
        *,
        seasons (
          id,
          name,
          start_date,
          end_date,
          is_current
        )
      `, { count: 'exact' });

    // Apply filters
    if (status === 'active') {
      console.log('üîç Filtering for active challenges');
      query = query.eq('is_active', true);
    } else if (status === 'inactive') {
      console.log('üîç Filtering for inactive challenges');
      query = query.eq('is_active', false);
    }

    if (season_id) {
      console.log('üîç Filtering by season:', season_id);
      query = query.eq('season_id', parseInt(season_id));
    }

    if (hasCustomName === 'true') {
      console.log('üîç Filtering for challenges with custom names');
      query = query.not('custom_name', 'is', null);
    } else if (hasCustomName === 'false') {
      console.log('üîç Filtering for challenges without custom names');
      query = query.is('custom_name', null);
    }

    if (hasRuleset === 'true') {
      console.log('üîç Filtering for challenges with rulesets');
      query = query.eq('has_ruleset', true);
    } else if (hasRuleset === 'false') {
      console.log('üîç Filtering for challenges without rulesets');
      query = query.eq('has_ruleset', false);
    }

    if (search) {
      console.log('üîç Applying search filter:', search);
      // Search in room_id, name, custom_name, and host
      query = query.or(`
        room_id.eq.${parseInt(search) || 0},
        name.ilike.%${search}%,
        custom_name.ilike.%${search}%,
        host.ilike.%${search}%
      `);
    }

    // Date filtering
    if (dateFrom) {
      console.log('üîç Filtering from date:', dateFrom);
      query = query.gte('created_at', dateFrom);
    }
    if (dateTo) {
      console.log('üîç Filtering to date:', dateTo);
      query = query.lte('created_at', dateTo);
    }

    // For challenges with null end_date (active challenges), they'll be sorted last
    console.log('üîç Sorting by end_date DESC (most recent first)');
    
    query = query
      .order('end_date', { ascending: false, nullsLast: true })
      .order('updated_at', { ascending: false }) // Secondary sort for consistency
      .range(parsedOffset, parsedOffset + parsedLimit - 1);

    console.log('üöÄ Executing main challenges query...');
    const { data, error, count } = await query;

    if (error) {
      console.error('‚ùå Database error:', error);
      return handleAPIError(res, error);
    }

    console.log('‚úÖ Challenges fetched:', {
      count: data?.length || 0,
      total: count || 0
    });

    // Get summary statistics
    console.log('üìä Fetching summary statistics...');
    const { data: stats, error: statsError } = await supabase
      .from('challenges')
      .select(`
        id,
        is_active,
        custom_name,
        has_ruleset
      `);

    let summary = {
      total: count || 0,
      active: 0,
      inactive: 0,
      withCustomNames: 0,
      withoutCustomNames: 0,
      withRulesets: 0,
      withoutRulesets: 0
    };

    if (!statsError && stats) {
      summary.active = stats.filter(c => c.is_active).length;
      summary.inactive = stats.filter(c => !c.is_active).length;
      summary.withCustomNames = stats.filter(c => c.custom_name !== null).length;
      summary.withoutCustomNames = stats.filter(c => c.custom_name === null).length;
      summary.withRulesets = stats.filter(c => c.has_ruleset === true).length;
      summary.withoutRulesets = stats.filter(c => c.has_ruleset === false).length;
      console.log('‚úÖ Summary calculated:', summary);
    } else if (statsError) {
      console.error('‚ö†Ô∏è Stats error (non-critical):', statsError);
    }

    console.log('‚úÖ Sending successful response');
    handleAPIResponse(res, {
      challenges: data || [],
      pagination: {
        total: count || 0,
        limit: parsedLimit,
        offset: parsedOffset,
        hasNext: (parsedOffset + parsedLimit) < (count || 0),
        hasPrev: parsedOffset > 0,
        totalPages: Math.ceil((count || 0) / parsedLimit),
        currentPage: Math.floor(parsedOffset / parsedLimit) + 1
      },
      summary,
      sorting: {
        field: 'end_date',
        order: 'desc',
        description: 'Sorted by end date (most recent first), active challenges last'
      },
      filters: {
        search,
        status,
        season_id,
        hasCustomName,
        hasRuleset,
        dateFrom,
        dateTo
      }
    }, { cache: false });

  } catch (error) {
    console.error('üö® Unexpected error in handleGetAllChallenges:', error);
    return handleAPIError(res, error);
  }
}

// Delete challenge and all related data
async function handleDeleteChallenge(req, res) {
  try {
    // Validate request
    validateRequest(req, {
      method: 'DELETE',
      body: {
        roomId: { required: true, type: 'number' }
      }
    });

    const { roomId } = req.body;

    console.log(`üóëÔ∏è Admin ${req.user.username} attempting to delete challenge ${roomId}`);

    // First, get the challenge details for logging and verification
    const { data: challengeToDelete, error: fetchError } = await supabase
      .from('challenges')
      .select(`
        id,
        room_id,
        name,
        custom_name,
        participant_count,
        is_active,
        created_at
      `)
      .eq('room_id', roomId)
      .single();

    if (fetchError || !challengeToDelete) {
      console.log('‚ùå Challenge not found:', roomId);
      return res.status(404).json({ 
        success: false,
        error: 'Challenge not found' 
      });
    }

    // Get statistics about what will be deleted for logging
    const { data: playlistStats } = await supabase
      .from('playlists')
      .select('id')
      .eq('challenge_id', challengeToDelete.id);

    const playlistIds = playlistStats?.map(p => p.id) || [];
    
    let scoreCount = 0;
    let userCount = 0;
    
    if (playlistIds.length > 0) {
      // Get score count
      const { count: scores } = await supabase
        .from('scores')
        .select('*', { count: 'exact', head: true })
        .in('playlist_id', playlistIds);
      
      // Get unique user count
      const { data: users } = await supabase
        .from('scores')
        .select('user_id')
        .in('playlist_id', playlistIds);
      
      scoreCount = scores || 0;
      userCount = new Set(users?.map(u => u.user_id) || []).size;
    }

    console.log(`üìä Challenge ${roomId} deletion impact:`, {
      challengeName: challengeToDelete.custom_name || challengeToDelete.name,
      playlists: playlistIds.length,
      scores: scoreCount,
      uniqueUsers: userCount,
      isActive: challengeToDelete.is_active
    });

    // Perform the deletion using a transaction-like approach
    // The CASCADE constraints should handle most of the cleanup, but we'll be explicit

    try {
      console.log('üóëÔ∏è Step 1: Deleting challenge_ruleset_winners...');
      await supabaseAdmin
        .from('challenge_ruleset_winners')
        .delete()
        .eq('challenge_id', challengeToDelete.id);

      console.log('üóëÔ∏è Step 2: Deleting scores...');
      if (playlistIds.length > 0) {
        await supabaseAdmin
          .from('scores')
          .delete()
          .in('playlist_id', playlistIds);
      }

      console.log('üóëÔ∏è Step 3: Deleting user_challenges...');
      await supabaseAdmin
        .from('user_challenges')
        .delete()
        .eq('challenge_id', challengeToDelete.id);

      console.log('üóëÔ∏è Step 4: Deleting playlists...');
      await supabaseAdmin
        .from('playlists')
        .delete()
        .eq('challenge_id', challengeToDelete.id);

      console.log('üóëÔ∏è Step 5: Deleting challenge...');
      const { error: deleteError } = await supabaseAdmin
        .from('challenges')
        .delete()
        .eq('id', challengeToDelete.id);

      if (deleteError) {
        throw deleteError;
      }

      console.log('‚úÖ Challenge deleted successfully');

    } catch (deleteError) {
      console.error('‚ùå Error during deletion:', deleteError);
      return res.status(500).json({
        success: false,
        error: 'Failed to delete challenge',
        details: process.env.NODE_ENV === 'development' ? deleteError.message : undefined
      });
    }

    // Log the deletion for audit purposes
    console.log(`üéØ Admin ${req.user.username} (ID: ${req.user.id}) deleted challenge:`, {
      roomId: challengeToDelete.room_id,
      challengeId: challengeToDelete.id,
      name: challengeToDelete.custom_name || challengeToDelete.name,
      wasActive: challengeToDelete.is_active,
      deletedPlaylists: playlistIds.length,
      deletedScores: scoreCount,
      affectedUsers: userCount,
      timestamp: new Date().toISOString()
    });

    handleAPIResponse(res, {
      message: `Challenge "${challengeToDelete.custom_name || challengeToDelete.name}" deleted successfully`,
      deletionStats: {
        challenge: challengeToDelete.custom_name || challengeToDelete.name,
        playlists: playlistIds.length,
        scores: scoreCount,
        affectedUsers: userCount
      }
    }, { cache: false });

  } catch (error) {
    console.error('üö® Delete challenge error:', error);
    return handleAPIError(res, error);
  }
}

// Update challenge name
async function handleUpdateChallengeName(req, res) {
  try {
    // Validate request
    validateRequest(req, {
      method: 'PUT',
      body: {
        roomId: { required: true, type: 'number' },
        customName: { required: true, type: 'string', minLength: 1, maxLength: 500 }
      }
    });

    const { roomId, customName } = req.body;

    // Check if challenge exists
    const { data: existingChallenge, error: fetchError } = await supabase
      .from('challenges')
      .select('id, room_id, name, custom_name')
      .eq('room_id', roomId)
      .single();

    if (fetchError || !existingChallenge) {
      return res.status(404).json({ 
        success: false,
        error: 'Challenge not found' 
      });
    }

    // Update the challenge
    const { data: updatedChallenge, error: updateError } = await supabaseAdmin
      .from('challenges')
      .update({
        custom_name: customName.trim(),
        updated_at: new Date().toISOString()
      })
      .eq('room_id', roomId)
      .select(`
        *,
        seasons (
          id,
          name,
          start_date,
          end_date,
          is_current
        )
      `)
      .single();

    if (updateError) {
      console.error('Challenge update error:', updateError);
      return res.status(500).json({ 
        success: false,
        error: 'Failed to update challenge name',
        details: process.env.NODE_ENV === 'development' ? updateError.message : undefined
      });
    }

    // Log the change for audit purposes
    console.log(`üéØ Admin ${req.user.username} (ID: ${req.user.id}) updated challenge ${roomId} name:`, {
      oldName: existingChallenge.name,
      oldCustomName: existingChallenge.custom_name,
      newCustomName: customName.trim(),
      timestamp: new Date().toISOString()
    });

    handleAPIResponse(res, {
      message: 'Challenge name updated successfully',
      challenge: updatedChallenge,
      changes: {
        field: 'custom_name',
        oldValue: existingChallenge.custom_name,
        newValue: customName.trim()
      }
    }, { cache: false });

  } catch (error) {
    console.error('Update challenge name error:', error);
    return handleAPIError(res, error);
  }
}

// Reset challenge name to original
async function handleResetChallengeName(req, res) {
  try {
    // Validate request
    validateRequest(req, {
      method: 'POST',
      body: {
        roomId: { required: true, type: 'number' },
        action: { required: true }
      }
    });

    const { roomId } = req.body;

    // Check if challenge exists
    const { data: existingChallenge, error: fetchError } = await supabase
      .from('challenges')
      .select('id, room_id, name, custom_name')
      .eq('room_id', roomId)
      .single();

    if (fetchError || !existingChallenge) {
      return res.status(404).json({ 
        success: false,
        error: 'Challenge not found' 
      });
    }

    if (!existingChallenge.custom_name) {
      return res.status(400).json({ 
        success: false,
        error: 'Challenge already uses original name' 
      });
    }

    // Reset to original name (set custom_name to null)
    const { data: updatedChallenge, error: updateError } = await supabaseAdmin
      .from('challenges')
      .update({
        custom_name: null,
        updated_at: new Date().toISOString()
      })
      .eq('room_id', roomId)
      .select(`
        *,
        seasons (
          id,
          name,
          start_date,
          end_date,
          is_current
        )
      `)
      .single();

    if (updateError) {
      console.error('Challenge reset error:', updateError);
      return res.status(500).json({ 
        success: false,
        error: 'Failed to reset challenge name',
        details: process.env.NODE_ENV === 'development' ? updateError.message : undefined
      });
    }

    // Log the reset for audit purposes
    console.log(`üîÑ Admin ${req.user.username} (ID: ${req.user.id}) reset challenge ${roomId} name:`, {
      originalName: existingChallenge.name,
      removedCustomName: existingChallenge.custom_name,
      timestamp: new Date().toISOString()
    });

    handleAPIResponse(res, {
      message: 'Challenge name reset to original',
      challenge: updatedChallenge,
      changes: {
        field: 'custom_name',
        oldValue: existingChallenge.custom_name,
        newValue: null
      }
    }, { cache: false });

  } catch (error) {
    console.error('Reset challenge name error:', error);
    return handleAPIError(res, error);
  }
}

export default handler;


================================================
FILE: frontend/pages/api/admin/partners.js
================================================
import { supabaseAdmin } from '../../../lib/supabase-admin';
import { withAdminAuth } from '../../../lib/auth-middleware';
import { handleAPIResponse, handleAPIError, validateRequest } from '../../../lib/api-utils';

async function handler(req, res) {
  return withAdminAuth(handleAdminPartners)(req, res);
}

async function handleAdminPartners(req, res) {
  switch (req.method) {
    case 'GET':
      return handleGetAllPartners(req, res);
    case 'POST':
      return handleBulkOperations(req, res);
    case 'PUT':
      return handleReorderPartners(req, res);
    default:
      return handleAPIError(res, new Error('Method not allowed'), { status: 405 });
  }
}

async function handleGetAllPartners(req, res) {
  try {
    // Get all partners with admin view (including inactive)
    const { data: partners, error } = await supabaseAdmin
      .from('partners')
      .select('*')
      .order('display_order', { ascending: true })
      .order('created_at', { ascending: true });

    if (error) {
      throw error;
    }

    // Get stats
    const activeCount = partners?.filter(p => p.is_active).length || 0;
    const inactiveCount = partners?.filter(p => !p.is_active).length || 0;

    return handleAPIResponse(res, {
      partners: partners || [],
      stats: {
        total: partners?.length || 0,
        active: activeCount,
        inactive: inactiveCount
      }
    });

  } catch (error) {
    console.error('Admin get partners error:', error);
    return handleAPIError(res, error);
  }
}

async function handleBulkOperations(req, res) {
  try {
    validateRequest(req, {
      method: 'POST',
      body: {
        operation: { required: true, type: 'string', enum: ['activate', 'deactivate', 'delete'] },
        partnerIds: { required: true, type: 'array' }
      }
    });

    const { operation, partnerIds } = req.body;

    if (!Array.isArray(partnerIds) || partnerIds.length === 0) {
      throw new Error('No partner IDs provided');
    }

    // Validate all IDs are numbers
    if (!partnerIds.every(id => typeof id === 'number')) {
      throw new Error('Invalid partner ID format');
    }

    let result;

    switch (operation) {
      case 'activate':
        result = await supabaseAdmin
          .from('partners')
          .update({ is_active: true, updated_at: new Date().toISOString() })
          .in('id', partnerIds)
          .select();
        break;

      case 'deactivate':
        result = await supabaseAdmin
          .from('partners')
          .update({ is_active: false, updated_at: new Date().toISOString() })
          .in('id', partnerIds)
          .select();
        break;

      case 'delete':
        result = await supabaseAdmin
          .from('partners')
          .delete()
          .in('id', partnerIds)
          .select();
        break;

      default:
        throw new Error('Invalid operation');
    }

    if (result.error) {
      throw result.error;
    }

    console.log(`‚úÖ Bulk ${operation} completed for ${result.data?.length || 0} partners`);

    return handleAPIResponse(res, {
      operation,
      affected: result.data?.length || 0,
      partners: result.data || [],
      message: `Successfully ${operation}d ${result.data?.length || 0} partners`
    });

  } catch (error) {
    console.error('Bulk operation error:', error);
    return handleAPIError(res, error);
  }
}

async function handleReorderPartners(req, res) {
  try {
    validateRequest(req, {
      method: 'PUT',
      body: {
        partners: { required: true, type: 'array' }
      }
    });

    const { partners } = req.body;

    if (!Array.isArray(partners) || partners.length === 0) {
      throw new Error('No partners provided for reordering');
    }

    // Validate partner format
    const isValid = partners.every(p => 
      typeof p.id === 'number' && 
      typeof p.display_order === 'number'
    );

    if (!isValid) {
      throw new Error('Invalid partner format for reordering');
    }

    // Update all partners in a transaction-like manner
    const updates = await Promise.all(
      partners.map(partner => 
        supabaseAdmin
          .from('partners')
          .update({ 
            display_order: partner.display_order,
            updated_at: new Date().toISOString()
          })
          .eq('id', partner.id)
          .select()
          .single()
      )
    );

    // Check for errors
    const errors = updates.filter(u => u.error);
    if (errors.length > 0) {
      throw new Error(`Failed to update ${errors.length} partners`);
    }

    console.log(`‚úÖ Reordered ${partners.length} partners`);

    return handleAPIResponse(res, {
      updated: updates.map(u => u.data).filter(Boolean),
      message: 'Partners reordered successfully'
    });

  } catch (error) {
    console.error('Reorder partners error:', error);
    return handleAPIError(res, error);
  }
}

export default handler;


================================================
FILE: frontend/pages/api/admin/scheduled-challenges.js
================================================
import { supabaseAdmin } from '../../../lib/supabase-admin';
import { validateRequest, handleAPIError, handleAPIResponse } from '../../../lib/api-utils';

const SCHEDULER_SECRET = process.env.SCHEDULER_SHARED_SECRET;

if (!SCHEDULER_SECRET || SCHEDULER_SECRET.length < 32) {
  throw new Error('SCHEDULER_SHARED_SECRET must be set and at least 32 characters');
}

/**
 * Verify scheduler authentication
 */
function verifySchedulerAuth(req) {
  const providedSecret = req.headers['x-scheduler-secret'];
  
  if (!providedSecret) {
    throw new Error('Authentication required');
  }

  if (providedSecret !== SCHEDULER_SECRET) {
    throw new Error('Invalid authentication');
  }
}

/**
 * Main handler - routes to appropriate method
 */
export default async function handler(req, res) {
  console.log('Scheduled challenges API:', {
    method: req.method,
    timestamp: new Date().toISOString()
  });

  try {
    // Verify authentication for all requests
    verifySchedulerAuth(req);

    switch (req.method) {
      case 'POST':
        return await handleCreate(req, res);
      case 'GET':
        return await handleList(req, res);
      case 'PATCH':
        return await handleUpdate(req, res);
      case 'DELETE':
        return await handleDelete(req, res);
      default:
        return res.status(405).json({
          success: false,
          error: 'Method not allowed'
        });
    }
  } catch (error) {
    console.error('üö® Scheduled challenges error:', error);
    
    if (error.message === 'Authentication required' || error.message === 'Invalid authentication') {
      return res.status(401).json({
        success: false,
        error: error.message
      });
    }
    
    return handleAPIError(res, error);
  }
}

/**
 * POST - Create a new scheduled challenge
 * NOTE: No longer requires osu_token in request body
 */
async function handleCreate(req, res) {
  console.log('Creating scheduled challenge');

  try {
    // Validate request - osu_token is now OPTIONAL for backward compatibility
    validateRequest(req, {
      method: 'POST',
      body: {
        osu_id: { required: true, type: 'number' },
        scheduled_time: { required: true, type: 'string' },
        room_data: { required: true, type: 'object' },
        // osu_token is now optional (for backward compatibility)
        osu_token: { required: false, type: 'string' },
        // Optional fields
        chat_messages: { required: false, type: 'array' },
        season_id: { required: false, type: 'number' },
        // Optional ruleset configuration for mod challenges
        ruleset_config: { required: false, type: 'object' }
      }
    });

    const {
      osu_id,
      scheduled_time,
      room_data,
      osu_token, // Optional - legacy support
      chat_messages,
      season_id,
      ruleset_config  // Optional ruleset config
    } = req.body;

    console.log(`Schedule request from osu_id ${osu_id}:`, {
      room_name: room_data.name,
      scheduled_time,
      playlist_items: room_data.playlist.length,
      has_chat_messages: !!chat_messages?.length,
      has_ruleset_config: !!ruleset_config,  // Log ruleset config presence
      uses_stored_token: !osu_token // New workflow if no token provided
    });

    // Validate ruleset_config if provided
    if (ruleset_config) {
      const rulesetValidation = validateRulesetConfig(ruleset_config);
      if (!rulesetValidation.valid) {
        return res.status(400).json({
          success: false,
          error: 'Invalid ruleset configuration',
          details: rulesetValidation.errors
        });
      }
      console.log('‚úÖ Ruleset config validated:', {
        match_type: ruleset_config.ruleset_match_type,
        mods_count: ruleset_config.required_mods?.length || 0
      });
    }

    // Verify user exists and is admin
    const { data: user, error: userError } = await supabaseAdmin
      .from('users')
      .select('id, osu_id, username, admin')
      .eq('osu_id', osu_id)
      .single();

    if (userError || !user) {
      console.log('‚ùå User not found:', osu_id);
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    if (!user.admin) {
      console.log('‚ùå User is not admin:', user.username);
      return res.status(403).json({
        success: false,
        error: 'Admin access required'
      });
    }

    // Validate scheduled time is in the future
    const scheduledDate = new Date(scheduled_time);
    if (scheduledDate <= new Date()) {
      return res.status(400).json({
        success: false,
        error: 'Scheduled time must be in the future'
      });
    }

    // If no token provided, check if user has stored token
    if (!osu_token) {
      console.log('‚ÑπÔ∏è No token provided, checking for stored token...');
      
      const { data: storedToken, error: tokenError } = await supabaseAdmin
        .from('user_osu_tokens')
        .select('id')
        .eq('osu_id', osu_id)
        .single();

      if (tokenError || !storedToken) {
        console.log('‚ùå User has no stored token');
        return res.status(400).json({
          success: false,
          error: 'No stored token found. Please set your osu! token first using POST /api/admin/user-token',
          code: 'NO_STORED_TOKEN'
        });
      }

      console.log('‚úÖ User has stored token, will use it at execution time');
    }

    // Legacy encryption handling (only if token provided)
    let encrypted_token = null;
    if (osu_token) {
      console.log('‚ö†Ô∏è Using legacy token workflow (token provided in request)');
      const { encryptToken, maskToken } = require('../../../lib/token-encryption');
      console.log('Encrypting provided token:', maskToken(osu_token));
      encrypted_token = encryptToken(osu_token);
    }

    // Insert into database
    // Include ruleset_config in the insert
    const { data: schedule, error: insertError } = await supabaseAdmin
      .from('scheduled_challenges')
      .insert({
        osu_id,
        scheduled_time: scheduledDate.toISOString(),
        room_data,
        encrypted_token, // NULL for new workflow, encrypted for legacy
        chat_messages: chat_messages || [],
        season_id: season_id || null,
        ruleset_config: ruleset_config || null,  // Store ruleset config
        status: 'pending'
      })
      .select()
      .single();

    if (insertError) {
      console.error('‚ùå Database insert error:', insertError);
      throw insertError;
    }

    console.log('‚úÖ Schedule created:', {
      id: schedule.id,
      scheduled_for: schedule.scheduled_time,
      has_ruleset: !!ruleset_config,  // Log ruleset presence
      workflow: encrypted_token ? 'legacy' : 'new'
    });

    // Return response (without encrypted token)
    const { encrypted_token: _, ...scheduleWithoutToken } = schedule;

    return handleAPIResponse(res, {
      message: 'Challenge scheduled successfully',
      schedule: scheduleWithoutToken,
      scheduled_by: {
        username: user.username,
        osu_id: user.osu_id
      }
    }, { cache: false });

  } catch (error) {
    console.error('üö® Create schedule error:', error);
    return handleAPIError(res, error);
  }
}

/**
 * GET - List scheduled challenges (optionally filtered by osu_id)
 */
async function handleList(req, res) {
  console.log('Listing scheduled challenges');

  try {
    const { osu_id, status, limit = 50, offset = 0 } = req.query;

    let query = supabaseAdmin
      .from('scheduled_challenges')
      .select(`
        id,
        osu_id,
        scheduled_time,
        room_data,
        chat_messages,
        ruleset_config,
        status,
        created_room_id,
        error_message,
        retry_count,
        created_at,
        updated_at,
        executed_at,
        season_id
      `, { count: 'exact' });

    // Filter by osu_id if provided
    if (osu_id) {
      query = query.eq('osu_id', parseInt(osu_id));
    }

    // Filter by status if provided
    if (status) {
      query = query.eq('status', status);
    }

    // Order by scheduled_time (upcoming first for pending, recent first for completed)
    if (status === 'pending') {
      query = query.order('scheduled_time', { ascending: true });
    } else {
      query = query.order('scheduled_time', { ascending: false });
    }

    // Pagination
    const parsedLimit = Math.min(parseInt(limit) || 50, 100);
    const parsedOffset = parseInt(offset) || 0;
    
    query = query.range(parsedOffset, parsedOffset + parsedLimit - 1);

    const { data: schedules, error, count } = await query;

    if (error) {
      throw error;
    }

    console.log(`‚úÖ Found ${schedules?.length || 0} schedules (total: ${count})`);

    return handleAPIResponse(res, {
      schedules: schedules || [],
      pagination: {
        total: count || 0,
        limit: parsedLimit,
        offset: parsedOffset,
        hasNext: (parsedOffset + parsedLimit) < (count || 0),
        hasPrev: parsedOffset > 0
      }
    }, { cache: false });

  } catch (error) {
    console.error('üö® List schedules error:', error);
    return handleAPIError(res, error);
  }
}

/**
 * PATCH - Update a scheduled challenge (only if status='pending')
 */
async function handleUpdate(req, res) {
  console.log('Updating scheduled challenge');

  try {
    validateRequest(req, {
      method: 'PATCH',
      body: {
        id: { required: true, type: 'number' },
        // At least one field must be provided
        scheduled_time: { required: false, type: 'string' },
        room_data: { required: false, type: 'object' },
        chat_messages: { required: false, type: 'array' },
        season_id: { required: false, type: 'number' },
        ruleset_config: { required: false, type: 'object' }  // Support updating ruleset_config
      }
    });

    const { id, ...updates } = req.body;

    // Check if schedule exists and is pending
    const { data: existing, error: fetchError } = await supabaseAdmin
      .from('scheduled_challenges')
      .select('id, status, scheduled_time, osu_id')
      .eq('id', id)
      .single();

    if (fetchError || !existing) {
      return res.status(404).json({
        success: false,
        error: 'Schedule not found'
      });
    }

    if (existing.status !== 'pending') {
      return res.status(400).json({
        success: false,
        error: `Cannot update schedule with status '${existing.status}'`
      });
    }

    // If updating scheduled_time, ensure it's in the future
    if (updates.scheduled_time) {
      const newScheduledDate = new Date(updates.scheduled_time);
      if (newScheduledDate <= new Date()) {
        return res.status(400).json({
          success: false,
          error: 'Scheduled time must be in the future'
        });
      }
      updates.scheduled_time = newScheduledDate.toISOString();
    }

    // Validate ruleset_config if provided
    if (updates.ruleset_config) {
      const rulesetValidation = validateRulesetConfig(updates.ruleset_config);
      if (!rulesetValidation.valid) {
        return res.status(400).json({
          success: false,
          error: 'Invalid ruleset configuration',
          details: rulesetValidation.errors
        });
      }
    }

    // Update
    const { data: updated, error: updateError } = await supabaseAdmin
      .from('scheduled_challenges')
      .update({
        ...updates,
        updated_at: new Date().toISOString()
      })
      .eq('id', id)
      .select()
      .single();

    if (updateError) {
      throw updateError;
    }

    console.log('‚úÖ Schedule updated:', id);

    const { encrypted_token: _, ...scheduleWithoutToken } = updated;

    return handleAPIResponse(res, {
      message: 'Schedule updated successfully',
      schedule: scheduleWithoutToken
    }, { cache: false });

  } catch (error) {
    console.error('üö® Update schedule error:', error);
    return handleAPIError(res, error);
  }
}

/**
 * DELETE - Cancel a scheduled challenge (only if status='pending')
 */
async function handleDelete(req, res) {
  console.log('Deleting scheduled challenge');

  try {
    validateRequest(req, {
      method: 'DELETE',
      body: {
        id: { required: true, type: 'number' }
      }
    });

    const { id } = req.body;

    // Check if schedule exists and is pending
    const { data: existing, error: fetchError } = await supabaseAdmin
      .from('scheduled_challenges')
      .select('id, status, room_data')
      .eq('id', id)
      .single();

    if (fetchError || !existing) {
      return res.status(404).json({
        success: false,
        error: 'Schedule not found'
      });
    }

    if (existing.status !== 'pending') {
      return res.status(400).json({
        success: false,
        error: `Cannot delete schedule with status '${existing.status}'`
      });
    }

    // Mark as cancelled instead of deleting
    const { error: updateError } = await supabaseAdmin
      .from('scheduled_challenges')
      .update({
        status: 'cancelled',
        updated_at: new Date().toISOString()
      })
      .eq('id', id);

    if (updateError) {
      throw updateError;
    }

    console.log('‚úÖ Schedule cancelled:', {
      id,
      room_name: existing.room_data?.name
    });

    return handleAPIResponse(res, {
      message: 'Schedule cancelled successfully',
      id
    }, { cache: false });

  } catch (error) {
    console.error('üö® Delete schedule error:', error);
    return handleAPIError(res, error);
  }
}

/**
 * Validate ruleset configuration
 * @param {Object} rulesetConfig - The ruleset configuration to validate
 * @returns {Object} - { valid: boolean, errors: string[] }
 */
function validateRulesetConfig(rulesetConfig) {
  const errors = [];

  if (!rulesetConfig) {
    return { valid: true, errors: [] };
  }

  // Validate match type
  const validMatchTypes = ['exact', 'at_least', 'any_of'];
  if (rulesetConfig.ruleset_match_type && !validMatchTypes.includes(rulesetConfig.ruleset_match_type)) {
    errors.push(`Invalid ruleset_match_type. Must be one of: ${validMatchTypes.join(', ')}`);
  }

  // Validate required_mods
  if (rulesetConfig.required_mods) {
    if (!Array.isArray(rulesetConfig.required_mods)) {
      errors.push('required_mods must be an array');
    } else if (rulesetConfig.required_mods.length === 0) {
      errors.push('required_mods cannot be empty if ruleset_config is provided');
    } else {
      // Validate each mod has an acronym
      for (let i = 0; i < rulesetConfig.required_mods.length; i++) {
        const mod = rulesetConfig.required_mods[i];
        if (!mod.acronym || typeof mod.acronym !== 'string') {
          errors.push(`Mod at index ${i} must have a valid acronym`);
        }
        // Settings are optional, but if provided must be an object
        if (mod.settings !== undefined && (typeof mod.settings !== 'object' || mod.settings === null)) {
          errors.push(`Mod ${mod.acronym || i}: settings must be an object`);
        }
      }
    }
  } else {
    errors.push('required_mods is required when ruleset_config is provided');
  }

  return {
    valid: errors.length === 0,
    errors
  };
}


================================================
FILE: frontend/pages/api/admin/schedules.js
================================================
import { supabaseAdmin } from '../../../lib/supabase-admin';
import { withAdminAuth } from '../../../lib/auth-middleware';
import { validateRequest, handleAPIError, handleAPIResponse } from '../../../lib/api-utils';

/**
 * Admin API for viewing and managing scheduled challenges
 * This wraps the scheduler API with admin authentication
 */
async function handler(req, res) {
  console.log('Admin scheduled challenges API:', {
    method: req.method,
    timestamp: new Date().toISOString()
  });

  switch (req.method) {
    case 'GET':
      return withAdminAuth(handleList)(req, res);
    case 'PATCH':
      return withAdminAuth(handleUpdate)(req, res);
    case 'DELETE':
      return withAdminAuth(handleCancel)(req, res);
    default:
      return res.status(405).json({
        success: false,
        error: 'Method not allowed'
      });
  }
}

/**
 * GET - List scheduled challenges (admin can see all)
 */
async function handleList(req, res) {
  console.log('Admin listing scheduled challenges');

  try {
    const { status, limit = 50, offset = 0 } = req.query;

    let query = supabaseAdmin
      .from('scheduled_challenges')
      .select(`
        id,
        osu_id,
        scheduled_time,
        room_data,
        chat_messages,
        ruleset_config,
        status,
        created_room_id,
        error_message,
        retry_count,
        created_at,
        updated_at,
        executed_at,
        season_id
      `, { count: 'exact' });

    // Filter by status if provided
    if (status) {
      query = query.eq('status', status);
    }

    // Order by scheduled_time (upcoming first for pending, recent first for others)
    if (status === 'pending') {
      query = query.order('scheduled_time', { ascending: true });
    } else {
      query = query.order('scheduled_time', { ascending: false });
    }

    // Pagination
    const parsedLimit = Math.min(parseInt(limit) || 50, 100);
    const parsedOffset = parseInt(offset) || 0;
    
    query = query.range(parsedOffset, parsedOffset + parsedLimit - 1);

    const { data: schedules, error, count } = await query;

    if (error) {
      throw error;
    }

    // Get user info for each schedule
    const osuIds = [...new Set(schedules.map(s => s.osu_id))];
    let userMap = {};
    
    if (osuIds.length > 0) {
      const { data: users } = await supabaseAdmin
        .from('users')
        .select('osu_id, username, avatar_url')
        .in('osu_id', osuIds);
      
      if (users) {
        userMap = Object.fromEntries(users.map(u => [u.osu_id, u]));
      }
    }

    // Enrich schedules with user info
    const enrichedSchedules = schedules.map(schedule => ({
      ...schedule,
      user: userMap[schedule.osu_id] || { username: `User ${schedule.osu_id}` }
    }));

    console.log(`‚úÖ Admin found ${schedules?.length || 0} schedules (total: ${count})`);

    return handleAPIResponse(res, {
      schedules: enrichedSchedules,
      pagination: {
        total: count || 0,
        limit: parsedLimit,
        offset: parsedOffset,
        hasNext: (parsedOffset + parsedLimit) < (count || 0),
        hasPrev: parsedOffset > 0
      }
    }, { cache: false });

  } catch (error) {
    console.error('üö® Admin list schedules error:', error);
    return handleAPIError(res, error);
  }
}

/**
 * PATCH - Update a scheduled challenge (only if status='pending')
 */
async function handleUpdate(req, res) {
  console.log('Admin updating scheduled challenge');

  try {
    validateRequest(req, {
      method: 'PATCH',
      body: {
        id: { required: true, type: 'number' },
        scheduled_time: { required: false, type: 'string' },
        room_data: { required: false, type: 'object' },
        chat_messages: { required: false, type: 'array' }
      }
    });

    const { id, ...updates } = req.body;

    // Check if schedule exists and is pending
    const { data: existing, error: fetchError } = await supabaseAdmin
      .from('scheduled_challenges')
      .select('id, status, scheduled_time, osu_id, room_data')
      .eq('id', id)
      .single();

    if (fetchError || !existing) {
      return res.status(404).json({
        success: false,
        error: 'Schedule not found'
      });
    }

    if (existing.status !== 'pending') {
      return res.status(400).json({
        success: false,
        error: `Cannot update schedule with status '${existing.status}'`
      });
    }

    // If updating scheduled_time, ensure it's in the future
    if (updates.scheduled_time) {
      const newScheduledDate = new Date(updates.scheduled_time);
      if (newScheduledDate <= new Date()) {
        return res.status(400).json({
          success: false,
          error: 'Scheduled time must be in the future'
        });
      }
      updates.scheduled_time = newScheduledDate.toISOString();
    }

    // Update
    const { data: updated, error: updateError } = await supabaseAdmin
      .from('scheduled_challenges')
      .update({
        ...updates,
        updated_at: new Date().toISOString()
      })
      .eq('id', id)
      .select()
      .single();

    if (updateError) {
      throw updateError;
    }

    console.log(`‚úÖ Admin ${req.user.username} updated schedule ${id}`);

    // Remove encrypted token from response
    const { encrypted_token: _, ...scheduleWithoutToken } = updated;

    return handleAPIResponse(res, {
      message: 'Schedule updated successfully',
      schedule: scheduleWithoutToken
    }, { cache: false });

  } catch (error) {
    console.error('üö® Admin update schedule error:', error);
    return handleAPIError(res, error);
  }
}

/**
 * DELETE - Cancel a scheduled challenge (only if status='pending')
 */
async function handleCancel(req, res) {
  console.log('Admin cancelling scheduled challenge');

  try {
    validateRequest(req, {
      method: 'DELETE',
      body: {
        id: { required: true, type: 'number' }
      }
    });

    const { id } = req.body;

    // Check if schedule exists and is pending
    const { data: existing, error: fetchError } = await supabaseAdmin
      .from('scheduled_challenges')
      .select('id, status, room_data, osu_id')
      .eq('id', id)
      .single();

    if (fetchError || !existing) {
      return res.status(404).json({
        success: false,
        error: 'Schedule not found'
      });
    }

    if (existing.status !== 'pending') {
      return res.status(400).json({
        success: false,
        error: `Cannot cancel schedule with status '${existing.status}'`
      });
    }

    // Mark as cancelled
    const { error: updateError } = await supabaseAdmin
      .from('scheduled_challenges')
      .update({
        status: 'cancelled',
        updated_at: new Date().toISOString()
      })
      .eq('id', id);

    if (updateError) {
      throw updateError;
    }

    console.log(`‚úÖ Admin ${req.user.username} cancelled schedule ${id}:`, {
      room_name: existing.room_data?.name,
      original_owner: existing.osu_id
    });

    return handleAPIResponse(res, {
      message: 'Schedule cancelled successfully',
      id
    }, { cache: false });

  } catch (error) {
    console.error('üö® Admin cancel schedule error:', error);
    return handleAPIError(res, error);
  }
}

export default handler;


================================================
FILE: frontend/pages/api/admin/track-call.js
================================================
import apiTracker from '../../../lib/api-tracker';
import { handleAPIResponse, handleAPIError } from '../../../lib/api-utils';

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ 
      success: false,
      error: { message: 'Method not allowed' }
    });
  }

  try {
    const { 
      type, 
      endpoint, 
      method = 'GET', 
      duration = 0, 
      success = true, 
      responseSize = 0,
      apiName = 'internal',
      memoryMB = 128
    } = req.body;

    if (!type || !endpoint) {
      return res.status(400).json({
        success: false,
        error: { message: 'Type and endpoint are required' }
      });
    }

    let callCount = 0;

    if (type === 'internal') {
      callCount = await apiTracker.trackInternal(
        endpoint, 
        method, 
        duration, 
        success, 
        memoryMB, 
        responseSize
      );
    } else if (type === 'external') {
      callCount = await apiTracker.trackExternal(
        apiName, 
        endpoint, 
        method, 
        duration, 
        success, 
        responseSize
      );
    } else {
      return res.status(400).json({
        success: false,
        error: { message: 'Invalid tracking type' }
      });
    }

    return handleAPIResponse(res, { 
      tracked: true, 
      callCount,
      type,
      endpoint 
    }, { 
      cache: false 
    });

  } catch (error) {
    console.error('Track call error:', error);
    return handleAPIError(res, error);
  }
}


================================================
FILE: frontend/pages/api/admin/user-token.js
================================================
import { supabaseAdmin } from '../../../lib/supabase-admin';
import { validateRequest, handleAPIError, handleAPIResponse } from '../../../lib/api-utils';
import { encryptToken, maskToken, parseToken, isTokenExpired } from '../../../lib/token-encryption';
import { trackedOsuAPI } from '../../../lib/osu-api';

const SCHEDULER_SECRET = process.env.SCHEDULER_SHARED_SECRET;

if (!SCHEDULER_SECRET || SCHEDULER_SECRET.length < 32) {
  throw new Error('SCHEDULER_SHARED_SECRET must be set and at least 32 characters');
}

/**
 * Verify scheduler authentication
 */
function verifySchedulerAuth(req) {
  const providedSecret = req.headers['x-scheduler-secret'];
  
  if (!providedSecret) {
    throw new Error('Authentication required');
  }

  if (providedSecret !== SCHEDULER_SECRET) {
    throw new Error('Invalid authentication');
  }
}

export default async function handler(req, res) {
  console.log('User token management:', {
    method: req.method,
    timestamp: new Date().toISOString()
  });

  try {
    // Verify authentication for all requests
    verifySchedulerAuth(req);

    switch (req.method) {
      case 'POST':
        return await handleSetToken(req, res);
      case 'GET':
        return await handleGetTokenStatus(req, res);
      case 'DELETE':
        return await handleRevokeToken(req, res);
      default:
        return res.status(405).json({
          success: false,
          error: 'Method not allowed'
        });
    }
  } catch (error) {
    console.error('üö® Token management error:', error);
    
    if (error.message === 'Authentication required' || error.message === 'Invalid authentication') {
      return res.status(401).json({
        success: false,
        error: error.message
      });
    }
    
    return handleAPIError(res, error);
  }
}

/**
 * POST - Set/update user's osu! token
 */
async function handleSetToken(req, res) {
  console.log('Setting user token');

  try {
    validateRequest(req, {
      method: 'POST',
      body: {
        osu_id: { required: true, type: 'number' },
        osu_token: { required: true, type: 'string' }
      }
    });

    const { osu_id, osu_token } = req.body;

    console.log(`Token set request from osu_id ${osu_id}`);
    console.log(`Token (masked): ${maskToken(osu_token)}`);

    // Step 1: Verify user exists and is admin
    const { data: user, error: userError } = await supabaseAdmin
      .from('users')
      .select('id, osu_id, username, admin')
      .eq('osu_id', osu_id)
      .single();

    if (userError || !user) {
      console.log('‚ùå User not found:', osu_id);
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    if (!user.admin) {
      console.log('‚ùå User is not admin:', user.username);
      return res.status(403).json({
        success: false,
        error: 'Admin access required'
      });
    }

    // Step 2: Validate token format and check if it's expired
    try {
      const parsed = parseToken(osu_token);
      console.log(`Token expires at: ${parsed.expiresAt.toISOString()}`);

      if (isTokenExpired(osu_token, 0)) {
        console.log('‚ö†Ô∏è Token is already expired');
        return res.status(400).json({
          success: false,
          error: 'Token is expired. Please provide a valid token.',
          expires_at: parsed.expiresAt.toISOString()
        });
      }
    } catch (parseError) {
      console.error('‚ùå Invalid token format:', parseError.message);
      return res.status(400).json({
        success: false,
        error: 'Invalid token format. Expected: access_token|timestamp|refresh_token'
      });
    }

    // Step 3: Verify token is valid by making a test API call
    console.log('üîç Verifying token validity with osu! API...');
    try {
      const { accessToken } = parseToken(osu_token);
      const userInfo = await trackedOsuAPI.getUserWithToken(accessToken);
      
      // Verify the token belongs to the user
      if (userInfo.id !== osu_id) {
        console.log('‚ùå Token user ID mismatch:', {
          expected: osu_id,
          actual: userInfo.id
        });
        return res.status(400).json({
          success: false,
          error: 'Token does not belong to this user',
          token_user_id: userInfo.id,
          expected_user_id: osu_id
        });
      }

      console.log('‚úÖ Token verified for user:', userInfo.username);
    } catch (apiError) {
      console.error('‚ùå Token verification failed:', apiError.message);
      return res.status(400).json({
        success: false,
        error: 'Failed to verify token with osu! API',
        details: apiError.message
      });
    }

    // Step 4: Encrypt and store token
    console.log('üîê Encrypting token...');
    const encrypted_token = encryptToken(osu_token);

    // Upsert (insert or update)
    const { data: tokenRecord, error: upsertError } = await supabaseAdmin
      .from('user_osu_tokens')
      .upsert({
        osu_id,
        encrypted_token,
        updated_at: new Date().toISOString()
      }, {
        onConflict: 'osu_id'
      })
      .select()
      .single();

    if (upsertError) {
      console.error('‚ùå Database upsert error:', upsertError);
      throw upsertError;
    }

    console.log('‚úÖ Token stored successfully:', {
      id: tokenRecord.id,
      osu_id: tokenRecord.osu_id
    });

    return handleAPIResponse(res, {
      message: 'Token set successfully',
      user: {
        osu_id: user.osu_id,
        username: user.username
      },
      token_set_at: tokenRecord.updated_at
    }, { cache: false });

  } catch (error) {
    console.error('üö® Set token error:', error);
    return handleAPIError(res, error);
  }
}

/**
 * GET - Check if user has a token stored
 */
async function handleGetTokenStatus(req, res) {
  console.log('Getting token status');

  try {
    const { osu_id } = req.query;

    if (!osu_id) {
      return res.status(400).json({
        success: false,
        error: 'osu_id query parameter is required'
      });
    }

    const parsedOsuId = parseInt(osu_id);
    if (isNaN(parsedOsuId)) {
      return res.status(400).json({
        success: false,
        error: 'osu_id must be a number'
      });
    }

    console.log(`Checking token status for osu_id: ${parsedOsuId}`);

    // Check if user exists
    const { data: user, error: userError } = await supabaseAdmin
      .from('users')
      .select('osu_id, username, admin')
      .eq('osu_id', parsedOsuId)
      .single();

    if (userError || !user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    // Check if token exists
    const { data: tokenRecord, error: tokenError } = await supabaseAdmin
      .from('user_osu_tokens')
      .select('id, created_at, updated_at')
      .eq('osu_id', parsedOsuId)
      .single();

    const hasToken = !tokenError && !!tokenRecord;

    console.log(`Token status for ${user.username}: ${hasToken ? 'HAS TOKEN' : 'NO TOKEN'}`);

    return handleAPIResponse(res, {
      has_token: hasToken,
      user: {
        osu_id: user.osu_id,
        username: user.username,
        admin: user.admin
      },
      token_set_at: hasToken ? tokenRecord.updated_at : null,
      token_created_at: hasToken ? tokenRecord.created_at : null
    }, { cache: false });

  } catch (error) {
    console.error('üö® Get token status error:', error);
    return handleAPIError(res, error);
  }
}

/**
 * DELETE - Revoke/remove user's stored token
 */
async function handleRevokeToken(req, res) {
  console.log('Revoking user token');

  try {
    validateRequest(req, {
      method: 'DELETE',
      body: {
        osu_id: { required: true, type: 'number' }
      }
    });

    const { osu_id } = req.body;

    console.log(`Token revoke request from osu_id: ${osu_id}`);

    // Verify user exists
    const { data: user, error: userError } = await supabaseAdmin
      .from('users')
      .select('osu_id, username')
      .eq('osu_id', osu_id)
      .single();

    if (userError || !user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    // Delete token
    const { error: deleteError } = await supabaseAdmin
      .from('user_osu_tokens')
      .delete()
      .eq('osu_id', osu_id);

    if (deleteError) {
      console.error('‚ùå Database delete error:', deleteError);
      throw deleteError;
    }

    console.log('‚úÖ Token revoked for user:', user.username);

    return handleAPIResponse(res, {
      message: 'Token revoked successfully',
      user: {
        osu_id: user.osu_id,
        username: user.username
      }
    }, { cache: false });

  } catch (error) {
    console.error('üö® Revoke token error:', error);
    return handleAPIError(res, error);
  }
}


================================================
FILE: frontend/pages/api/admin/vercel-usage.js
================================================
import apiTracker from '../../../lib/api-tracker';
import { handleAPIResponse, handleAPIError } from '../../../lib/api-utils';

async function handler(req, res) {
  if (req.method !== 'GET') {
    return res.status(405).json({ 
      success: false,
      error: { message: 'Method not allowed' }
    });
  }

  try {
    // Get comprehensive usage statistics from custom tracking
    const usageStats = apiTracker.getUsageStats();
    const limitStatus = apiTracker.checkLimits();
    const recommendations = apiTracker.generateRecommendations();
    
    // Note: Vercel doesn't provide public API endpoints for usage data
    // We'll rely on custom tracking only
    const isProduction = process.env.NODE_ENV === 'production';
    const isLocal = !isProduction;
    
    console.log('üìä Usage tracking - using custom tracking only');
    
    // Use custom tracking data
    const mergedUsageStats = enhanceUsageData(usageStats, isLocal);
    
    // Generate alerts based on current usage (without Vercel API warnings)
    const alerts = generateAlerts(mergedUsageStats, limitStatus, isLocal);
    
    // Calculate efficiency metrics
    const efficiency = calculateEfficiencyMetrics(usageStats);
    
    // Generate cost analysis
    const costAnalysis = generateCostAnalysis(mergedUsageStats);
    
    // Real-time status
    const realTimeStatus = {
      status: limitStatus,
      timestamp: new Date().toISOString(),
      nextCheck: new Date(Date.now() + 30000).toISOString(),
      isHealthy: limitStatus === 'ok' || limitStatus === 'caution',
      environment: isLocal ? 'local' : 'production',
      dataSource: isLocal ? 'local_tracking' : 'custom_tracking'
    };

    const responseData = {
      // Core usage data from custom tracking
      usage: mergedUsageStats,
      
      // Status and health
      status: realTimeStatus,
      limitStatus,
      
      // Analysis and insights
      recommendations,
      alerts,
      efficiency,
      costAnalysis,
      
      // Trends and patterns
      trends: {
        daily: usageStats.trends,
        hourly: usageStats.performance.peakHours,
        growth: calculateGrowthTrends(usageStats)
      },
      
      // Quick metrics for dashboard
      quickMetrics: {
        totalCalls: mergedUsageStats.monthly.total,
        averageResponseTime: usageStats.performance.averageResponseTime,
        errorRate: calculateOverallErrorRate(usageStats.performance.errorRates),
        topEndpoint: getTopEndpoint(usageStats.breakdown.internal.details),
        bandwidth: formatBytes(mergedUsageStats.monthly.bandwidth),
        projectedOverage: mergedUsageStats.projections?.willExceedLimits || {}
      },
      
      // Debug info for troubleshooting
      debug: {
        isLocal,
        trackingMethod: 'custom_only',
        note: 'Vercel does not provide public usage APIs. Using custom tracking.',
        customTracking: {
          internal: usageStats.monthly.internal,
          external: usageStats.monthly.external,
          total: usageStats.monthly.total
        }
      },
      
      // Export options
      export: {
        csvUrl: '/api/admin/export/usage-csv',
        jsonUrl: '/api/admin/export/usage-json',
        reportUrl: '/api/admin/export/usage-report'
      }
    };

    return handleAPIResponse(res, responseData, { 
      cache: false // Always fresh data for admin dashboard
    });

  } catch (error) {
    console.error('Enhanced Vercel usage tracking error:', error);
    return handleAPIError(res, error);
  }
}

// Enhanced usage data with custom tracking only
function enhanceUsageData(customStats, isLocal) {
  const enhanced = JSON.parse(JSON.stringify(customStats));
  
  if (isLocal) {
    enhanced.usage = {
      ...enhanced.usage,
      functions: {
        ...enhanced.usage.functions,
        current: enhanced.monthly.total,
        note: 'Local development - using custom tracking'
      }
    };
    enhanced.environment = 'local';
  } else {
    enhanced.usage = {
      ...enhanced.usage,
      functions: {
        ...enhanced.usage.functions,
        current: enhanced.monthly.total,
        note: 'Production - custom tracking (Vercel does not provide usage APIs)'
      }
    };
    enhanced.environment = 'production_custom_tracking';
  }
  
  return enhanced;
}

// Updated alerts without Vercel API warnings
function generateAlerts(stats, limitStatus, isLocal) {
  const alerts = [];
  
  // Add environment-specific alerts
  if (isLocal) {
    alerts.push({
      level: 'info',
      type: 'environment',
      resource: 'development',
      message: 'Running in local development mode',
      action: 'Deploy to Vercel to see production usage metrics',
      priority: 3
    });
  } else {
    alerts.push({
      level: 'info',
      type: 'tracking',
      resource: 'usage_data',
      message: 'Using custom tracking for usage monitoring',
      action: 'Monitor usage through this dashboard for accurate local tracking',
      priority: 3
    });
  }
  
  // Usage-based alerts
  Object.entries(stats.usage || {}).forEach(([resource, data]) => {
    const percentage = parseFloat(data.percentage);
    
    if (percentage >= 95) {
      alerts.push({
        level: 'critical',
        type: 'usage',
        resource,
        message: `${resource} usage is at ${percentage}% (${data.current?.toLocaleString()}/${data.limit?.toLocaleString()})`,
        action: 'Immediate action required to prevent service disruption',
        priority: 1
      });
    } else if (percentage >= 85) {
      alerts.push({
        level: 'warning',
        type: 'usage',
        resource,
        message: `${resource} usage is at ${percentage}%`,
        action: 'Consider optimization or monitoring closely',
        priority: 2
      });
    }
  });
  
  return alerts.sort((a, b) => a.priority - b.priority);
}

// Keep all your existing helper functions exactly the same:
function calculateEfficiencyMetrics(stats) {
  const totalRequests = stats.monthly.total;
  const totalDuration = stats.performance.slowestEndpoints.reduce(
    (sum, ep) => sum + ep.totalDuration, 0
  );
  const totalCalls = stats.performance.slowestEndpoints.reduce(
    (sum, ep) => sum + ep.callCount, 0
  );
  
  return {
    averageResponseTime: totalCalls > 0 ? Math.round(totalDuration / totalCalls) : 0,
    requestsPerDay: Math.round(totalRequests / Math.max(1, stats.projections.daysElapsed)),
    errorRate: calculateOverallErrorRate(stats.performance.errorRates),
    bandwidthPerRequest: totalRequests > 0 ? Math.round(stats.monthly.bandwidth / totalRequests) : 0,
    functionEfficiency: {
      avgDuration: stats.performance.averageResponseTime,
      avgMemoryUsage: calculateAverageMemoryUsage(stats.breakdown.internal.details),
      costPerRequest: totalRequests > 0 ? (stats.costs.estimated / totalRequests).toFixed(4) : 0
    }
  };
}

function generateCostAnalysis(stats) {
  const currentCosts = stats.costs;
  const projectedCosts = {
    functions: Math.max(0, stats.projections.projectedMonthly.functions - stats.limits.functions) * 0.40 / 1000,
    bandwidth: Math.max(0, stats.projections.projectedMonthly.bandwidth - stats.limits.bandwidth) * 20 / (1024 * 1024 * 1024)
  };
  
  return {
    current: currentCosts,
    projected: {
      estimated: projectedCosts.functions + projectedCosts.bandwidth,
      breakdown: projectedCosts
    },
    optimization: {
      potentialSavings: calculatePotentialSavings(stats),
      recommendations: [
        'Cache responses for frequently called endpoints',
        'Optimize database queries to reduce function duration',
        'Implement request batching for bulk operations',
        'Use Edge Functions for simple operations',
        'Compress API responses to reduce bandwidth usage'
      ]
    },
    planComparison: {
      hobby: { cost: 0, limits: stats.limits },
      pro: { 
        cost: 20, 
        limits: {
          functions: 1000000,
          bandwidth: 1000 * 1024 * 1024 * 1024,
          edgeExecutionUnits: 5000000
        }
      }
    }
  };
}

function calculateGrowthTrends(stats) {
  const trends = stats.trends;
  if (trends.length < 2) return { growth: 0, trend: 'insufficient_data' };
  
  const recent = trends.slice(-7);
  const older = trends.slice(-14, -7);
  
  if (older.length === 0) return { growth: 0, trend: 'insufficient_data' };
  
  const recentAvg = recent.reduce((sum, day) => sum + (day.internal + day.external), 0) / recent.length;
  const olderAvg = older.reduce((sum, day) => sum + (day.internal + day.external), 0) / older.length;
  
  const growth = olderAvg > 0 ? ((recentAvg - olderAvg) / olderAvg * 100) : 0;
  
  return {
    growth: Math.round(growth * 100) / 100,
    trend: growth > 10 ? 'growing' : growth < -10 ? 'declining' : 'stable',
    recentAverage: Math.round(recentAvg),
    previousAverage: Math.round(olderAvg)
  };
}

function calculateOverallErrorRate(errorRates) {
  if (errorRates.length === 0) return 0;
  
  const totalRequests = errorRates.reduce((sum, ep) => sum + ep.totalRequests, 0);
  const totalErrors = errorRates.reduce((sum, ep) => sum + ep.errorCount, 0);
  
  return totalRequests > 0 ? ((totalErrors / totalRequests) * 100).toFixed(2) : 0;
}

function getTopEndpoint(internalDetails) {
  if (internalDetails.length === 0) return null;
  
  const top = internalDetails[0];
  return {
    endpoint: top.endpoint,
    count: top.count,
    avgDuration: Math.round(top.totalDuration / top.count)
  };
}

function calculateAverageMemoryUsage(internalDetails) {
  if (internalDetails.length === 0) return 0;
  
  const totalMemory = internalDetails.reduce((sum, ep) => sum + (ep.totalMemoryUsage || 0), 0);
  const totalCalls = internalDetails.reduce((sum, ep) => sum + ep.count, 0);
  
  return totalCalls > 0 ? Math.round(totalMemory / totalCalls) : 128;
}

function calculatePotentialSavings(stats) {
  const topEndpoints = stats.breakdown.internal.details.slice(0, 3);
  let estimatedSavings = 0;
  
  topEndpoints.forEach(endpoint => {
    if (endpoint.count > 1000) {
      const potentialReduction = Math.round(endpoint.count * 0.3);
      estimatedSavings += potentialReduction;
    }
  });
  
  return {
    functionCalls: estimatedSavings,
    costSavings: estimatedSavings * 0.40 / 1000,
    percentage: stats.monthly.total > 0 ? ((estimatedSavings / stats.monthly.total) * 100).toFixed(1) : 0
  };
}

function formatBytes(bytes) {
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  if (bytes === 0) return '0 Bytes';
  
  const i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
  return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
}

export default handler;


================================================
FILE: frontend/pages/api/admin/verify-schedule-permission.js
================================================
import { supabaseAdmin } from '../../../lib/supabase-admin';
import { validateRequest, handleAPIError, handleAPIResponse } from '../../../lib/api-utils';

const SCHEDULER_SECRET = process.env.SCHEDULER_SHARED_SECRET;

if (!SCHEDULER_SECRET || SCHEDULER_SECRET.length < 32) {
  throw new Error('SCHEDULER_SHARED_SECRET must be set and at least 32 characters');
}

export default async function handler(req, res) {
  console.log('Schedule permission check:', {
    method: req.method,
    hasSecret: !!req.headers['x-scheduler-secret'],
    timestamp: new Date().toISOString()
  });

  // Only allow POST
  if (req.method !== 'POST') {
    return res.status(405).json({
      success: false,
      error: 'Method not allowed'
    });
  }

  try {
    // Verify shared secret
    const providedSecret = req.headers['x-scheduler-secret'];
    
    if (!providedSecret) {
      console.log('‚ùå No scheduler secret provided');
      return res.status(401).json({
        success: false,
        error: 'Authentication required',
        code: 'NO_SECRET'
      });
    }

    if (providedSecret !== SCHEDULER_SECRET) {
      console.log('‚ùå Invalid scheduler secret');
      return res.status(403).json({
        success: false,
        error: 'Invalid authentication',
        code: 'INVALID_SECRET'
      });
    }

    // Validate request body
    validateRequest(req, {
      method: 'POST',
      body: {
        osu_id: { required: true, type: 'number' }
      }
    });

    const { osu_id } = req.body;

    console.log(`Checking admin status for osu_id: ${osu_id}`);

    // Check if user exists and is admin
    const { data: user, error } = await supabaseAdmin
      .from('users')
      .select('id, osu_id, username, admin')
      .eq('osu_id', osu_id)
      .single();

    if (error) {
      if (error.code === 'PGRST116') {
        // User not found
        console.log(`‚ùå User not found: ${osu_id}`);
        return handleAPIResponse(res, {
          allowed: false,
          reason: 'User not found in Challengers database',
          osu_id
        });
      }
      
      throw error;
    }

    const isAdmin = user.admin === true;

    console.log(`${isAdmin ? '‚úÖ' : '‚ùå'} Admin check for ${user.username}: ${isAdmin}`);

    return handleAPIResponse(res, {
      allowed: isAdmin,
      reason: isAdmin 
        ? 'User is a Challengers admin' 
        : 'User is not a Challengers admin',
      user: {
        id: user.id,
        osu_id: user.osu_id,
        username: user.username,
        admin: user.admin
      }
    });

  } catch (error) {
    console.error('üö® Permission verification error:', error);
    return handleAPIError(res, error);
  }
}


================================================
FILE: frontend/pages/api/admin/rulesets/[challengeId].js
================================================
import { supabaseAdmin } from '../../../../lib/supabase-admin';
import { withAdminAuth } from '../../../../lib/auth-middleware';
import { OSU_MODS, CONFLICTING_MODS, SETTING_RANGES, SETTING_CONFIGS } from '../../../../lib/osu-mods-reference';

async function handler(req, res) {
  const { challengeId } = req.query;

  if (!challengeId || !/^\d+$/.test(challengeId)) {
    return res.status(400).json({ error: 'Invalid challenge ID' });
  }

  const challengeIdInt = parseInt(challengeId);

  if (req.method === 'GET') {
    return handleGetRuleset(req, res, challengeIdInt);
  } else if (req.method === 'POST' || req.method === 'PUT') {
    return withAdminAuth(async (req, res) => {
      return handleCreateOrUpdateRuleset(req, res, challengeIdInt);
    })(req, res);
  } else if (req.method === 'DELETE') {
    return withAdminAuth(async (req, res) => {
      return handleDeleteRuleset(req, res, challengeIdInt);
    })(req, res);
  } else {
    return res.status(405).json({ error: 'Method not allowed' });
  }
}

async function handleGetRuleset(req, res, challengeId) {
  try {
    const { data: challenge, error } = await supabaseAdmin
      .from('challenges')
      .select(`
        id,
        room_id,
        name,
        custom_name,
        has_ruleset,
        required_mods,
        ruleset_match_type
      `)
      .eq('id', challengeId)
      .single();

    if (error) {
      console.error('Database error:', error);
      return res.status(500).json({ error: 'Failed to fetch challenge' });
    }

    if (!challenge) {
      return res.status(404).json({ error: 'Challenge not found' });
    }

    // Get current winner if ruleset exists
    let winner = null;
    if (challenge.has_ruleset) {
      const { data: winnerData } = await supabaseAdmin
        .from('challenge_ruleset_winners')
        .select(`
          score_id,
          won_at,
          scores (
            score,
            mods_detailed,
            users (
              username,
              avatar_url
            )
          )
        `)
        .eq('challenge_id', challengeId)
        .single();

      if (winnerData) {
        winner = {
          score_id: winnerData.score_id,
          won_at: winnerData.won_at,
          score: winnerData.scores.score,
          mods_detailed: winnerData.scores.mods_detailed,
          username: winnerData.scores.users.username,
          avatar_url: winnerData.scores.users.avatar_url
        };
      }
    }

    res.status(200).json({
      success: true,
      challenge,
      winner
    });

  } catch (error) {
    console.error('API error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}

async function handleCreateOrUpdateRuleset(req, res, challengeId) {
  try {
    const { 
      required_mods, 
      ruleset_match_type 
    } = req.body;

    // Validate input (removed name and description validation)
    const validation = validateRulesetData({
      required_mods,
      ruleset_match_type
    });

    if (!validation.valid) {
      return res.status(400).json({ 
        error: 'Invalid ruleset data', 
        details: validation.errors 
      });
    }

    // Check if challenge exists
    const { data: challenge, error: challengeError } = await supabaseAdmin
      .from('challenges')
      .select('id, name')
      .eq('id', challengeId)
      .single();

    if (challengeError || !challenge) {
      return res.status(404).json({ error: 'Challenge not found' });
    }

    // Update challenge with ruleset (removed name and description)
    const { data: updatedChallenge, error: updateError } = await supabaseAdmin
      .from('challenges')
      .update({
        has_ruleset: true,
        required_mods: required_mods || [],
        ruleset_match_type: ruleset_match_type || 'at_least',  // CHANGED: Default to 'at_least'
        updated_at: new Date().toISOString()
      })
      .eq('id', challengeId)
      .select()
      .single();

    if (updateError) {
      console.error('Update error:', updateError);
      return res.status(500).json({ error: 'Failed to update ruleset' });
    }

    // Calculate new winner
    const { data: winnerResult, error: winnerError } = await supabaseAdmin
      .rpc('update_challenge_ruleset_winner', { challenge_id_param: challengeId });

    if (winnerError) {
      console.warn('Winner calculation error:', winnerError);
    }

    res.status(200).json({
      success: true,
      challenge: updatedChallenge,
      winner_result: winnerResult,
      message: 'Ruleset updated successfully'
    });

  } catch (error) {
    console.error('API error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}

async function handleDeleteRuleset(req, res, challengeId) {
  try {
    // Remove ruleset from challenge (removed name and description)
    const { data: updatedChallenge, error: updateError } = await supabaseAdmin
      .from('challenges')
      .update({
        has_ruleset: false,
        required_mods: [],
        ruleset_match_type: 'at_least', 
        updated_at: new Date().toISOString()
      })
      .eq('id', challengeId)
      .select()
      .single();

    if (updateError) {
      console.error('Update error:', updateError);
      return res.status(500).json({ error: 'Failed to remove ruleset' });
    }

    // Remove winner record
    await supabaseAdmin
      .from('challenge_ruleset_winners')
      .delete()
      .eq('challenge_id', challengeId);

    res.status(200).json({
      success: true,
      message: 'Ruleset removed successfully'
    });

  } catch (error) {
    console.error('API error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}

function validateRulesetData({ required_mods, ruleset_match_type }) {
  const errors = [];

  // Validate match type
  if (!['exact', 'at_least', 'any_of'].includes(ruleset_match_type)) {
    errors.push('Invalid match type. Must be "exact", "at_least", or "any_of"');
  }

  // Validate required mods
  if (!Array.isArray(required_mods)) {
    errors.push('Required mods must be an array');
  } else if (required_mods.length === 0) {
    errors.push('At least one mod must be specified');
  } else {
    // Validate each mod
    const modAcronyms = [];
    
    for (let i = 0; i < required_mods.length; i++) {
      const mod = required_mods[i];
      
      if (!mod.acronym || typeof mod.acronym !== 'string') {
        errors.push(`Mod ${i + 1}: acronym is required`);
        continue;
      }

      const acronym = mod.acronym.toUpperCase();
      
      // Check if mod exists in osu! reference
      if (!OSU_MODS[acronym]) {
        errors.push(`Mod ${i + 1}: "${acronym}" is not a valid osu! mod`);
        continue;
      }

      // Check for duplicate mods
      if (modAcronyms.includes(acronym)) {
        errors.push(`Mod ${i + 1}: "${acronym}" is specified multiple times`);
        continue;
      }
      
      modAcronyms.push(acronym);

      // Validate settings
      if (mod.settings && typeof mod.settings === 'object') {
        const validSettings = OSU_MODS[acronym].settings;
        
        for (const settingKey of Object.keys(mod.settings)) {
          if (!validSettings.includes(settingKey)) {
            errors.push(`Mod ${acronym}: "${settingKey}" is not a valid setting`);
            continue;
          }

          const settingValue = mod.settings[settingKey];
          const range = SETTING_RANGES[settingKey];
          
          if (range) {
            if (range.type === 'boolean' && typeof settingValue !== 'boolean') {
              errors.push(`Mod ${acronym}: "${settingKey}" must be a boolean`);
            } else if (range.type === 'number' && typeof settingValue !== 'number') {
              errors.push(`Mod ${acronym}: "${settingKey}" must be a number`);
            } else if (range.type === 'integer' && (!Number.isInteger(settingValue))) {
              errors.push(`Mod ${acronym}: "${settingKey}" must be an integer`);
            } else if (range.min !== undefined && settingValue < range.min) {
              errors.push(`Mod ${acronym}: "${settingKey}" must be at least ${range.min}`);
            } else if (range.max !== undefined && settingValue > range.max) {
              errors.push(`Mod ${acronym}: "${settingKey}" must be at most ${range.max}`);
            }
          }
        }
      }
    }

    // Check for conflicting mods
    for (const conflictGroup of CONFLICTING_MODS) {
      const conflictingFound = modAcronyms.filter(acronym => conflictGroup.includes(acronym));
      if (conflictingFound.length > 1) {
        errors.push(`Conflicting mods detected: ${conflictingFound.join(', ')} cannot be used together`);
      }
    }
  }

  return {
    valid: errors.length === 0,
    errors
  };
}

export default handler;


================================================
FILE: frontend/pages/api/admin/rulesets/validate.js
================================================
import { withAdminAuth } from '../../../../lib/auth-middleware';
import { OSU_MODS, CONFLICTING_MODS, SETTING_RANGES, SETTING_CONFIGS } from '../../../../lib/osu-mods-reference';

async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  return withAdminAuth(handleValidateRuleset)(req, res);
}

async function handleValidateRuleset(req, res) {
  try {
    const { required_mods, ruleset_match_type, test_scores } = req.body;

    // Validate the ruleset itself (removed name validation)
    const rulesetValidation = validateRulesetData({
      required_mods,
      ruleset_match_type
    });

    if (!rulesetValidation.valid) {
      return res.status(400).json({
        success: false,
        errors: rulesetValidation.errors
      });
    }

    // Test against provided scores if any
    let scoreTests = [];
    if (test_scores && Array.isArray(test_scores)) {
      scoreTests = test_scores.map(testScore => {
        const qualifies = validateScoreAgainstRuleset(
          testScore.mods_detailed || [],
          required_mods || [],
          ruleset_match_type || 'at_least' 
        );

        return {
          username: testScore.username || 'Test User',
          mods_detailed: testScore.mods_detailed || [],
          qualifies,
          reason: qualifies ? 'Meets ruleset requirements' : getFailureReason(
            testScore.mods_detailed || [],
            required_mods || [],
            ruleset_match_type || 'at_least'  
          )
        };
      });
    }

    // Generate examples of qualifying mod combinations
    const examples = generateQualifyingExamples(required_mods || [], ruleset_match_type || 'at_least'); 

    res.status(200).json({
      success: true,
      validation: {
        valid: true,
        required_mods: required_mods || [],
        match_type: ruleset_match_type || 'at_least' 
      },
      score_tests: scoreTests,
      examples: examples,
      message: 'Ruleset validation successful'
    });

  } catch (error) {
    console.error('Validation API error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}

function validateRulesetData({ required_mods, ruleset_match_type }) {
  const errors = [];

  // Validate match type
  if (!['exact', 'at_least', 'any_of'].includes(ruleset_match_type)) {
    errors.push('Invalid match type. Must be "exact", "at_least", or "any_of"');
  }

  // Validate required mods
  if (!Array.isArray(required_mods)) {
    errors.push('Required mods must be an array');
  } else if (required_mods.length === 0) {
    errors.push('At least one mod must be specified');
  } else {
    // Validate each mod
    const modAcronyms = [];
    
    for (let i = 0; i < required_mods.length; i++) {
      const mod = required_mods[i];
      
      if (!mod.acronym || typeof mod.acronym !== 'string') {
        errors.push(`Mod ${i + 1}: acronym is required`);
        continue;
      }

      const acronym = mod.acronym.toUpperCase();
      
      // Check if mod exists in osu! reference
      if (!OSU_MODS[acronym]) {
        errors.push(`Mod ${i + 1}: "${acronym}" is not a valid osu! mod`);
        continue;
      }

      // Check for duplicate mods
      if (modAcronyms.includes(acronym)) {
        errors.push(`Mod ${i + 1}: "${acronym}" is specified multiple times`);
        continue;
      }
      
      modAcronyms.push(acronym);

      // Validate settings
      if (mod.settings && typeof mod.settings === 'object') {
        const validSettings = OSU_MODS[acronym].settings;
        
        for (const settingKey of Object.keys(mod.settings)) {
          if (!validSettings.includes(settingKey)) {
            errors.push(`Mod ${acronym}: "${settingKey}" is not a valid setting`);
            continue;
          }

          const settingValue = mod.settings[settingKey];
          const range = SETTING_RANGES[settingKey];
          
          if (range) {
            if (range.type === 'boolean' && typeof settingValue !== 'boolean') {
              errors.push(`Mod ${acronym}: "${settingKey}" must be a boolean`);
            } else if (range.type === 'number' && typeof settingValue !== 'number') {
              errors.push(`Mod ${acronym}: "${settingKey}" must be a number`);
            } else if (range.type === 'integer' && (!Number.isInteger(settingValue))) {
              errors.push(`Mod ${acronym}: "${settingKey}" must be an integer`);
            } else if (range.min !== undefined && settingValue < range.min) {
              errors.push(`Mod ${acronym}: "${settingKey}" must be at least ${range.min}`);
            } else if (range.max !== undefined && settingValue > range.max) {
              errors.push(`Mod ${acronym}: "${settingKey}" must be at most ${range.max}`);
            }
          }
        }
      }
    }

    // Check for conflicting mods
    for (const conflictGroup of CONFLICTING_MODS) {
      const conflictingFound = modAcronyms.filter(acronym => conflictGroup.includes(acronym));
      if (conflictingFound.length > 1) {
        errors.push(`Conflicting mods detected: ${conflictingFound.join(', ')} cannot be used together`);
      }
    }
  }

  return {
    valid: errors.length === 0,
    errors
  };
}

function validateScoreAgainstRuleset(scoreMods, requiredMods, matchType = 'at_least') {
  // Handle empty cases
  if (!requiredMods || requiredMods.length === 0) {
    return true; // No requirements means all scores qualify
  }
  
  if (!scoreMods) {
    scoreMods = [];
  }

  switch (matchType) {
    case 'exact':
      // Must have exactly the same mods with same settings
      if (scoreMods.length !== requiredMods.length) {
        return false;
      }
      
      // Check each required mod exists with exact settings
      for (const requiredMod of requiredMods) {
        const scoreModMatch = scoreMods.find(scoreMod => 
          scoreMod.acronym === requiredMod.acronym
        );
        
        if (!scoreModMatch) {
          return false;
        }
        
        // Check settings match exactly
        const requiredSettings = requiredMod.settings || {};
        const scoreSettings = scoreModMatch.settings || {};
        
        if (JSON.stringify(requiredSettings) !== JSON.stringify(scoreSettings)) {
          return false;
        }
      }
      
      return true;
    
    case 'at_least':
      // Must have all required mods with exact settings (can have extras)
      for (const requiredMod of requiredMods) {
        const scoreModMatch = scoreMods.find(scoreMod => 
          scoreMod.acronym === requiredMod.acronym
        );
        
        if (!scoreModMatch) {
          return false;
        }
        
        // Check if all required settings match
        const requiredSettings = requiredMod.settings || {};
        const scoreSettings = scoreModMatch.settings || {};
        
        for (const [key, value] of Object.entries(requiredSettings)) {
          if (scoreSettings[key] !== value) {
            return false;
          }
        }
      }
      
      return true;
    
    case 'any_of':
      // Must have at least one required mod with exact settings
      for (const requiredMod of requiredMods) {
        const scoreModMatch = scoreMods.find(scoreMod => 
          scoreMod.acronym === requiredMod.acronym
        );
        
        if (scoreModMatch) {
          // Check if all required settings match
          const requiredSettings = requiredMod.settings || {};
          const scoreSettings = scoreModMatch.settings || {};
          
          let settingsMatch = true;
          for (const [key, value] of Object.entries(requiredSettings)) {
            if (scoreSettings[key] !== value) {
              settingsMatch = false;
              break;
            }
          }
          
          if (settingsMatch) {
            return true;
          }
        }
      }
      
      return false;
    
    default:
      return false;
  }
}

function getFailureReason(scoreMods, requiredMods, matchType = 'at_least') {
  if (!requiredMods || requiredMods.length === 0) {
    return 'No requirements specified';
  }

  if (!scoreMods) {
    scoreMods = [];
  }

  switch (matchType) {
    case 'exact':
      if (scoreMods.length !== requiredMods.length) {
        return `Must have exactly ${requiredMods.length} mod(s), but has ${scoreMods.length}`;
      }
      
      for (const requiredMod of requiredMods) {
        const scoreModMatch = scoreMods.find(scoreMod => 
          scoreMod.acronym === requiredMod.acronym
        );
        
        if (!scoreModMatch) {
          return `Missing required mod: ${requiredMod.acronym}`;
        }
        
        const requiredSettings = requiredMod.settings || {};
        const scoreSettings = scoreModMatch.settings || {};
        
        for (const [key, value] of Object.entries(requiredSettings)) {
          if (scoreSettings[key] !== value) {
            return `Mod ${requiredMod.acronym}: ${key} should be ${value}, but is ${scoreSettings[key]}`;
          }
        }
      }
      
      return 'Unknown exact match failure';
    
    case 'at_least':
      for (const requiredMod of requiredMods) {
        const scoreModMatch = scoreMods.find(scoreMod => 
          scoreMod.acronym === requiredMod.acronym
        );
        
        if (!scoreModMatch) {
          return `Missing required mod: ${requiredMod.acronym}`;
        }
        
        const requiredSettings = requiredMod.settings || {};
        const scoreSettings = scoreModMatch.settings || {};
        
        for (const [key, value] of Object.entries(requiredSettings)) {
          if (scoreSettings[key] !== value) {
            return `Mod ${requiredMod.acronym}: ${key} should be ${value}, but is ${scoreSettings[key]}`;
          }
        }
      }
      
      return 'Unknown at_least failure';
    
    case 'any_of':
      const modNames = requiredMods.map(mod => mod.acronym).join(', ');
      return `Must have at least one of: ${modNames} with correct settings`;
    
    default:
      return 'Invalid match type';
  }
}

function generateQualifyingExamples(requiredMods, matchType = 'at_least') {
  if (!requiredMods || requiredMods.length === 0) {
    return [{ description: 'Any mods (no requirements)', mods: [] }];
  }

  const examples = [];

  switch (matchType) {
    case 'exact':
      examples.push({
        description: 'Exact match - only these mods',
        mods: requiredMods
      });
      break;
    
    case 'at_least':
      examples.push({
        description: 'Minimum required mods',
        mods: requiredMods
      });
      
      if (requiredMods.length === 1) {
        examples.push({
          description: 'Required mods + additional mod',
          mods: [...requiredMods, { acronym: 'HD', settings: {} }]
        });
      }
      break;
    
    case 'any_of':
      requiredMods.forEach((mod, index) => {
        examples.push({
          description: `Option ${index + 1}: ${mod.acronym} ${Object.keys(mod.settings || {}).length > 0 ? 'with settings' : ''}`,
          mods: [mod]
        });
      });
      
      if (requiredMods.length > 1) {
        examples.push({
          description: 'Multiple options + additional mod',
          mods: [requiredMods[0], { acronym: 'HD', settings: {} }]
        });
      }
      break;
  }

  return examples;
}

export default handler;


================================================
FILE: frontend/pages/api/auth/callback.js
================================================
import { supabaseAdmin } from '../../../lib/supabase-admin';
import { generateSessionToken } from '../../../lib/secure-auth';

async function handler(req, res) {
  const { code, state, error } = req.query;
  
  console.log('üîë === SECURE AUTH CALLBACK START ===');
  console.log('üìç URL:', req.url);
  console.log('üîë Code present:', !!code);
  console.log('üé≤ State received:', state);
  console.log('‚ùå Error param:', error);
  
  // Check for OAuth errors first
  if (error) {
    console.log('‚ùå OAuth error received:', error);
    return res.redirect('/?error=oauth_denied');
  }
  
  // Verify state parameter - NO BYPASS ALLOWED
  const cookieHeader = req.headers.cookie || '';
  console.log('üç™ Cookie header:', cookieHeader);
  
  if (!cookieHeader) {
    console.log('‚ùå SECURITY: No cookies received - potential attack');
    return res.redirect('/?error=security_violation');
  }
  
  const cookies = cookieHeader.split('; ');
  console.log('üç™ All cookies:', cookies);
  
  // Look for state cookie with multiple fallbacks
  let stateCookie = cookies.find(c => c.startsWith('osu_auth_state='));
  if (!stateCookie) {
    stateCookie = cookies.find(c => c.startsWith('osu_auth_state_backup='));
  }
  
  if (!stateCookie) {
    console.log('‚ùå SECURITY: State cookie not found - BLOCKING AUTH');
    console.log('Available cookies:', cookies);
    return res.redirect('/?error=security_violation');
  }
  
  const savedState = stateCookie.split('=')[1];
  console.log('üîç Saved state:', savedState);
  console.log('üîç Received state:', state);
  
  if (!savedState || savedState !== state) {
    console.log('‚ùå SECURITY: State mismatch - BLOCKING AUTH');
    return res.redirect('/?error=security_violation');
  }
  
  if (!code) {
    console.log('‚ùå No authorization code received');
    return res.redirect('/?error=auth_failed');
  }
  
  console.log('‚úÖ State verification PASSED - proceeding with auth');
  
  // Clear state cookies immediately
  const isProduction = process.env.NODE_ENV === 'production';
  const clearCookies = [
    'osu_auth_state=; Path=/; HttpOnly; SameSite=Lax; Max-Age=0' + (isProduction ? '; Secure' : ''),
    'osu_auth_state_backup=; Path=/; HttpOnly; Max-Age=0' + (isProduction ? '; Secure' : '')
  ];
  
  try {
    console.log('üîÑ Exchanging code for access token...');
    
    // Exchange code for access token
    const tokenResponse = await fetch('https://osu.ppy.sh/oauth/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        client_id: process.env.OSU_CLIENT_ID,
        client_secret: process.env.OSU_CLIENT_SECRET,
        code,
        grant_type: 'authorization_code',
        redirect_uri: process.env.OSU_REDIRECT_URI,
      }),
    });
    
    if (!tokenResponse.ok) {
      const errorText = await tokenResponse.text();
      console.error('‚ùå Token exchange failed:', tokenResponse.status, errorText);
      return res.redirect('/?error=token_exchange_failed');
    }
    
    const { access_token } = await tokenResponse.json();
    console.log('‚úÖ Access token received');
    
    // Get user info from osu! API
    console.log('üë§ Fetching user info from osu! API...');
    const userResponse = await fetch('https://osu.ppy.sh/api/v2/me', {
      headers: {
        'Authorization': `Bearer ${access_token}`,
      },
    });
    
    if (!userResponse.ok) {
      console.error('‚ùå User info fetch failed:', userResponse.status);
      return res.redirect('/?error=user_fetch_failed');
    }
    
    const osuUser = await userResponse.json();
    console.log('üë§ osu! user data:', { 
      id: osuUser.id, 
      username: osuUser.username, 
      country: osuUser.country_code 
    });
    
    // Create NEW session, never reuse existing ones
    console.log('üíæ Creating new user session...');
    const { data: dbUser, error: dbError } = await supabaseAdmin
      .from('users')
      .upsert({
        osu_id: osuUser.id,
        username: osuUser.username,
        avatar_url: osuUser.avatar_url,
        country: osuUser.country_code,
        global_rank: osuUser.statistics?.global_rank,
        country_rank: osuUser.statistics?.country_rank,
        pp: osuUser.statistics?.pp,
        updated_at: new Date().toISOString()
      }, {
        onConflict: 'osu_id',
        ignoreDuplicates: false
      })
      .select()
      .single();
    
    if (dbError) {
      console.error('‚ùå Database error:', dbError);
      return res.redirect('/?error=database_error');
    }
    
    console.log('‚úÖ User saved to database:', { 
      id: dbUser.id, 
      username: dbUser.username,
      admin: dbUser.admin 
    });
    
    // Generate secure session token using the proper function
    const { token: sessionToken, expiresAt } = generateSessionToken(
      dbUser.id,
      req.headers['user-agent'],
      req  // Pass full request for proper IP extraction
    );

    // Set NEW session cookie
    const maxAge = Math.floor((expiresAt - Date.now()) / 1000);
    const sessionCookie = `osu_session=${sessionToken}; Path=/; HttpOnly; SameSite=Lax; Max-Age=${maxAge}` + (isProduction ? '; Secure' : '');

    console.log('Setting NEW session cookie');
    
    // Set all cookies
    res.setHeader('Set-Cookie', [...clearCookies, sessionCookie]);
    
    // Redirect to profile
    console.log('‚Ü©Ô∏è Redirecting to profile...');
    res.redirect(`/profile/${dbUser.id}`);
    
  } catch (error) {
    console.error('üö® Auth callback error:', error);
    res.redirect(`/?error=auth_failed&details=${encodeURIComponent(error.message)}`);
  }
}

export default handler;


================================================
FILE: frontend/pages/api/auth/login.js
================================================
function handler(req, res) {
    const { OSU_CLIENT_ID, OSU_REDIRECT_URI } = process.env;
    
    console.log('üîë === SECURE LOGIN START ===');
    console.log('üåç Environment:', process.env.NODE_ENV);
    console.log('üè† Host:', req.headers.host);
    console.log('üîó Redirect URI:', OSU_REDIRECT_URI);
    
    if (!OSU_CLIENT_ID || !OSU_REDIRECT_URI) {
        console.error('‚ùå Missing OAuth configuration');
        return res.status(500).json({ error: 'Server configuration error' });
    }
    
    // Generate cryptographically secure state
    const state = require('crypto').randomBytes(16).toString('hex');
    console.log('üé≤ Generated state:', state);
    
    const isProduction = process.env.NODE_ENV === 'production';
    
    // Set cookies with proper attributes for OAuth flows
    const stateCookieOptions = [
    `osu_auth_state=${state}`,
    'Path=/',
    'HttpOnly',
    'SameSite=Lax',
    'Max-Age=600',
    ...(isProduction ? ['Secure'] : [])
    ].join('; ');

    console.log('Setting state cookie (SameSite=Lax):', stateCookieOptions);

    res.setHeader('Set-Cookie', stateCookieOptions);
    
    // Build OAuth URL with proper parameters
    const authUrl = new URL('https://osu.ppy.sh/oauth/authorize');
    authUrl.searchParams.set('client_id', OSU_CLIENT_ID);
    authUrl.searchParams.set('redirect_uri', OSU_REDIRECT_URI);
    authUrl.searchParams.set('response_type', 'code');
    authUrl.searchParams.set('scope', 'identify public');
    authUrl.searchParams.set('state', state);
    
    const finalAuthUrl = authUrl.toString();
    console.log('üîë Redirecting to OAuth provider');
    
    // Always redirect to OAuth, never skip this step
    res.redirect(finalAuthUrl);
}

export default handler;


================================================
FILE: frontend/pages/api/auth/logout.js
================================================
import { handleAPIResponse, handleAPIError } from '../../../lib/api-utils';

const COOKIE_DOMAIN = process.env.COOKIE_DOMAIN || 'challengersnexus.com';

function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  console.log('üö™ Logout request received');
  console.log('üåç Environment:', process.env.NODE_ENV);
  console.log('üç™ Current cookies:', req.headers.cookie);

  try {
    const isProduction = process.env.NODE_ENV === 'production';

    const clearCookies = [
      `osu_session=; Path=/; HttpOnly; SameSite=Lax; Max-Age=0${isProduction ? '; Secure' : ''}`,
      `osu_auth_state=; Path=/; HttpOnly; SameSite=Lax; Max-Age=0${isProduction ? '; Secure' : ''}`,
      `osu_auth_state=; Path=/; HttpOnly; SameSite=None; Max-Age=0${isProduction ? '; Secure' : ''}`,
      `osu_auth_state_backup=; Path=/; HttpOnly; SameSite=Lax; Max-Age=0${isProduction ? '; Secure' : ''}`,
      
      ...(isProduction ? [
        `osu_session=; Path=/; Domain=.${COOKIE_DOMAIN}; HttpOnly; SameSite=Lax; Max-Age=0; Secure`,
        `osu_session=; Path=/; Domain=${COOKIE_DOMAIN}; HttpOnly; SameSite=Lax; Max-Age=0; Secure`
      ] : [])
    ];

    console.log('üßπ Clearing session cookies:', clearCookies);
    res.setHeader('Set-Cookie', clearCookies);
    
    // Prevent any caching of logout response
    res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');

    console.log('üç™ Session cookie cleared');

    return handleAPIResponse(res, {
      message: 'Logged out successfully',
      cookiesCleared: clearCookies.length
    });

  } catch (error) {
    console.error('üö® Logout error:', error);
    
    // Even if there's an error, try to clear the main session cookie
    const isProduction = process.env.NODE_ENV === 'production';
    res.setHeader('Set-Cookie', [
      `osu_session=; Path=/; HttpOnly; SameSite=Lax; Max-Age=0${isProduction ? '; Secure' : ''}`
    ]);
    
    return res.status(500).json({ 
      success: false, 
      error: 'Failed to logout',
      timestamp: new Date().toISOString()
    });
  }
}

export default handler;


================================================
FILE: frontend/pages/api/auth/status.js
================================================
import { withOptionalAuth } from '../../../lib/auth-middleware';
import { handleAPIResponse, handleAPIError } from '../../../lib/api-utils';

async function handler(req, res) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }
  
  // Allow very short caching for performance, but not so long it breaks logout
  res.setHeader('Cache-Control', 'private, no-cache, no-store, must-revalidate');
  res.setHeader('Pragma', 'no-cache');
  res.setHeader('Expires', '0');
  
  // Add cache busting headers for logout scenarios
  const timestamp = Date.now();

  try {
    console.log('üîç Auth status check:', {
      hasUser: !!req.user,
      username: req.user?.username,
      timestamp: new Date().toISOString()
    });

    if (!req.user) {
      return handleAPIResponse(res, { 
        authenticated: false, 
        user: null,
        timestamp
      }, { cache: false });
    }

    return handleAPIResponse(res, {
      authenticated: true,
      user: {
        id: req.user.id,
        username: req.user.username,
        avatar_url: req.user.avatar_url,
        country: req.user.country,
        admin: req.user.admin,
        osu_id: req.user.osu_id
      },
      timestamp
    }, { cache: false });
  } catch (error) {
    console.error('üö® Auth status error:', error);
    return res.status(500).json({ 
      authenticated: false, 
      user: null,
      error: 'Internal server error',
      timestamp
    });
  }
}

export default withOptionalAuth(handler);


================================================
FILE: frontend/pages/api/card/index.js
================================================
import fs from "fs";
import * as cheerio from "cheerio";
import TextToSVG from "text-to-svg";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SUPABASE_URL = "https://yqgqoxgykswytoswqpkj.supabase.co";
const SUPABASE_ANON_KEY = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

const fontRegular = TextToSVG.loadSync(path.join(process.cwd(), "public/fonts/Inter.ttf"));
const fontBold = TextToSVG.loadSync(path.join(process.cwd(), "public/fonts/Inter-Bold.ttf"));
const fontExtraBold = TextToSVG.loadSync(path.join(process.cwd(), "public/fonts/Inter-ExtraBold.ttf"));

function pickFontById(id) {
  if (["username", "current_streak", "best_streak", "text9", "text74", "text9-9", "text73"].includes(id)) {
    return fontBold;
  }
  if (["total_score", "avg_acc", "rank", "plays", "top1", "top"].includes(id)) {
    return fontExtraBold;
  }
  return fontRegular;
}

async function callRpc(name, params = {}) {
  const res = await fetch(`${SUPABASE_URL}/rest/v1/rpc/${name}`, {
    method: "POST",
    headers: {
      apikey: SUPABASE_ANON_KEY,
      Authorization: `Bearer ${SUPABASE_ANON_KEY}`,
      "Content-Type": "application/json",
      Accept: "application/json",
    },
    body: JSON.stringify(params),
  });
  if (!res.ok) throw new Error(`Supabase RPC failed: ${res.statusText}`);
  return res.json();
}

function adjustFontSizePx(text, maxChars, basePx) {
  if (!text) return basePx;
  return text.length > maxChars ? (basePx * maxChars) / text.length : basePx;
}

function getCharacterOffset(text, baseChars, offsetPerChar) {
  if (!text) return 0;
  const extraChars = Math.max(0, text.length - baseChars);
  return extraChars * offsetPerChar;
}

const pct = (v) => (typeof v === "number" ? v.toFixed(2) + "%" : "-");

function parseStyle(styleAttr = "") {
  const out = {};
  (styleAttr || "")
    .split(";")
    .map((s) => s.trim())
    .filter(Boolean)
    .forEach((decl) => {
      const idx = decl.indexOf(":");
      if (idx > -1) {
        const k = decl.slice(0, idx).trim();
        const v = decl.slice(idx + 1).trim();
        out[k] = v;
      }
    });
  return out;
}

function mergedStyle(textStyle, tspanStyle) {
  return { ...textStyle, ...tspanStyle };
}

function coordsFor($node, $parent) {
  const x = parseFloat($node.attr("x") ?? $parent.attr("x") ?? "0");
  const y = parseFloat($node.attr("y") ?? $parent.attr("y") ?? "0");
  return { x, y };
}

function xWithAnchor(x, anchor, width) {
  if (anchor === "middle") return x - width / 2;
  if (anchor === "end") return x - width;
  return x;
}

const dynamicOffsets = {};

function convertAllTextToPaths($, variant = "main") {
  $("text").each((_, el) => {
    const $text = $(el);
    const textStyle = parseStyle($text.attr("style"));
    const textAnchor = ($text.attr("text-anchor") || textStyle["text-anchor"] || "start").trim();
    const $group = $("<g/>");
    if ($text.attr("id")) $group.attr("id", $text.attr("id"));
    if ($text.attr("transform")) $group.attr("transform", $text.attr("transform"));

    const tspans = $text.children("tspan");
    const targets = tspans.length ? tspans.toArray() : [el];

    targets.forEach((node) => {
      const $node = $(node);
      const nodeStyle = parseStyle($node.attr("style"));
      const st = mergedStyle(textStyle, nodeStyle);

      const textContent = (tspans.length ? $node.text() : $text.text()) ?? "";
      if (!textContent) return;

      const fontSize = parseFloat(st["font-size"] || "16");
      let { x, y } = coordsFor($node, $text);
      y += 1.2;

      const id = $text.attr("id") || "";
      const font = pickFontById(id) || fontRegular;
      switch (id) {
        case "username":
          x -= 0.6;
          y -= 0.2;
          x += dynamicOffsets.username || 0;
          break;
        case "current_streak":
          x += 3.1;
          y += 3;
          if (variant === "mini") {
            x += 2;
          }
          x += dynamicOffsets.current_streak || 0;
          break;
        case "best_streak":
          x += 3.3;
          y += 3;
          if (variant === "mini") {
            x += 2.2;
          }
          x += dynamicOffsets.best_streak || 0;
          break;
        case "text9":
          x += 0.1;
		  if (variant === "mini") {
            x += 2;
		  }
          break;
        case "text74":
          x += 0.1;
		  if (variant === "mini") {
            x += 2;
		  }
          break;
        case "text9-9":
          x += 0.7;
		  if (variant === "mini") {
            x += 2;
		  }
          break;
        case "text73":
          x += 0.7;
		  if (variant === "mini") {
            x += 2;
		  }
          break;
      }

      const metrics = font.getMetrics(textContent, { fontSize });
      const width = metrics.width || 0;
      const topY = y - (metrics.ascender || 0);
      const startX = xWithAnchor(x, textAnchor, width);
      const d = font.getD(textContent, {
        x: startX,
        y: topY,
        fontSize,
      });

      const $path = $("<path/>").attr("d", d);
      if (st.fill) $path.attr("fill", st.fill);
      else $path.attr("fill", "black");
      if (st["fill-opacity"]) $path.attr("fill-opacity", st["fill-opacity"]);
      if (st.stroke) $path.attr("stroke", st.stroke);
      if (st["stroke-opacity"]) $path.attr("stroke-opacity", st["stroke-opacity"]);
      if (st["stroke-width"]) $path.attr("stroke-width", st["stroke-width"]);
      if (st["stroke-linecap"]) $path.attr("stroke-linecap", st["stroke-linecap"]);
      if (st["stroke-linejoin"]) $path.attr("stroke-linejoin", st["stroke-linejoin"]);
      if (st["paint-order"]) $path.attr("paint-order", st["paint-order"]);

      $group.append($path);
    });

    $text.replaceWith($group);
  });
}

async function generateSvgGeneric(svgFile, profile, stats, streaks, leaderboard, variant = "main") {
  const svg = fs.readFileSync(svgFile, "utf8");
  const $ = cheerio.load(svg, { xmlMode: true });

  const me = Array.isArray(leaderboard)
    ? leaderboard.find((r) => r && (r.is_target_user || r.is_target_user === true)) || {}
    : {};

  const $nameSpan = $("#username tspan");
  if ($nameSpan.length) {
    const username = profile?.username ?? "name";
    const basePx = parseFloat(parseStyle($nameSpan.attr("style"))["font-size"] || "16");
    const newPx = adjustFontSizePx(username, 11, basePx);
    $nameSpan.text(username);
    const ns = parseStyle($nameSpan.attr("style"));
    ns["font-size"] = `${newPx}px`;
    const styleStr = Object.entries(ns)
      .map(([k, v]) => `${k}:${v}`)
      .join(";");
    $nameSpan.attr("style", styleStr);
    if ($nameSpan.length !== 3) {
      dynamicOffsets.username = getCharacterOffset(username, username.length / 2, -0.67);
    } else if (username.length > 10); {
      dynamicOffsets.username = getCharacterOffset(username, username.length / 2, -0.5);
    }
    
  }

  const currentStreakText = String(streaks?.currentStreak ?? "-");
  dynamicOffsets.current_streak = getCharacterOffset(currentStreakText, 1, -1.1);

  const bestStreakText = String(streaks?.longestStreak ?? "-");
  dynamicOffsets.best_streak = getCharacterOffset(bestStreakText, 1, -1.3);

  if ($("#pfp").length) {
    async function getOsuAvatar(osuUsername) {
	  try {
		const tokenRes = await fetch("https://osu.ppy.sh/oauth/token", {
		  method: "POST",
		  headers: { "Content-Type": "application/json" },
		  body: JSON.stringify({
			client_id: process.env.OSU_CLIENT_ID,
			client_secret: process.env.OSU_CLIENT_SECRET,
			grant_type: "client_credentials",
			scope: "public",
		  }),
		});
		if (!tokenRes.ok) throw new Error("Failed to get OAuth token");
		const tokenData = await tokenRes.json();
		const accessToken = tokenData.access_token;

		const userRes = await fetch(`https://osu.ppy.sh/api/v2/users/${osuUsername}/osu`, {
		  headers: { Authorization: `Bearer ${accessToken}` },
		});
		if (!userRes.ok) throw new Error("Failed to fetch osu user");
		const userData = await userRes.json();

		const avatarUrl = userData.avatar_url;

		const imgRes = await fetch(avatarUrl);
		if (!imgRes.ok) throw new Error("Failed to fetch avatar image");
		const arrayBuffer = await imgRes.arrayBuffer();
		const buffer = Buffer.from(arrayBuffer);

		const contentType = imgRes.headers.get("content-type") || "image/png";

		const base64 = buffer.toString("base64");
		return `data:${contentType};base64,${base64}`;
	  } catch (err) {
		console.error("Failed to fetch osu avatar:", err.message);

		try {
		  const fallbackRes = await fetch("https://paraliyzed.net/img/lara.png");
		  const arrBuf = await fallbackRes.arrayBuffer();
		  const buf = Buffer.from(arrBuf);
		  const base64 = buf.toString("base64");
		  return `data:image/png;base64,${base64}`;
		} catch {
		  return null;
		}
	  }
	}

    const osuAvatar = await getOsuAvatar(profile?.username);
    if (osuAvatar) {
      $("#pfp").attr("xlink:href", osuAvatar);
    }
  }

  const setText = (sel, val) => {
    const $t = $(`${sel} tspan`);
    if ($t.length) $t.text(val);
  };
  setText("#total_score", stats?.totalScorePoints ?? "-");
  setText("#avg_acc", pct(me.average_accuracy));
  setText("#rank", me.position ?? "-");
  setText("#plays", stats?.totalScores ?? "-");
  setText("#top1", stats?.firstPlaceCount ?? "-");
  setText("#top", pct(100 - (me.percentile ?? 0)));
  setText("#current_streak", currentStreakText);
  setText("#best_streak", bestStreakText);
  convertAllTextToPaths($, variant);

  return $.xml();
}

export default async function handler(req, res) {
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Methods", "GET,OPTIONS");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type");
  if (req.method === "OPTIONS") {
    return res.status(200).end();
  }
  if (req.method !== "GET") return res.status(405).send("Method not allowed");

  try {
    const osuId = req.query.id;
    const option = req.query.option || "main";

    if (!osuId) {
      return res.status(400).send("osu ID is required");
    }

    const rawInt = await callRpc("get_user_id_from_osu_id", { p_osu_id: osuId });
    const internalId =
      typeof rawInt === "number"
        ? rawInt
        : Array.isArray(rawInt)
        ? rawInt.find((v) => typeof v === "number")
        : rawInt && typeof rawInt === "object"
        ? Object.values(rawInt).find((v) => typeof v === "number")
        : null;

    if (!internalId) {
      return res.status(404).send("User not found");
    }

    const profileRes = await fetch(
      `https://www.challengersnexus.com/api/user/profile/${internalId}`,
      {
        headers: {
          'Accept': 'application/json'
        }
      }
    );
    
    if (!profileRes.ok) {
      const errorText = await profileRes.text();
      console.error('Profile fetch failed:', profileRes.status, errorText);
      throw new Error(`Failed to fetch profile: ${profileRes.status}`);
    }

    const profileData = await profileRes.json();
    
    if (!profileData || !profileData.success || !profileData.data) {
      console.error('Invalid profile data structure:', profileData);
      throw new Error('Invalid profile data received');
    }

    const profile = profileData.data.user;
    const stats = profileData.data.stats;
    const streaks = profileData.data.streaks;

    if (!profile || !profile.username) {
      console.error('Profile missing required fields:', profile);
      throw new Error('Profile data incomplete');
    }

    const SEASON_ID = await callRpc("get_current_season_id", {});
    const leaderboard = await callRpc("get_season_leaderboard_with_user", {
      user_id_param: internalId,
      season_id_param: SEASON_ID,
    });

    const templateFile = path.join(process.cwd(), "public/card-templates/", option === "mini" ? "mini.svg" : "main.svg");

    const outSvg = await generateSvgGeneric(
	  templateFile,
	  profile,
	  stats,
	  streaks,
	  leaderboard,
	  option
	);

    res.setHeader("Content-Type", "image/svg+xml");
    res.setHeader("Cache-Control", "public, max-age=300");
    res.send(outSvg);
  } catch (err) {
    console.error('Card API error:', err.message);
    if (err.stack) {
      console.error('Stack trace:', err.stack);
    }
    res.status(500).send("Error: " + err.message);
  }
}


================================================
FILE: frontend/pages/api/challenges/[roomId].js
================================================
import { supabase } from '../../../lib/supabase';
import { handleAPIResponse, handleAPIError, validateRequest } from '../../../lib/api-utils';
import { memoryCache, createCacheKey, CACHE_DURATIONS } from '../../../lib/memory-cache';
import { isStale } from '../../../lib/sync-config';

async function handler(req, res) {
  try {
    validateRequest(req, {
      method: 'GET',
      query: {
        roomId: { required: true, pattern: /^\d+$/ }
      }
    });

    const { roomId } = req.query;
    const roomIdNum = parseInt(roomId);

    // CREATE CACHE KEY
    const cacheKey = createCacheKey('challenge_detail', roomId);

    // TRY CACHE FIRST
    const cached = memoryCache.get(cacheKey);
    if (cached) {
      console.log(`üìã Serving challenge ${roomId} from cache`);
      return handleAPIResponse(res, cached, {
        cache: true,
        cacheTime: 300,
        enableETag: true,
        req
      });
    }

    console.log(`üìã Fetching challenge ${roomId} from database`);

    // FETCH FROM DATABASE
    const { data: challenge, error } = await supabase
      .from('challenges')
      .select(`
        *,
        seasons (id, name, start_date, end_date, is_current),
        playlists (
          id, playlist_id, beatmap_id, beatmap_title, beatmap_artist,
          beatmap_version, beatmap_difficulty, beatmap_cover_url,
          beatmap_card_url, beatmap_list_url, beatmap_slimcover_url,
          scores (
            id, score, accuracy, max_combo, mods, mods_detailed, submitted_at,
            users (id, osu_id, username, avatar_url, country)
          )
        )
      `)
      .eq('room_id', roomIdNum)
      .single();

    if (error) {
      if (error.code === 'PGRST116') {
        return handleAPIError(res, new Error('Challenge not found'));
      }
      throw error;
    }

    // SORT SCORES
    if (challenge.playlists) {
      challenge.playlists = challenge.playlists.map(playlist => ({
        ...playlist,
        scores: playlist.scores 
          ? playlist.scores.sort((a, b) => b.score - a.score)
          : []
      }));
    }

    // GET RULESET WINNER
    let rulesetWinner = null;
    let rulesetInfo = null;

    if (challenge.has_ruleset) {
      rulesetInfo = {
        ruleset_name: challenge.ruleset_name,
        ruleset_description: challenge.ruleset_description,
        required_mods: challenge.required_mods || [],
        ruleset_match_type: challenge.ruleset_match_type
      };

      const { data: winnerData } = await supabase
        .from('challenge_ruleset_winners')
        .select(`
          score_id, won_at,
          scores (
            id, score, accuracy, max_combo, mods, mods_detailed,
            users (id, osu_id, username, avatar_url, country)
          )
        `)
        .eq('challenge_id', challenge.id)
        .single();

      if (winnerData) {
        rulesetWinner = {
          score_id: winnerData.score_id,
          won_at: winnerData.won_at,
          score: winnerData.scores.score,
          accuracy: winnerData.scores.accuracy,
          max_combo: winnerData.scores.max_combo,
          mods: winnerData.scores.mods,
          mods_detailed: winnerData.scores.mods_detailed,
          username: winnerData.scores.users.username,
          avatar_url: winnerData.scores.users.avatar_url,
          country: winnerData.scores.users.country,
          user_id: winnerData.scores.users.id,
          osu_id: winnerData.scores.users.osu_id
        };
      }
    }

    // ADD DATA INFO
    const dataAgeMinutes = challenge.updated_at 
      ? Math.floor((Date.now() - new Date(challenge.updated_at).getTime()) / 60000)
      : null;

    const responseData = {
      challenge,
      ruleset_info: rulesetInfo,
      ruleset_winner: rulesetWinner,
      data_info: {
        last_updated: challenge.updated_at,
        data_age_minutes: dataAgeMinutes,
        is_fresh: !isStale(challenge.updated_at),
        next_update_in_minutes: Math.max(0, 5 - (dataAgeMinutes || 0))
      }
    };

    // CACHE THE RESULT
    const cacheDuration = challenge.is_active 
      ? CACHE_DURATIONS.CHALLENGE_DETAIL 
      : 3600000;
    
    memoryCache.set(cacheKey, responseData, cacheDuration);

    console.log(`üìã Challenge ${roomId} loaded (age: ${dataAgeMinutes}min)`);

    return handleAPIResponse(res, responseData, {
      cache: true,
      cacheTime: 300,
      enableETag: true,
      req
    });

  } catch (error) {
    console.error('Challenge detail API error:', error);
    return handleAPIError(res, error);
  }
}

export default handler;


================================================
FILE: frontend/pages/api/challenges/index.js
================================================
import { supabase } from '../../../lib/supabase';
import { supabaseAdmin } from '../../../lib/supabase-admin';
import { withAdminAuth } from '../../../lib/auth-middleware';
import { trackedFetch } from '../../../lib/api-tracker';
import { handleAPIResponse, handleAPIError, validateRequest, getPaginationParams, paginatedResponse } from '../../../lib/api-utils';
import apiTracker from '../../../lib/api-tracker';
import { memoryCache, createCacheKey, CACHE_DURATIONS } from '../../../lib/memory-cache';
import { generateETag, checkETag } from '../../../lib/api-utils';
import { isStale } from '../../../lib/sync-config';

async function handler(req, res) {
  if (req.method === 'GET') {
    return handleGetChallenges(req, res);
  } else if (req.method === 'POST') {
    return withAdminAuth(handleCreateChallenge)(req, res);
  } else {
    return handleAPIError(res, new Error('Method not allowed'));
  }
}

async function handleGetChallenges(req, res) {
  try {
    validateRequest(req, {
      method: 'GET',
      query: {
        active: { type: 'string', enum: ['true', 'false'] },
        season_id: { type: 'number', min: 1 },
        search: { type: 'string', maxLength: 100 },
        sortBy: { type: 'string', enum: ['created_at', 'updated_at', 'name', 'participant_count', 'start_date'] },
        sortOrder: { type: 'string', enum: ['asc', 'desc'] }
      }
    });

    const { 
      active,
      season_id,
      search = '',
      sortBy = 'created_at',
      sortOrder = 'desc'
    } = req.query;

    const { limit, offset, page } = getPaginationParams(req, 100, 50);

    // CREATE CACHE KEY
    const cacheKey = createCacheKey('challenges_list', 'all', {
      active, season_id, search, sortBy, sortOrder, page, limit
    });

    // TRY CACHE FIRST
    const cached = memoryCache.get(cacheKey);
    if (cached) {
      console.log(`üìã Serving challenges from cache: ${cacheKey}`);
      
      // Set cache headers
      res.setHeader('Cache-Control', 's-maxage=300, stale-while-revalidate=150');
      res.setHeader('CDN-Cache-Control', 'max-age=300');
      
      const etag = generateETag(cached);
      res.setHeader('ETag', etag);
      
      if (checkETag(req, etag)) {
        return res.status(304).end();
      }
      
      return paginatedResponse(res, cached.data, cached.pagination.total, { 
        limit, page 
      });
    }

    console.log(`üìã Fetching challenges from database`);

    // FETCH FROM DATABASE
    let query = supabase
      .from('challenges')
      .select(`
        *,
        seasons (id, name, start_date, end_date, is_current),
        playlists (
          id, playlist_id, beatmap_title, beatmap_artist,
          beatmap_version, beatmap_difficulty, beatmap_cover_url,
          beatmap_card_url, beatmap_list_url, beatmap_slimcover_url
        )
      `, { count: 'exact' });

    // Apply filters
    if (active === 'true') {
      query = query.eq('is_active', true);
    } else if (active === 'false') {
      query = query.eq('is_active', false);
    }

    if (season_id) {
      query = query.eq('season_id', parseInt(season_id));
    }

    if (search) {
      query = query.or(`name.ilike.%${search}%,custom_name.ilike.%${search}%,host.ilike.%${search}%`);
    }

    const ascending = sortOrder === 'asc';
    query = query
      .order(sortBy, { ascending })
      .range(offset, offset + limit - 1);

    const { data, error, count } = await query;

    if (error) throw error;

    // CALCULATE FRESHNESS FOR EACH CHALLENGE
    const challengesWithFreshness = data.map(challenge => ({
      ...challenge,
      data_age_minutes: challenge.updated_at 
        ? Math.floor((Date.now() - new Date(challenge.updated_at).getTime()) / 60000)
        : null,
      is_fresh: !isStale(challenge.updated_at)
    }));

    const responseData = {
      challenges: challengesWithFreshness,
      summary: {
        total: count || 0,
        fresh: challengesWithFreshness.filter(c => c.is_fresh).length,
        stale: challengesWithFreshness.filter(c => !c.is_fresh).length
      }
    };

    // CACHE THE RESULT
    const cacheData = {
      data: responseData,
      pagination: { total: count || 0, page, limit }
    };
    
    memoryCache.set(cacheKey, cacheData, CACHE_DURATIONS.CHALLENGES_LIST);

    console.log(`üìã Loaded ${data.length} challenges (${responseData.summary.fresh} fresh, ${responseData.summary.stale} stale)`);

    res.setHeader('Cache-Control', 's-maxage=300, stale-while-revalidate=150');
    res.setHeader('CDN-Cache-Control', 'max-age=300');

    return paginatedResponse(res, responseData, count || 0, { limit, page });

  } catch (error) {
    console.error('Challenges list API error:', error);
    return handleAPIError(res, error);
  }
}

async function handleCreateChallenge(req, res) {
  try {
    console.log('üéØ Create challenge request:', {
      method: req.method,
      body: req.body,
      user: req.user?.username
    });

    validateRequest(req, {
      method: 'POST',
      body: {
        roomId: { required: true, type: 'number', min: 1 },
        name: { type: 'string', maxLength: 500 },
        custom_name: { type: 'string', maxLength: 255 }
      }
    });

    const { roomId, name, custom_name } = req.body;

    if (!Number.isInteger(roomId) || roomId <= 0) {
      throw new Error('Room ID must be a positive integer');
    }

    console.log(`üîç Creating challenge for room ID: ${roomId}`);

    const limitStatus = apiTracker.checkLimits();
    if (limitStatus === 'critical') {
      return handleAPIError(res, new Error('API usage critical - temporarily limiting requests'));
    }

    // Check if challenge already exists
    const { data: existingChallenge, error: checkError } = await supabase
      .from('challenges')
      .select('id, room_id, name, custom_name, is_active')
      .eq('room_id', roomId)
      .single();

    if (checkError && checkError.code !== 'PGRST116') {
      console.error('‚ùå Error checking existing challenge:', checkError);
      throw new Error('Database error while checking existing challenge');
    }

    if (existingChallenge) {
      console.log(`‚ö†Ô∏è Challenge already exists:`, existingChallenge);
      return res.status(409).json({
        success: false,
        error: 'Challenge already exists',
        existing_challenge: existingChallenge
      });
    }

    // Get current season
    let currentSeasonId = null;
    try {
      const baseUrl = req.headers.origin || process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000';
      const seasonResponse = await trackedFetch(`${baseUrl}/api/seasons/current`, {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' }
      }, 'internal-api');

      if (seasonResponse.ok) {
        const seasonData = await seasonResponse.json();
        if (seasonData.success && seasonData.data?.season) {
          currentSeasonId = seasonData.data.season.id;
          console.log(`‚úÖ Found current season: ${currentSeasonId}`);
        }
      }
    } catch (seasonError) {
      console.warn('‚ö†Ô∏è Could not fetch current season:', seasonError.message);
    }

    // Prepare challenge data
    const challengeData = {
      room_id: roomId,
      name: name || `Challenge ${roomId}`,
      custom_name: custom_name || null,
      host: 'Unknown', // Will be updated by cron
      room_type: 'playlisted',
      participant_count: 0,
      is_active: true,
      season_id: currentSeasonId,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    console.log('üìù Inserting challenge data:', challengeData);

    // Create challenge in database
    const { data: challenge, error: createError } = await supabaseAdmin
      .from('challenges')
      .insert(challengeData)
      .select(`
        *,
        seasons (
          id,
          name,
          start_date,
          end_date,
          is_current
        )
      `)
      .single();

    if (createError) {
      console.error('‚ùå Error creating challenge:', createError);
      throw new Error(`Failed to create challenge: ${createError.message}`);
    }

    console.log('‚úÖ Challenge created successfully:', challenge.id);

    const usageStats = apiTracker.getUsageStats();

    console.log('üéâ Challenge creation completed successfully');

    return handleAPIResponse(res, {
      challenge: {
        ...challenge,
        data_info: {
          message: 'Challenge created. Data will be fetched automatically within 5 minutes.',
          next_cron_update: 'Within 5 minutes'
        }
      },
      message: 'Challenge created successfully. Cron job will fetch data within 5 minutes.',
      apiUsage: {
        percentage: usageStats.usage?.functions?.percentage || '0',
        remaining: usageStats.usage?.functions?.remaining || 100000
      }
    }, { status: 201 });

  } catch (error) {
    console.error('‚ùå Create challenge error:', error);
    
    if (error.message?.includes('duplicate key')) {
      return res.status(409).json({
        success: false,
        error: 'Challenge with this room ID already exists'
      });
    }
    
    if (error.message?.includes('validation')) {
      return res.status(400).json({
        success: false,
        error: error.message
      });
    }
    
    return handleAPIError(res, error);
  }
}

export default handler;


================================================
FILE: frontend/pages/api/cron/process-scheduled-challenges.js
================================================
import { supabaseAdmin } from '../../../lib/supabase-admin';
import { trackedOsuAPI } from '../../../lib/osu-api';
import { decryptToken, parseToken, isTokenExpired, createTokenString, encryptToken, maskToken } from '../../../lib/token-encryption';
import { handleAPIError } from '../../../lib/api-utils';

const CRON_SECRET = process.env.CRON_SECRET;
const GRACE_PERIOD_MINUTES = 100; // How late we'll still execute

if (!CRON_SECRET) {
  throw new Error('CRON_SECRET must be set in environment');
}

export default async function handler(req, res) {
  const startTime = Date.now();
  
  console.log('‚è∞ === SCHEDULED CHALLENGES CRON START ===');
  console.log('üìÖ Time:', new Date().toISOString());

  // Verify cron secret - support multiple authentication methods
  const authHeader = req.headers.authorization;
  const cronSecret = req.headers['x-cron-secret'];
  const providedSecret = authHeader?.replace('Bearer ', '');

  // Check both Bearer token and custom header
  const isAuthorized = 
    (providedSecret && providedSecret === CRON_SECRET) ||
    (cronSecret && cronSecret === CRON_SECRET);

  if (!isAuthorized) {
    console.log('‚ùå Unauthorized cron request', {
      hasAuth: !!authHeader,
      hasCronSecret: !!cronSecret,
      ip: req.headers['x-forwarded-for'] || req.socket.remoteAddress,
      userAgent: req.headers['user-agent']
    });
    return res.status(401).json({
      success: false,
      error: 'Unauthorized'
    });
  }

  try {
    // Get all pending schedules that are due
    const now = new Date();
    const gracePeriodAgo = new Date(now.getTime() - GRACE_PERIOD_MINUTES * 60 * 1000);

    console.log('üîç Looking for pending schedules...');
    console.log(`    Due between: ${gracePeriodAgo.toISOString()} and ${now.toISOString()}`);

    const { data: schedules, error: fetchError } = await supabaseAdmin
      .from('scheduled_challenges')
      .select('*')
      .eq('status', 'pending')
      .lte('scheduled_time', now.toISOString())
      .gte('scheduled_time', gracePeriodAgo.toISOString())
      .order('scheduled_time', { ascending: true });

    if (fetchError) {
      throw fetchError;
    }

    console.log(`üìä Found ${schedules?.length || 0} pending schedules to process`);

    if (!schedules || schedules.length === 0) {
      const duration = Date.now() - startTime;
      console.log(`‚úÖ No schedules to process (${duration}ms)`);
      return res.status(200).json({
        success: true,
        message: 'No schedules to process',
        processed: 0,
        duration: duration
      });
    }

    // Process each schedule
    const results = [];
    
    for (const schedule of schedules) {
      const result = await processSchedule(schedule);
      results.push(result);
    }

    // Summary
    const successful = results.filter(r => r.success).length;
    const failed = results.filter(r => !r.success).length;
    const duration = Date.now() - startTime;

    console.log('üìä Processing summary:', {
      total: results.length,
      successful,
      failed,
      duration: `${duration}ms`
    });

    console.log('‚è∞ === SCHEDULED CHALLENGES CRON END ===\n');

    return res.status(200).json({
      success: true,
      message: `Processed ${results.length} schedules`,
      summary: {
        total: results.length,
        successful,
        failed
      },
      results,
      duration
    });

  } catch (error) {
    console.error('üö® Cron job error:', error);
    console.log('‚è∞ === SCHEDULED CHALLENGES CRON END (ERROR) ===\n');
    return handleAPIError(res, error);
  }
}

/**
 * Process a single scheduled challenge
 */
async function processSchedule(schedule) {
  const scheduleId = schedule.id;
  const scheduledFor = new Date(schedule.scheduled_time);
  const delay = Date.now() - scheduledFor.getTime();
  
  console.log(`\nüéØ Processing schedule #${scheduleId}:`);
  console.log(`    Room: ${schedule.room_data?.name}`);
  console.log(`    Scheduled for: ${scheduledFor.toISOString()}`);
  console.log(`    Delay: ${Math.round(delay / 1000)}s`);
  console.log(`    Has ruleset config: ${!!schedule.ruleset_config}`);  // NEW: Log ruleset config

  try {
    // Check if already being processed (race condition protection)
    const { data: current } = await supabaseAdmin
      .from('scheduled_challenges')
      .select('status')
      .eq('id', scheduleId)
      .single();

    if (current?.status !== 'pending') {
      console.log(`‚ö†Ô∏è Schedule #${scheduleId} already processed (status: ${current?.status})`);
      return {
        success: false,
        scheduleId,
        error: 'Already processed',
        skipped: true
      };
    }

    // Step 1: Get user's token (NEW WORKFLOW vs LEGACY)
    console.log('üîê Step 1: Retrieving user token...');
    
    let tokenString;
    let tokenSource;
    
    // Check if schedule has embedded encrypted token (legacy)
    if (schedule.encrypted_token) {
      console.log('    Using legacy embedded token');
      tokenString = decryptToken(schedule.encrypted_token);
      tokenSource = 'embedded';
    } else {
      // NEW: Fetch from user_osu_tokens table
      console.log(`    Fetching stored token for osu_id: ${schedule.osu_id}`);
      
      const { data: userToken, error: tokenError } = await supabaseAdmin
        .from('user_osu_tokens')
        .select('encrypted_token')
        .eq('osu_id', schedule.osu_id)
        .single();

      if (tokenError || !userToken) {
        console.error('‚ùå No stored token found for user');
        
        await supabaseAdmin
          .from('scheduled_challenges')
          .update({
            status: 'failed',
            error_message: 'No stored token found for user. User must set token via POST /api/admin/user-token',
            executed_at: new Date().toISOString()
          })
          .eq('id', scheduleId);

        return {
          success: false,
          scheduleId,
          error: 'No stored token found'
        };
      }

      tokenString = decryptToken(userToken.encrypted_token);
      tokenSource = 'stored';
      console.log('‚úÖ Retrieved stored token');
    }

    const { accessToken: originalAccessToken, refreshToken, expiresAt } = parseToken(tokenString);
    
    console.log(`    Token source: ${tokenSource}`);
    console.log(`    Token expires: ${expiresAt.toISOString()}`);
    console.log(`    Token masked: ${maskToken(tokenString)}`);

    let accessToken = originalAccessToken;
    let newRefreshToken = refreshToken;
    let tokenRefreshed = false;

    // Step 2: Refresh token if needed
    if (isTokenExpired(tokenString, 300)) { // 5 min buffer
      console.log('üîÑ Token expired or expiring soon, refreshing...');
      
      try {
        const newTokens = await trackedOsuAPI.refreshUserToken(refreshToken);
        accessToken = newTokens.access_token;
        newRefreshToken = newTokens.refresh_token;
        tokenRefreshed = true;

        // Calculate new expiry (convert seconds to timestamp)
        const newExpiresAt = Math.floor(Date.now() / 1000) + newTokens.expires_in;
        const newTokenString = createTokenString(accessToken, newExpiresAt, newRefreshToken);
        const newEncryptedToken = encryptToken(newTokenString);

        // Update token in appropriate location
        if (tokenSource === 'embedded') {
          // Legacy: update in scheduled_challenges table
          await supabaseAdmin
            .from('scheduled_challenges')
            .update({ encrypted_token: newEncryptedToken })
            .eq('id', scheduleId);
          
          console.log('‚úÖ Token refreshed and updated in schedule (legacy)');
        } else {
          // NEW: update in user_osu_tokens table
          await supabaseAdmin
            .from('user_osu_tokens')
            .update({ 
              encrypted_token: newEncryptedToken,
              updated_at: new Date().toISOString()
            })
            .eq('osu_id', schedule.osu_id);
          
          console.log('‚úÖ Token refreshed and updated in user token storage');
        }

      } catch (refreshError) {
        console.error('‚ùå Token refresh failed:', refreshError.message);
        
        await supabaseAdmin
          .from('scheduled_challenges')
          .update({
            status: 'failed',
            error_message: `Token refresh failed: ${refreshError.message}`,
            retry_count: schedule.retry_count + 1,
            executed_at: new Date().toISOString()
          })
          .eq('id', scheduleId);

        return {
          success: false,
          scheduleId,
          error: 'Token refresh failed',
          details: refreshError.message
        };
      }
    } else {
      console.log('‚úÖ Token is still valid');
    }

    // Step 3: Verify user is still admin
    console.log('üë§ Step 3: Verifying admin status...');
    const { data: user, error: userError } = await supabaseAdmin
      .from('users')
      .select('id, osu_id, username, admin')
      .eq('osu_id', schedule.osu_id)
      .single();

    if (userError || !user) {
      console.log('‚ùå User not found');
      
      await supabaseAdmin
        .from('scheduled_challenges')
        .update({
          status: 'failed',
          error_message: 'User not found',
          executed_at: new Date().toISOString()
        })
        .eq('id', scheduleId);

      return {
        success: false,
        scheduleId,
        error: 'User not found'
      };
    }

    if (!user.admin) {
      console.log('‚ùå User no longer has admin privileges');
      
      await supabaseAdmin
        .from('scheduled_challenges')
        .update({
          status: 'failed',
          error_message: 'User no longer has admin privileges',
          executed_at: new Date().toISOString()
        })
        .eq('id', scheduleId);

      return {
        success: false,
        scheduleId,
        error: 'User not admin'
      };
    }

    console.log(`‚úÖ User ${user.username} is still an admin`);

    // Step 4: Create the room with retry logic
    console.log('üéÆ Step 4: Creating multiplayer room...');
    
    // Clean room_data: remove AT from allowed mods to avoid invalid mod errors
    const cleanedRoomData = {
      ...schedule.room_data,
      playlist: schedule.room_data.playlist?.map(item => {
        if (item.allowed_mods && item.allowed_mods.length > 0) {
          const filteredMods = item.allowed_mods.filter(mod => mod.acronym !== 'AT');
          const removedCount = item.allowed_mods.length - filteredMods.length;
          if (removedCount > 0) {
            console.log(`    Removed AT mod from playlist item ${item.id || 0}`);
          }
          return { ...item, allowed_mods: filteredMods };
        }
        return item;
      })
    };
    
    let room = null;
    let lastError = null;
    const maxRetries = 3;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`    Attempt ${attempt}/${maxRetries}...`);
        
        room = await trackedOsuAPI.createRoomWithUserToken(
          cleanedRoomData,
          accessToken
        );

        console.log(`‚úÖ Room created successfully: ${room.id}`);
        break;

      } catch (createError) {
        lastError = createError;
        console.error(`‚ùå Attempt ${attempt} failed:`, createError.message);

        if (attempt < maxRetries) {
          const delay = Math.pow(2, attempt) * 1000; // 2s, 4s
          console.log(`‚è≥ Waiting ${delay}ms before retry...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    if (!room) {
      console.error(`‚ùå Failed to create room after ${maxRetries} attempts`);
      
      await supabaseAdmin
        .from('scheduled_challenges')
        .update({
          status: 'failed',
          error_message: `Room creation failed: ${lastError?.message || 'Unknown error'}`,
          retry_count: schedule.retry_count + 1,
          executed_at: new Date().toISOString()
        })
        .eq('id', scheduleId);

      return {
        success: false,
        scheduleId,
        error: 'Room creation failed',
        details: lastError?.message,
        attempts: maxRetries
      };
    }

    // Step 5: Send chat messages (if any)
    let chatSent = true;
    if (schedule.chat_messages && schedule.chat_messages.length > 0) {
      console.log('üí¨ Step 5: Sending chat messages...');
      
      try {
        await trackedOsuAPI.sendChatToRoom(
          room.id,
          schedule.osu_id,
          schedule.chat_messages,
          accessToken
        );
        console.log('‚úÖ Chat messages sent successfully');
      } catch (chatError) {
        console.error('‚ùå Failed to send chat messages:', chatError.message);
        chatSent = false;
        // Don't fail the whole operation - room was created successfully
      }
    } else {
      console.log('‚ÑπÔ∏è No chat messages to send');
    }

    // Step 5.5: Immediately add to tracker (Call update-challenge logic)
    console.log('üìù Step 5.5: Initializing tracker for new room...');
    let trackerInitialized = false;
    let challengeId = null;
    try {
      const trackerResult = await triggerImmediateUpdate(room.id);
      trackerInitialized = true;
      // Extract the challenge ID from the tracker result if available
      challengeId = trackerResult?.challenge?.id || null;
      console.log('‚úÖ Tracker initialized successfully', challengeId ? `(Challenge ID: ${challengeId})` : '');
    } catch (trackError) {
      console.error('‚ö†Ô∏è Failed to initialize tracker (non-fatal):', trackError.message);
      // We log but don't fail, as the room exists on osu! now
    }

    let rulesetApplied = false;
    if (schedule.ruleset_config && challengeId) {
      console.log('üéØ Step 5.6: Applying ruleset configuration...');
      
      try {
        rulesetApplied = await applyRulesetConfig(challengeId, schedule.ruleset_config);
        if (rulesetApplied) {
          console.log('‚úÖ Ruleset configuration applied successfully');
        } else {
          console.log('‚ö†Ô∏è Ruleset configuration could not be applied');
        }
      } catch (rulesetError) {
        console.error('‚ö†Ô∏è Failed to apply ruleset (non-fatal):', rulesetError.message);
        // Don't fail the whole operation - room was created successfully
      }
    } else if (schedule.ruleset_config && !challengeId) {
      console.log('‚ö†Ô∏è Cannot apply ruleset: Challenge ID not available from tracker');
    } else {
      console.log('‚ÑπÔ∏è No ruleset configuration to apply');
    }

    // Step 6: Mark as completed
    console.log('‚úÖ Step 6: Marking as completed...');
    
    // Build error message if any non-fatal issues occurred
    let errorMessage = null;
    const issues = [];
    if (!chatSent) issues.push('Chat messages failed');
    if (schedule.ruleset_config && !rulesetApplied) issues.push('Ruleset configuration failed');
    if (issues.length > 0) {
      errorMessage = `${issues.join(', ')} (room created successfully)`;
    }
    
    await supabaseAdmin
      .from('scheduled_challenges')
      .update({
        status: 'completed',
        created_room_id: room.id,
        error_message: errorMessage,
        executed_at: new Date().toISOString()
      })
      .eq('id', scheduleId);

    console.log(`üéâ Schedule #${scheduleId} completed successfully!`);
    console.log(`    Room ID: ${room.id}`);
    console.log(`    Room URL: https://osu.ppy.sh/multiplayer/rooms/${room.id}`);

    return {
      success: true,
      scheduleId,
      roomId: room.id,
      roomName: room.name,
      chatSent,
      trackerInitialized,
      rulesetApplied,
      tokenRefreshed,
      tokenSource,
      delaySeconds: Math.round(delay / 1000)
    };

  } catch (error) {
    console.error(`üö® Error processing schedule #${scheduleId}:`, error);
    
    // Try to mark as failed
    try {
      await supabaseAdmin
        .from('scheduled_challenges')
        .update({
          status: 'failed',
          error_message: error.message || 'Unknown error',
          retry_count: schedule.retry_count + 1,
          executed_at: new Date().toISOString()
        })
        .eq('id', scheduleId);
    } catch (updateError) {
      console.error('Failed to update schedule status:', updateError);
    }

    return {
      success: false,
      scheduleId,
      error: error.message || 'Unknown error'
    };
  }
}

// Helper: Reuse the update-challenge logic via mock request
// This ensures the room is added to the DB with all correct relations (season, scores, etc)
async function triggerImmediateUpdate(roomId) {
  // Dynamic import to allow running in cron context
  const updateChallengeModule = await import('../update-challenge');
  const updateHandler = updateChallengeModule.default;
  
  const mockReq = {
    method: 'POST',
    body: { roomId: parseInt(roomId) },
    headers: { 'x-internal-call': 'true' }
  };
  
  let responseData = null;
  let responseStatus = 200;
  
  const mockRes = {
    status: (code) => {
      responseStatus = code;
      return mockRes;
    },
    json: (data) => {
      responseData = data;
      return mockRes;
    },
    setHeader: () => mockRes
  };
  
  await updateHandler(mockReq, mockRes);
  
  if (responseStatus >= 400) {
    throw new Error(responseData?.error || 'Update handler returned error status');
  }
  
  return responseData;
}

/**
 * @param {number} challengeId - The challenge ID to apply ruleset to
 * @param {Object} rulesetConfig - The ruleset configuration
 * @returns {boolean} - True if successfully applied
 */
async function applyRulesetConfig(challengeId, rulesetConfig) {
  if (!rulesetConfig || !rulesetConfig.required_mods || rulesetConfig.required_mods.length === 0) {
    console.log('    No valid ruleset config to apply');
    return false;
  }

  try {
    // Default to 'at_least' if not specified (matching Change 1)
    const matchType = rulesetConfig.ruleset_match_type || 'at_least';
    
    console.log(`    Applying ruleset: ${matchType} with ${rulesetConfig.required_mods.length} mod(s)`);
    
    // Update the challenge with ruleset configuration
    const { data: updatedChallenge, error: updateError } = await supabaseAdmin
      .from('challenges')
      .update({
        has_ruleset: true,
        required_mods: rulesetConfig.required_mods,
        ruleset_match_type: matchType,
        updated_at: new Date().toISOString()
      })
      .eq('id', challengeId)
      .select('id, room_id')
      .single();

    if (updateError) {
      console.error('    Failed to update challenge with ruleset:', updateError);
      return false;
    }

    console.log(`    Ruleset applied to challenge ${challengeId} (room ${updatedChallenge.room_id})`);

    // Calculate the ruleset winner
    try {
      const { data: winnerResult, error: winnerError } = await supabaseAdmin
        .rpc('update_challenge_ruleset_winner', { challenge_id_param: challengeId });

      if (winnerError) {
        console.warn('    Winner calculation warning:', winnerError.message);
      } else {
        console.log('    Ruleset winner calculated');
      }
    } catch (winnerCalcError) {
      console.warn('    Winner calculation error (non-fatal):', winnerCalcError.message);
    }

    return true;

  } catch (error) {
    console.error('    Error applying ruleset config:', error);
    return false;
  }
}


================================================
FILE: frontend/pages/api/cron/status.js
================================================
import { supabase } from '../../../lib/supabase';
import { handleAPIResponse, handleAPIError } from '../../../lib/api-utils';

export default async function handler(req, res) {
  try {
    if (req.method !== 'GET') {
      return res.status(405).json({ error: 'Method not allowed' });
    }

    // Get recent cron job executions from logs or create a simple status check
    const { data: recentChallenges, error } = await supabase
      .from('challenges')
      .select('room_id, updated_at, is_active')
      .eq('is_active', true)
      .order('updated_at', { ascending: false })
      .limit(10);

    if (error) throw error;

    const now = Date.now();
    const staleThreshold = 20 * 60 * 1000; // 20 minutes
    
    const challengeStatus = recentChallenges.map(challenge => {
      const lastUpdate = new Date(challenge.updated_at).getTime();
      const timeSinceUpdate = now - lastUpdate;
      
      return {
        room_id: challenge.room_id,
        last_updated: challenge.updated_at,
        minutes_since_update: Math.floor(timeSinceUpdate / 60000),
        is_stale: timeSinceUpdate > staleThreshold
      };
    });

    const staleChallenges = challengeStatus.filter(c => c.is_stale).length;
    const avgMinutesSinceUpdate = challengeStatus.length > 0 
      ? Math.floor(challengeStatus.reduce((sum, c) => sum + c.minutes_since_update, 0) / challengeStatus.length)
      : 0;

    return handleAPIResponse(res, {
      cron_status: 'operational',
      total_active_challenges: challengeStatus.length,
      stale_challenges: staleChallenges,
      avg_minutes_since_update: avgMinutesSinceUpdate,
      last_check: new Date().toISOString(),
      challenges: challengeStatus
    });

  } catch (error) {
    console.error('Cron status error:', error);
    return handleAPIError(res, error);
  }
}



================================================
FILE: frontend/pages/api/cron/update-challenges.js
================================================
import { supabaseAdmin } from '../../../lib/supabase-admin';
import { handleAPIResponse, handleAPIError } from '../../../lib/api-utils';
import apiTracker from '../../../lib/api-tracker';
import { syncConfig, isStale } from '../../../lib/sync-config';
import { invalidateChallengeCache } from '../../../lib/memory-cache';
import pLimit from 'p-limit';

export default async function handler(req, res) {
  const startTime = Date.now();
  
  try {
    // 1. VERIFY CRON AUTHENTICATION
    if (req.method !== 'GET') {
      return res.status(405).json({ error: 'Method not allowed' });
    }

    // Support multiple authentication methods for flexibility
    const authHeader = req.headers.authorization;
    const cronSecret = req.headers['x-cron-secret'];
    
    // Check both Bearer token and custom header
    const isAuthorized = 
      (authHeader && authHeader === `Bearer ${syncConfig.CRON_SECRET}`) ||
      (cronSecret && cronSecret === process.env.CRON_SECRET);

    if (!isAuthorized) {
      console.warn('üö® Unauthorized cron request attempt', {
        hasAuth: !!authHeader,
        hasCronSecret: !!cronSecret,
        ip: req.headers['x-forwarded-for'] || req.socket.remoteAddress,
        userAgent: req.headers['user-agent']
      });
      return res.status(401).json({ error: 'Unauthorized' });
    }

    console.log('‚è∞ CRON: Starting automated challenge updates (5-min cycle)');

    // 2. CHECK API LIMITS
    const limitStatus = apiTracker.checkLimits();
    if (limitStatus === 'critical') {
      console.warn('üö® CRON: API limits critical, skipping update cycle');
      return res.status(429).json({
        success: false,
        reason: 'api_limits_critical',
        message: 'API usage too high, skipping this cycle'
      });
    }

    // 3. GET ALL ACTIVE CHALLENGES
    const { data: activeChallenges, error: fetchError } = await supabaseAdmin
      .from('challenges')
      .select('id, room_id, name, updated_at, is_active')
      .eq('is_active', true)
      .order('updated_at', { ascending: true }); // Oldest first

    if (fetchError) {
      throw new Error(`Failed to fetch challenges: ${fetchError.message}`);
    }

    if (!activeChallenges || activeChallenges.length === 0) {
      console.log('üìã CRON: No active challenges found');
      return handleAPIResponse(res, {
        success: true,
        challenges_checked: 0,
        challenges_updated: 0,
        message: 'No active challenges'
      });
    }

    console.log(`üìã CRON: Found ${activeChallenges.length} active challenges`);

    // 4. FILTER STALE CHALLENGES (updated more than 5 min ago)
    const staleChallenges = activeChallenges.filter(challenge => 
      isStale(challenge.updated_at)
    );

    if (staleChallenges.length === 0) {
      console.log('‚úÖ CRON: All challenges are up to date');
      return handleAPIResponse(res, {
        success: true,
        challenges_checked: activeChallenges.length,
        challenges_updated: 0,
        message: 'All challenges are fresh'
      });
    }

    console.log(`üîÑ CRON: ${staleChallenges.length} challenges need updating`);

    // 5. UPDATE CHALLENGES IN PARALLEL (with concurrency limit)
    const limit = pLimit(syncConfig.MAX_CONCURRENT_UPDATES);
    const updateResults = [];

    const updatePromises = staleChallenges.map(challenge =>
      limit(async () => {
        try {
          console.log(`üîÑ CRON: Updating challenge ${challenge.room_id}...`);
          
          // Call the update-challenge endpoint
          const updateResult = await updateChallenge(challenge.room_id);
          
          // Invalidate cache after successful update
          if (updateResult.success) {
            invalidateChallengeCache(challenge.room_id);
          }
          
          return {
            room_id: challenge.room_id,
            success: true,
            ...updateResult
          };
        } catch (error) {
          console.error(`‚ùå CRON: Failed to update ${challenge.room_id}:`, error.message);
          return {
            room_id: challenge.room_id,
            success: false,
            error: error.message
          };
        }
      })
    );

    const results = await Promise.allSettled(updatePromises);
    
    results.forEach((result, index) => {
      if (result.status === 'fulfilled') {
        updateResults.push(result.value);
      } else {
        updateResults.push({
          room_id: staleChallenges[index].room_id,
          success: false,
          error: result.reason?.message || 'Unknown error'
        });
      }
    });

    // 6. SUMMARIZE RESULTS
    const successCount = updateResults.filter(r => r.success).length;
    const failureCount = updateResults.filter(r => !r.success).length;
    const totalTime = Date.now() - startTime;

    console.log(`‚úÖ CRON: Completed in ${totalTime}ms - ${successCount} successful, ${failureCount} failed`);

    return handleAPIResponse(res, {
      success: true,
      challenges_checked: activeChallenges.length,
      challenges_updated: staleChallenges.length,
      successful_updates: successCount,
      failed_updates: failureCount,
      execution_time_ms: totalTime,
      api_usage: apiTracker.getUsageStats(),
      results: updateResults
    });

  } catch (error) {
    console.error('‚ùå CRON: Fatal error:', error);
    return handleAPIError(res, error);
  }
}

// Helper function to update a single challenge
async function updateChallenge(roomId) {
  // Import and call the update logic directly
  const updateChallengeModule = await import('../update-challenge');
  const updateHandler = updateChallengeModule.default;
  
  // Create mock request/response
  const mockReq = {
    method: 'POST',
    body: { roomId: parseInt(roomId) }
  };
  
  let responseData = null;
  let responseStatus = 200;
  
  const mockRes = {
    status: (code) => {
      responseStatus = code;
      return mockRes;
    },
    json: (data) => {
      responseData = data;
      return mockRes;
    },
    setHeader: () => mockRes
  };
  
  await updateHandler(mockReq, mockRes);
  
  if (responseStatus >= 400) {
    throw new Error(responseData?.error || 'Update failed');
  }
  
  return {
    success: true,
    data: responseData
  };
}


================================================
FILE: frontend/pages/api/emergency/invalidate-sessions.js
================================================
export default function handler(req, res) {
  console.log('üö® EMERGENCY: Invalidating all sessions');
  console.log('üïê Timestamp:', new Date().toISOString());
  console.log('üåê IP:', req.headers['x-forwarded-for'] || req.connection.remoteAddress);
  
  // Get environment info
  const isProduction = process.env.NODE_ENV === 'production';
  
  // Clear ALL authentication cookies with maximum compatibility
  const clearCookies = [
    // Main session cookie
    `osu_session=; Path=/; HttpOnly; SameSite=Lax; Max-Age=0${isProduction ? '; Secure' : ''}`,
    
    // OAuth state cookies  
    `osu_auth_state=; Path=/; HttpOnly; SameSite=None; Max-Age=0${isProduction ? '; Secure' : ''}`,
    `osu_auth_state_backup=; Path=/; HttpOnly; SameSite=Lax; Max-Age=0${isProduction ? '; Secure' : ''}`,
    
    // Legacy cookies (in case old ones exist)
    `session=; Path=/; HttpOnly; SameSite=Lax; Max-Age=0${isProduction ? '; Secure' : ''}`,
    `auth_token=; Path=/; HttpOnly; SameSite=Lax; Max-Age=0${isProduction ? '; Secure' : ''}`,
    
    // Clear any potential subdomain cookies
    `osu_session=; Path=/; Domain=.challengersnexus.com; HttpOnly; SameSite=Lax; Max-Age=0${isProduction ? '; Secure' : ''}`,
  ];
  
  console.log('üßπ Clearing cookies:', clearCookies);
  
  // Set response headers to clear cookies
  res.setHeader('Set-Cookie', clearCookies);
  
  // Prevent caching of this response
  res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
  res.setHeader('Pragma', 'no-cache');
  res.setHeader('Expires', '0');
  
  // Return success response
  res.status(200).json({ 
    success: true,
    message: 'All user sessions have been invalidated',
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV,
    cookiesCleared: clearCookies.length
  });
  
  console.log('‚úÖ Emergency session invalidation completed');
}


================================================
FILE: frontend/pages/api/partners/[id].js
================================================
import { supabase } from '../../../lib/supabase';
import { supabaseAdmin } from '../../../lib/supabase-admin';
import { withAdminAuth } from '../../../lib/auth-middleware';
import { handleAPIResponse, handleAPIError, validateRequest } from '../../../lib/api-utils';

async function handler(req, res) {
  const { id } = req.query;

  if (!id || isNaN(parseInt(id))) {
    return handleAPIError(res, new Error('Invalid partner ID'), { status: 400 });
  }

  switch (req.method) {
    case 'GET':
      return handleGetPartner(req, res, parseInt(id));
    case 'PUT':
      return withAdminAuth(handleUpdatePartner)(req, res, parseInt(id));
    case 'DELETE':
      return withAdminAuth(handleDeletePartner)(req, res, parseInt(id));
    default:
      return handleAPIError(res, new Error('Method not allowed'), { status: 405 });
  }
}

async function handleGetPartner(req, res, partnerId) {
  try {
    const { data: partner, error } = await supabase
      .from('partners')
      .select('*')
      .eq('id', partnerId)
      .single();

    if (error) {
      if (error.code === 'PGRST116') {
        return handleAPIError(res, new Error('Partner not found'), { status: 404 });
      }
      throw error;
    }

    return handleAPIResponse(res, { partner }, {
      cache: true,
      cacheTime: 900,
      enableETag: true,
      req
    });

  } catch (error) {
    console.error('Get partner error:', error);
    return handleAPIError(res, error);
  }
}

async function handleUpdatePartner(req, res, partnerId) {
  try {
    validateRequest(req, {
      method: 'PUT',
      body: {
        name: { type: 'string', maxLength: 255 },
        icon_url: { type: 'string' },
        link_url: { type: 'string' },
        description: { type: 'string', maxLength: 500 },
        is_active: { type: 'boolean' },
        display_order: { type: 'number', min: 0 }
      }
    });

    const updates = {};
    const allowedFields = ['name', 'icon_url', 'link_url', 'description', 'is_active', 'display_order'];
    
    // Only include fields that were provided
    allowedFields.forEach(field => {
      if (req.body[field] !== undefined) {
        updates[field] = req.body[field];
      }
    });

    if (Object.keys(updates).length === 0) {
      throw new Error('No valid fields to update');
    }

    // Validate URLs if provided
    if (updates.icon_url) {
      try {
        new URL(updates.icon_url);
      } catch {
        throw new Error('Invalid icon_url format');
      }
    }

    if (updates.link_url) {
      try {
        new URL(updates.link_url);
      } catch {
        throw new Error('Invalid link_url format');
      }
    }

    // Check if partner exists
    const { data: existing, error: checkError } = await supabase
      .from('partners')
      .select('id, name')
      .eq('id', partnerId)
      .single();

    if (checkError || !existing) {
      return handleAPIError(res, new Error('Partner not found'), { status: 404 });
    }

    // Check for duplicate name if updating name
    if (updates.name && updates.name !== existing.name) {
      const { data: duplicate } = await supabase
        .from('partners')
        .select('id')
        .eq('name', updates.name)
        .neq('id', partnerId)
        .single();

      if (duplicate) {
        throw new Error('A partner with this name already exists');
      }
    }

    // Update partner
    updates.updated_at = new Date().toISOString();

    const { data: partner, error: updateError } = await supabaseAdmin
      .from('partners')
      .update(updates)
      .eq('id', partnerId)
      .select()
      .single();

    if (updateError) {
      throw updateError;
    }

    console.log(`‚úÖ Updated partner ${partnerId}: ${Object.keys(updates).join(', ')}`);

    return handleAPIResponse(res, {
      partner,
      message: 'Partner updated successfully'
    });

  } catch (error) {
    console.error('Update partner error:', error);
    return handleAPIError(res, error);
  }
}

async function handleDeletePartner(req, res, partnerId) {
  try {
    // Check if partner exists
    const { data: existing } = await supabase
      .from('partners')
      .select('id, name')
      .eq('id', partnerId)
      .single();

    if (!existing) {
      return handleAPIError(res, new Error('Partner not found'), { status: 404 });
    }

    // Delete partner
    const { error: deleteError } = await supabaseAdmin
      .from('partners')
      .delete()
      .eq('id', partnerId);

    if (deleteError) {
      throw deleteError;
    }

    console.log(`‚úÖ Deleted partner ${partnerId} (${existing.name})`);

    return handleAPIResponse(res, {
      message: 'Partner deleted successfully',
      deleted: {
        id: partnerId,
        name: existing.name
      }
    });

  } catch (error) {
    console.error('Delete partner error:', error);
    return handleAPIError(res, error);
  }
}

export default handler;


================================================
FILE: frontend/pages/api/partners/index.js
================================================
import { supabase } from '../../../lib/supabase';
import { supabaseAdmin } from '../../../lib/supabase-admin';
import { withAdminAuth } from '../../../lib/auth-middleware';
import { handleAPIResponse, handleAPIError, validateRequest } from '../../../lib/api-utils';
import { memoryCache, createCacheKey, CACHE_DURATIONS } from '../../../lib/memory-cache';
import { generateETag, checkETag } from '../../../lib/api-utils';
import { invalidateAfterUpdate } from '../../../lib/cache-invalidation';

async function handler(req, res) {
  if (req.method === 'GET') {
    return handleGetPartners(req, res);
  } else if (req.method === 'POST') {
    return withAdminAuth(handleCreatePartner)(req, res);
  } else if (req.method === 'PUT') {
    return withAdminAuth(handleUpdatePartner)(req, res);
  } else {
    return handleAPIError(res, new Error('Method not allowed'), { status: 405 });
  }
}

async function handleGetPartners(req, res) {
  try {
    validateRequest(req, {
      method: 'GET',
      query: {
        active_only: { type: 'string', enum: ['true', 'false'] }
      }
    });

    const { active_only = 'true' } = req.query;
    const cacheKey = createCacheKey('partners_list', 'all', { active_only });

    // TRY MEMORY CACHE FIRST
    const cached = memoryCache.get(cacheKey);
    if (cached) {
      console.log('ü§ù Serving partners from memory cache');
      const etag = generateETag(cached);
      if (checkETag(req, etag)) {
        return res.status(304).end();
      }
      
      return handleAPIResponse(res, cached, { 
        cache: true, 
        cacheTime: 1800,
        enableETag: true 
      });
    }

    console.log(`üìã Fetching partners list (active_only: ${active_only})`);

    let query = supabase
      .from('partners')
      .select('*');

    // Apply filters
    if (active_only === 'true') {
      query = query.eq('is_active', true);
    }

    // Order by display_order, then by created_at
    query = query.order('display_order', { ascending: true })
                 .order('created_at', { ascending: true });

    const { data, error } = await query;

    if (error) {
      throw error;
    }

    const responseData = {
      partners: data || [],
      count: data?.length || 0
    };

    // Cache for 30 minutes
    memoryCache.set(cacheKey, responseData, CACHE_DURATIONS.PARTNERS);

    console.log(`‚úÖ Fetched ${data?.length || 0} partners`);

    return handleAPIResponse(res, responseData, { 
      cache: true, 
      cacheTime: 1800,
      enableETag: true 
    });

  } catch (error) {
    console.error('Get partners error:', error);
    return handleAPIError(res, error);
  }
}

async function handleCreatePartner(req, res) {
  try {
    validateRequest(req, {
      method: 'POST',
      body: {
        name: { required: true, type: 'string', maxLength: 255 },
        icon_url: { required: true, type: 'string' },
        description: { type: 'string', maxLength: 500 },
        is_active: { type: 'boolean' },
        display_order: { type: 'number', min: 0 }
      }
    });

    const { name, icon_url, description, is_active = true, display_order = 0 } = req.body;

    // Validate URLs
    try {
      new URL(icon_url);
    } catch (urlError) {
      throw new Error('Invalid URL format for icon_url');
    }

    // Check for duplicate name
    const { data: existing } = await supabase
      .from('partners')
      .select('id')
      .eq('name', name)
      .single();

    if (existing) {
      throw new Error('A partner with this name already exists');
    }

    // Create partner
    const { data: partner, error: createError } = await supabaseAdmin
      .from('partners')
      .insert({
        name,
        icon_url,
        description: description || null,
        is_active,
        display_order,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .select()
      .single();

    if (createError) {
      throw createError;
    }

    console.log(`‚úÖ Created new partner: ${name} (ID: ${partner.id})`);

    // INVALIDATE PARTNERS CACHE AFTER CREATION
    invalidateAfterUpdate('partner');

    return handleAPIResponse(res, {
      partner,
      message: 'Partner created successfully'
    }, { status: 201 });

  } catch (error) {
    console.error('Create partner error:', error);
    return handleAPIError(res, error);
  }
}

async function handleUpdatePartner(req, res) {
  try {
    validateRequest(req, {
      method: 'PUT',
      body: {
        id: { required: true, type: 'number' },
        name: { type: 'string', maxLength: 255 },
        icon_url: { type: 'string' },
        description: { type: 'string', maxLength: 500 },
        is_active: { type: 'boolean' },
        display_order: { type: 'number', min: 0 }
      }
    });

    const { id: partnerId, ...updateData } = req.body;

    const updates = {};
    const allowedFields = ['name', 'icon_url', 'description', 'is_active', 'display_order'];
    
    // Only include fields that were provided
    allowedFields.forEach(field => {
      if (updateData[field] !== undefined) {
        updates[field] = updateData[field];
      }
    });

    if (Object.keys(updates).length === 0) {
      throw new Error('No valid fields to update');
    }

    // Validate URLs if provided
    if (updates.icon_url) {
      try {
        new URL(updates.icon_url);
      } catch {
        throw new Error('Invalid icon_url format');
      }
    }

    // Check if partner exists
    const { data: existing, error: checkError } = await supabase
      .from('partners')
      .select('id, name')
      .eq('id', partnerId)
      .single();

    if (checkError || !existing) {
      return handleAPIError(res, new Error('Partner not found'), { status: 404 });
    }

    // Check for duplicate name if updating name
    if (updates.name && updates.name !== existing.name) {
      const { data: duplicate } = await supabase
        .from('partners')
        .select('id')
        .eq('name', updates.name)
        .neq('id', partnerId)
        .single();

      if (duplicate) {
        throw new Error('A partner with this name already exists');
      }
    }

    // Update partner
    updates.updated_at = new Date().toISOString();

    const { data: partner, error: updateError } = await supabaseAdmin
      .from('partners')
      .update(updates)
      .eq('id', partnerId)
      .select()
      .single();

    if (updateError) {
      throw updateError;
    }

    console.log(`‚úÖ Updated partner ${partnerId}: ${Object.keys(updates).join(', ')}`);

    return handleAPIResponse(res, {
      partner,
      message: 'Partner updated successfully'
    });

  } catch (error) {
    console.error('Update partner error:', error);
    return handleAPIError(res, error);
  }
}

export default handler;


================================================
FILE: frontend/pages/api/seasons/current.js
================================================
import { supabaseAdmin } from '../../../lib/supabase-admin';
import { seasonUtils } from '../../../lib/seasons';
import { handleAPIResponse, handleAPIError } from '../../../lib/api-utils';
import { memoryCache, createCacheKey, CACHE_DURATIONS } from '../../../lib/memory-cache';
import { generateETag, checkETag } from '../../../lib/api-utils';

async function handler(req, res) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const cacheKey = createCacheKey('current_season', 'current');
    
    // TRY MEMORY CACHE FIRST
    const cached = memoryCache.get(cacheKey);
    if (cached) {
      console.log('üéØ Serving current season from memory cache');
      const etag = generateETag(cached);
      if (checkETag(req, etag)) {
        return res.status(304).end();
      }
      
      return handleAPIResponse(res, cached, { 
        cache: true, 
        cacheTime: 300,
        enableETag: true,
        req // Pass req for ETag handling
      });
    }

    const { data: currentSeason, error } = await supabaseAdmin
      .from('seasons')
      .select('*')
      .eq('is_current', true)
      .single();

    if (error && error.code !== 'PGRST116') { // PGRST116 = no rows returned
      console.error('Error fetching current season:', error);
      return res.status(500).json({ 
        success: false, 
        error: 'Failed to fetch current season' 
      });
    }

    // Check if current season has expired or doesn't exist
    const now = new Date();
    const shouldRotate = !currentSeason || (currentSeason && new Date(currentSeason.end_date) < now);

    let responseData;

    if (shouldRotate) {
      console.log(`üîÑ Season rotation needed: ${currentSeason ? `${currentSeason.name} expired on ${currentSeason.end_date}` : 'No current season found'}`);
      
      // Mark any existing current season as not current
      if (currentSeason) {
        await supabaseAdmin
          .from('seasons')
          .update({ 
            is_current: false, 
            updated_at: new Date().toISOString() 
          })
          .eq('id', currentSeason.id);
        
        console.log(`üìÖ Marked ${currentSeason.name} as inactive`);
      }
      
      // Use utility functions to get the season info and name
      const { year, half } = seasonUtils.getCurrentSeasonInfo(now);
      const dateRange = seasonUtils.getSeasonDateRange(year, half);
      
      // Generate the next season name using the utility function (pass admin instance)
      const seasonName = await seasonUtils.generateSeasonName(now, supabaseAdmin);
      
      // Check if this exact season already exists
      const { data: existingSeason } = await supabaseAdmin
        .from('seasons')
        .select('*')
        .eq('name', seasonName)
        .single();
      
      if (existingSeason) {
        // Season exists but isn't current - make it current
        const { data: updatedSeason, error: updateError } = await supabaseAdmin
          .from('seasons')
          .update({ 
            is_current: true, 
            updated_at: new Date().toISOString() 
          })
          .eq('id', existingSeason.id)
          .select()
          .single();
        
        if (updateError) {
          console.error('Error updating existing season to current:', updateError);
          return res.status(500).json({ 
            success: false, 
            error: 'Failed to update existing season to current' 
          });
        }
        
        console.log(`‚úÖ Reactivated existing season: ${seasonName}`);
        responseData = {
          season: updatedSeason,
          rotated: true,
          message: `Season rotated to existing ${seasonName}`
        };
        
      } else {
        // Create brand new season
        const { data: newSeason, error: createError } = await supabaseAdmin
          .from('seasons')
          .insert({
            name: seasonName,
            start_date: dateRange.start_date,
            end_date: dateRange.end_date,
            is_current: true,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          })
          .select()
          .single();

        if (createError) {
          console.error('Error creating new season:', createError);
          return res.status(500).json({ 
            success: false, 
            error: 'Failed to create new season' 
          });
        }

        const seasonNumber = seasonUtils.getSeasonNumber(seasonName);
        console.log(`‚úÖ Created new season: ${seasonName} (${dateRange.start_date} to ${dateRange.end_date})`);
        
        responseData = {
          season: newSeason,
          rotated: true,
          season_number: seasonNumber,
          message: `Season rotated to new ${seasonName}`,
        };
      }
    } else {
      // Current season is still valid - return it
      const seasonEnd = new Date(currentSeason.end_date);
      const daysUntilExpiry = Math.ceil((seasonEnd - now) / (1000 * 60 * 60 * 24));
      
      // Extract season number using utility function
      const seasonNumber = seasonUtils.getSeasonNumber(currentSeason.name);
      
      console.log(`‚úÖ Current season ${currentSeason.name} is valid (${daysUntilExpiry} days remaining)`);
      
      responseData = {
        season: currentSeason,
        rotated: false,
        daysUntilExpiry,
        season_number: seasonNumber,
        message: `Current season ${currentSeason.name} is active`
      };
    }

    // Cache for 5 minutes
    memoryCache.set(cacheKey, responseData, CACHE_DURATIONS.SEASONS);

    return handleAPIResponse(res, responseData, { 
      cache: true, 
      cacheTime: 300,
      enableETag: true,
      req // Pass req for ETag handling
    });

  } catch (error) {
    console.error('Current season API error:', error);
    return handleAPIError(res, error);
  }
}

export default handler;


================================================
FILE: frontend/pages/api/seasons/index.js
================================================
import { supabaseAdmin } from '../../../lib/supabase-admin';
import { withAdminAuth } from '../../../lib/auth-middleware';
import { handleAPIResponse, handleAPIError } from '../../../lib/api-utils';

async function handleGetSeasons(req, res) {
  try {
    const { data: seasons, error } = await supabaseAdmin
      .from('seasons')
      .select('*')
      .order('start_date', { ascending: false });

    if (error) {
      console.error('Error fetching seasons:', error);
      return res.status(500).json({ 
        success: false, 
        error: 'Failed to fetch seasons' 
      });
    }

    return handleAPIResponse(res, {
      seasons: seasons || []
    }, {
      cache: true,
      cacheTime: 1800,
      enableETag: true,
      req
    });
  } catch (error) {
    console.error('Seasons fetch error:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Internal server error' 
    });
  }
}

async function handleCreateSeason(req, res) {
  try {
    const { name, start_date, end_date, is_current = false } = req.body;

    if (!name || !start_date || !end_date) {
      return res.status(400).json({
        success: false,
        error: 'Name, start_date, and end_date are required'
      });
    }

    // If this season is set as current, unset all other current seasons
    if (is_current) {
      const { error: updateError } = await supabaseAdmin
        .from('seasons')
        .update({ is_current: false })
        .eq('is_current', true);

      if (updateError) {
        console.error('Error updating current seasons:', updateError);
      }
    }

    const { data: season, error } = await supabaseAdmin
      .from('seasons')
      .insert({
        name,
        start_date,
        end_date,
        is_current,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .select()
      .single();

    if (error) {
      console.error('Error creating season:', error);
      return res.status(500).json({ 
        success: false, 
        error: 'Failed to create season' 
      });
    }

    return handleAPIResponse(res, {
      season,
      message: 'Season created successfully'
    }, { status: 201 });
  } catch (error) {
    console.error('Season creation error:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Internal server error' 
    });
  }
}

async function handler(req, res) {
  if (req.method === 'GET') {
    // Public access for GET requests
    return handleGetSeasons(req, res);
  } else if (req.method === 'POST') {
    // Admin-only for POST requests
    return withAdminAuth(handleCreateSeason)(req, res);
  } else {
    return res.status(405).json({ error: 'Method not allowed' });
  }
}

export default handler;


================================================
FILE: frontend/pages/api/seasons/leaderboard.js
================================================
import { supabaseAdmin } from '../../../lib/supabase-admin';
import { handleAPIResponse, handleAPIError } from '../../../lib/api-utils';
import { memoryCache, createCacheKey, CACHE_DURATIONS } from '../../../lib/memory-cache';
import { generateETag, checkETag } from '../../../lib/api-utils';

async function handler(req, res) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const { 
      seasonId, 
      userId, 
      limit = 50, 
      offset = 0,
      withUserContext = false,
      contextRange = 5 
    } = req.query;

    console.log(`Fetching weighted season leaderboard: seasonId=${seasonId}, userId=${userId}, limit=${limit}, offset=${offset}, withUserContext=${withUserContext}`);

    // CREATE CACHE KEY
    const cacheKey = createCacheKey('leaderboard_weighted', seasonId || 'current', {
      userId: withUserContext === 'true' ? userId : null,
      limit,
      offset,
      withUserContext,
      contextRange
    });

    // TRY CACHE FIRST
    const cached = memoryCache.get(cacheKey);
    if (cached) {
      console.log(`üèÜ Serving weighted leaderboard from memory cache: ${cacheKey}`);
      const etag = generateETag(cached);
      if (checkETag(req, etag)) {
        return res.status(304).end();
      }
      return handleAPIResponse(res, cached, { 
        cache: true, 
        cacheTime: 600,
        enableETag: true,
        req
      });
    }

    let data, error;

    if (withUserContext === 'true' && userId) {
      console.log(`Getting weighted leaderboard with user context for user ${userId}`);
      
      // Get leaderboard with user context using new weighted function
      const { data: leaderboardData, error: leaderboardError } = await supabaseAdmin
        .rpc('get_season_leaderboard_weighted_with_user', {
          user_id_param: parseInt(userId),
          season_id_param: seasonId ? parseInt(seasonId) : null,
          context_range: parseInt(contextRange)
        });

      data = leaderboardData;
      error = leaderboardError;
    } else {
      console.log(`Getting standard weighted season leaderboard with offset ${offset}`);
      
      // Get standard weighted leaderboard with offset support
      const { data: leaderboardData, error: leaderboardError } = await supabaseAdmin
        .rpc('get_season_leaderboard_weighted', {
          season_id_param: seasonId ? parseInt(seasonId) : null,
          limit_count: parseInt(limit),
          offset_count: parseInt(offset)
        });

      data = leaderboardData;
      error = leaderboardError;
    }

    if (error) {
      console.error('Database error fetching weighted season leaderboard:', error);
      return res.status(500).json({ 
        success: false,
        error: 'Failed to fetch season leaderboard',
        details: process.env.NODE_ENV === 'development' ? {
          message: error.message,
          code: error.code,
          details: error.details,
          hint: error.hint
        } : undefined
      });
    }

    // Get user's position if userId is provided (using new weighted function)
    let userPosition = null;
    if (userId) {
      console.log(`Getting weighted position for user ${userId}`);
      
      // Use the weighted leaderboard to find user's position
      const { data: positionData, error: positionError } = await supabaseAdmin
        .rpc('get_season_leaderboard_weighted', {
          season_id_param: seasonId ? parseInt(seasonId) : null,
          limit_count: 10000,
          offset_count: 0
        });

      if (positionError) {
        console.error('Error fetching user weighted position:', positionError);
      } else if (positionData) {
        // Find the user in the results
        const userEntry = positionData.find(entry => entry.out_user_id === parseInt(userId));
        if (userEntry) {
          // FIXED: Use user_rank which is returned by get_season_leaderboard_weighted
          userPosition = {
            user_position: userEntry.user_rank,
            total_score: userEntry.out_total_score,
            average_accuracy: userEntry.out_average_accuracy,
            challenges_participated: userEntry.out_challenges_participated,
            final_weighted_score: userEntry.out_final_weighted_score,
            max_streak: userEntry.out_max_streak,
            score_percentile: userEntry.out_score_percentile,
            accuracy_percentile: userEntry.out_accuracy_percentile,
            streak_percentile: userEntry.out_streak_percentile,
            total_participants: userEntry.out_total_participants,
            percentile: ((userEntry.out_total_participants - userEntry.user_rank + 1) / userEntry.out_total_participants) * 100
          };
        }
      }
    }

    // Get current season info
    const { data: seasonData, error: seasonError } = await supabaseAdmin
      .from('seasons')
      .select('*')
      .eq('is_current', true)
      .single();

    if (seasonError && seasonError.code !== 'PGRST116') {
      console.error('Error fetching season info:', seasonError);
    }

    const currentSeason = seasonError ? null : seasonData;

    // Transform data to match frontend expectations
    // FIXED: Use user_rank for standard function, out_rank_position for context function
    const transformedData = data ? data.map(entry => {
      // The rank field name differs between the two RPC functions:
      // - get_season_leaderboard_weighted returns: user_rank
      // - get_season_leaderboard_weighted_with_user returns: out_rank_position
      const rankPosition = entry.user_rank || entry.out_rank_position;
      
      return {
        user_id: entry.out_user_id,
        username: entry.out_username,
        avatar_url: entry.out_avatar_url,
        country: entry.out_country,
        total_score: entry.out_total_score,
        average_accuracy: entry.out_average_accuracy,
        max_streak: entry.out_max_streak,
        challenges_participated: entry.out_challenges_participated,
        final_weighted_score: entry.out_final_weighted_score,
        score_percentile: entry.out_score_percentile,
        accuracy_percentile: entry.out_accuracy_percentile,
        streak_percentile: entry.out_streak_percentile,
        user_position: rankPosition,
        rank_position: rankPosition,
        position: rankPosition,
        total_participants: entry.out_total_participants,
        is_target_user: entry.out_is_target_user,
        percentile: entry.out_total_participants > 0 ? 
          ((entry.out_total_participants - rankPosition + 1) / entry.out_total_participants) * 100 : 0
      };
    }) : [];

    console.log(`Weighted season leaderboard fetched: ${transformedData?.length || 0} entries, user position: ${userPosition ? 'found' : 'none'}`);

    // Determine if there are more records available
    const hasMore = transformedData && transformedData.length === parseInt(limit);

    // PREPARE RESPONSE DATA
    const responseData = {
      leaderboard: transformedData || [],
      userPosition,
      currentSeason,
      hasMore,
      meta: {
        seasonId: seasonId || currentSeason?.id,
        limit: parseInt(limit),
        offset: parseInt(offset),
        returned: transformedData?.length || 0,
        withUserContext: withUserContext === 'true',
        weighted: true
      }
    };

    // Cache for 10 minutes
    memoryCache.set(cacheKey, responseData, CACHE_DURATIONS.LEADERBOARD);

    return handleAPIResponse(res, responseData, { 
      cache: true, 
      cacheTime: 600,
      enableETag: true,
      req
    });

  } catch (error) {
    console.error('Weighted season leaderboard API error:', error);
    return handleAPIError(res, error);
  }
}

export default handler;


================================================
FILE: frontend/pages/api/settings/index.js
================================================
import { withAuth } from '../../../lib/auth-middleware';
import { supabaseAdmin } from '../../../lib/supabase-admin';
import { settingsQueries, donationQueries } from '../../../lib/supabase';
import { handleAPIResponse, handleAPIError } from '../../../lib/api-utils';

async function handler(req, res) {
  const { user } = req;

  if (req.method === 'GET') {
    try {
      // Get user settings
      const settings = await settingsQueries.getUserSettings(user.id);
      
      // Get user's total donations for donor perks
      const totalDonations = await donationQueries.getUserDonationTotal(user.id);
      
      // Get available backgrounds based on donation total (updated function)
      const availableBackgrounds = await settingsQueries.getAvailableBackgrounds(user.id, totalDonations);
      
      return handleAPIResponse(res, {
        settings,
        donorStatus: {
          totalDonations,
          isDonor: totalDonations > 0,
          // Updated tier calculation: supporter at any amount, premium at $10+
          tier: totalDonations >= 10 ? 'premium' : totalDonations >= 0.01 ? 'supporter' : null
        },
        availableBackgrounds
      }, {
        cache: true,
        cacheTime: 300, // 5 minutes
        enableETag: true,
        req
      });
    } catch (error) {
      console.error('Error fetching settings:', error);
      return handleAPIError(res, error);
    }
  }

  if (req.method === 'PUT') {
    try {
      const { settings } = req.body;
      
      if (!settings || typeof settings !== 'object') {
        return res.status(400).json({
          success: false,
          error: { message: 'Invalid settings data' }
        });
      }

      // Validate settings
      const validatedSettings = validateSettings(settings);
      
      // Check background access if specified (updated field name)
      if (validatedSettings.background_id) {
        const totalDonations = await donationQueries.getUserDonationTotal(user.id);
        const background = await settingsQueries.getBackground(validatedSettings.background_id);
        
        if (!background) {
          return res.status(404).json({
            success: false,
            error: { message: 'Background not found' }
          });
        }

        // Check access based on background category and user donation total
        if (background.category === 'donor' && totalDonations < background.min_donation_total) {
          return res.status(403).json({
            success: false,
            error: { message: 'Insufficient donations for this background' }
          });
        }

        if (background.category === 'premium' && totalDonations < background.min_donation_total) {
          return res.status(403).json({
            success: false,
            error: { message: 'Premium tier required for this background' }
          });
        }

        // Public backgrounds are always accessible
      }
      
      // Update settings
      const updatedSettings = await settingsQueries.updateUserSettings(user.id, validatedSettings);

      // Re-verify background access after update
      if (validatedSettings.background_id) {
        const currentDonations = await donationQueries.getUserDonationTotal(user.id);
        const background = await settingsQueries.getBackground(validatedSettings.background_id);
        
        if (background && background.category !== 'public' && 
            currentDonations < (background.min_donation_total || 0)) {
          console.log(`Background access revoked for user ${user.id} - insufficient donations`);
          
          // Revert the background setting
          await settingsQueries.updateUserSettings(user.id, { 
            background_id: null 
          });
          
          // Update the response to reflect the reversion
          updatedSettings.background_id = null;
        }
      }
      
      return handleAPIResponse(res, {
        settings: updatedSettings,
        message: 'Settings updated successfully'
      });
    } catch (error) {
      console.error('Error updating settings:', error);
      return handleAPIError(res, error);
    }
  }

  return res.status(405).json({
    success: false,
    error: { message: 'Method not allowed' }
  });
}

function validateSettings(settings) {
  const validated = {};
  
  if (settings.background_type === 'solid' || settings.background_type === 'gradient') {
    validated.background_type = settings.background_type;
  }
  
  // Gradient type validation
  if (settings.background_gradient_type === 'linear' || 
      settings.background_gradient_type === 'radial' || 
      settings.background_gradient_type === 'conic') {
    validated.background_gradient_type = settings.background_gradient_type;
  }
  
  // Gradient angle validation
  if (typeof settings.background_gradient_angle === 'number') {
    validated.background_gradient_angle = Math.max(0, Math.min(360, Math.round(settings.background_gradient_angle)));
  }
  
  if (settings.background_color && /^#[0-9A-F]{6}$/i.test(settings.background_color)) {
    validated.background_color = settings.background_color;
  }
  
  if (settings.background_gradient_end && /^#[0-9A-F]{6}$/i.test(settings.background_gradient_end)) {
    validated.background_gradient_end = settings.background_gradient_end;
  }
  
  if (typeof settings.background_blur === 'number') {
    validated.background_blur = Math.max(0, Math.min(70, settings.background_blur));
  }
  
  if (typeof settings.background_dimming === 'number') {
    validated.background_dimming = Math.max(20, Math.min(70, settings.background_dimming));
  }
  
  if (typeof settings.background_saturation === 'number') {
    validated.background_saturation = Math.max(-15, Math.min(15, settings.background_saturation));
  }
  
  // Privacy
  if (settings.profile_visibility === 'public' || settings.profile_visibility === 'private') {
    validated.profile_visibility = settings.profile_visibility;
  }
  
  if (settings.background_id !== undefined) {
    if (typeof settings.background_id === 'number' || settings.background_id === null) {
      validated.background_id = settings.background_id;
    }
  } else if (settings.donor_background_id !== undefined) {
    console.warn('Using legacy donor_background_id field for user', user?.id);
    if (typeof settings.donor_background_id === 'number' || settings.donor_background_id === null) {
      validated.background_id = settings.donor_background_id;
    }
  }
  
  if (settings.donor_effects && typeof settings.donor_effects === 'object') {
    validated.donor_effects = settings.donor_effects;
  }
  
  return validated;
}

export default withAuth(handler);


================================================
FILE: frontend/pages/api/subscriptions/cancel.js
================================================
import { withAuth } from '../../../lib/auth-middleware';
import stripe from '../../../lib/stripe';
import { supabaseAdmin } from '../../../lib/supabase-admin';

async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const { user } = req;
  const { subscriptionId } = req.body;

  if (!subscriptionId) {
    return res.status(400).json({ error: 'Subscription ID is required' });
  }

  try {
    // Verify the subscription belongs to this user
    const { data: donation, error: donationError } = await supabaseAdmin
      .from('donations')
      .select('id, user_id, stripe_subscription_id, status')
      .eq('stripe_subscription_id', subscriptionId)
      .eq('user_id', user.id)
      .single();

    if (donationError || !donation) {
      return res.status(404).json({ 
        error: 'Subscription not found or does not belong to you' 
      });
    }

    if (donation.status === 'cancelled') {
      return res.status(400).json({ 
        error: 'Subscription is already cancelled' 
      });
    }

    // Cancel the subscription at period end (not immediately)
    const cancelledSubscription = await stripe.subscriptions.update(
      subscriptionId,
      {
        cancel_at_period_end: true
      }
    );

    // Update our database to reflect the pending cancellation
    const { error: updateError } = await supabaseAdmin
      .from('donations')
      .update({
        status: 'cancelling', // New status to indicate pending cancellation
        updated_at: new Date().toISOString()
      })
      .eq('stripe_subscription_id', subscriptionId);

    if (updateError) {
      console.error('Error updating donation status:', updateError);
      // Don't fail the request - the Stripe cancellation succeeded
    }

    return res.status(200).json({
      success: true,
      message: 'Subscription will be cancelled at the end of the billing period',
      cancelsAt: new Date(cancelledSubscription.current_period_end * 1000).toISOString(),
      subscription: {
        id: cancelledSubscription.id,
        status: cancelledSubscription.status,
        cancel_at_period_end: cancelledSubscription.cancel_at_period_end,
        current_period_end: cancelledSubscription.current_period_end
      }
    });
  } catch (error) {
    console.error('Error cancelling subscription:', error);
    return res.status(500).json({ 
      error: 'Failed to cancel subscription. Please try again or contact support.' 
    });
  }
}

export default withAuth(handler);


================================================
FILE: frontend/pages/api/subscriptions/index.js
================================================
import { withAuth } from '../../../lib/auth-middleware';
import stripe from '../../../lib/stripe';
import { supabaseAdmin } from '../../../lib/supabase-admin';

async function handler(req, res) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const { user } = req;

  try {
    // Get all user's active or cancelling subscriptions
    const { data: donations, error } = await supabaseAdmin
      .from('donations')
      .select('*')
      .eq('user_id', user.id)
      .eq('is_recurring', true)
      .not('stripe_subscription_id', 'is', null)
      .in('status', ['completed', 'cancelling'])
      .order('created_at', { ascending: false });

    if (error) {
      throw error;
    }

    if (!donations || donations.length === 0) {
      return res.status(200).json({
        success: true,
        subscriptions: []
      });
    }

    // Fetch full subscription details from Stripe
    const subscriptionsWithDetails = await Promise.all(
      donations.map(async (donation) => {
        try {
          const subscription = await stripe.subscriptions.retrieve(
            donation.stripe_subscription_id
          );

          return {
            id: subscription.id,
            amount: donation.amount,
            currency: donation.currency,
            status: subscription.status,
            cancel_at_period_end: subscription.cancel_at_period_end,
            current_period_start: new Date(subscription.current_period_start * 1000).toISOString(),
            current_period_end: new Date(subscription.current_period_end * 1000).toISOString(),
            created: new Date(subscription.created * 1000).toISOString(),
            canceled_at: subscription.canceled_at 
              ? new Date(subscription.canceled_at * 1000).toISOString() 
              : null,
            ended_at: subscription.ended_at 
              ? new Date(subscription.ended_at * 1000).toISOString() 
              : null,
            // Our database fields
            dbStatus: donation.status,
            message: donation.message,
            anonymous: donation.anonymous
          };
        } catch (stripeError) {
          console.error(`Error fetching subscription ${donation.stripe_subscription_id}:`, stripeError);
          // Return partial data if Stripe fetch fails
          return {
            id: donation.stripe_subscription_id,
            amount: donation.amount,
            currency: donation.currency,
            status: 'unknown',
            dbStatus: donation.status,
            error: 'Could not fetch subscription details'
          };
        }
      })
    );

    // Filter out subscriptions that are actually cancelled/ended
    const activeSubscriptions = subscriptionsWithDetails.filter(sub => 
      sub.status !== 'canceled' && 
      sub.status !== 'incomplete_expired' &&
      sub.status !== 'unpaid'
    );

    return res.status(200).json({
      success: true,
      subscriptions: activeSubscriptions
    });
  } catch (error) {
    console.error('Error fetching subscriptions:', error);
    return res.status(500).json({ 
      error: 'Failed to fetch subscriptions' 
    });
  }
}

export default withAuth(handler);


================================================
FILE: frontend/pages/api/user/profile/[userId].js
================================================
import { withOptionalAuth } from '../../../../lib/auth-middleware';
import { challengeQueries, supabase } from '../../../../lib/supabase';
import { handleAPIResponse, handleAPIError } from '../../../../lib/api-utils';
import { memoryCache, createCacheKey, CACHE_DURATIONS } from '../../../../lib/memory-cache';
import { generateETag, checkETag } from '../../../../lib/api-utils';

async function handler(req, res) {
  if (req.method !== 'GET') {
    return res.status(405).json({ 
      success: false,
      error: { message: 'Method not allowed' } 
    });
  }

  const { userId, limit, tab } = req.query;

  // Validate userId parameter
  if (!userId || isNaN(parseInt(userId))) {
    return res.status(400).json({ 
      success: false,
      error: { 
        message: 'Invalid user ID parameter',
        code: 'INVALID_USER_ID'
      } 
    });
  }

  const targetUserId = parseInt(userId);
  
  // Determine score limit based on tab
  let scoreLimit;
  if (limit) {
    scoreLimit = parseInt(limit);
  } else {
    switch (tab) {
      case 'recent':
        scoreLimit = 5;
        break;
      case 'best':
        scoreLimit = null;
        break;
      case 'stats':
        scoreLimit = null;
        break;
      default:
        scoreLimit = 5;
    }
  }

  try {
    // CREATE CACHE KEY - Different cache for different tabs and limits
    const cacheKey = createCacheKey('user_profile', targetUserId, {
      tab: tab || 'recent',
      limit: scoreLimit || 'all'
    });

    // TRY MEMORY CACHE FIRST
    const cached = memoryCache.get(cacheKey);
    if (cached) {
      const etag = generateETag(cached);
      if (checkETag(req, etag)) {
        return res.status(304).end();
      }
      
      return handleAPIResponse(res, cached, { 
        cache: true, 
        cacheTime: 600,
        enableETag: true,
        req 
      });
    }

    // Get the target user's basic info
    const { data: profileUser, error: userError } = await supabase
      .from('users')
      .select('id, osu_id, username, avatar_url, country, global_rank, country_rank, pp, created_at')
      .eq('id', targetUserId)
      .single();

    if (userError || !profileUser) {
      return res.status(404).json({ 
        success: false,
        error: { 
          message: 'User not found',
          code: 'USER_NOT_FOUND'
        } 
      });
    }

    // Load user scores, stats, and streaks for the target user
    const [userScores, enhancedUserStats, userStreaks] = await Promise.all([
      challengeQueries.getUserScores(targetUserId),
      getEnhancedUserStats(targetUserId),
      challengeQueries.getUserStreaks(targetUserId)
    ]);

    // Use batch function to get ranks for user scores
    let scoresWithCalculatedRanks = userScores;
    
    if (userScores && userScores.length > 0) {
      try {
        const playlistIds = userScores.map(score => score.playlist_id);
        
        const { data: rankData, error: rankError } = await supabase
          .rpc('get_user_ranks_batch', {
            p_user_id: targetUserId,
            p_playlist_ids: playlistIds
          });

        if (!rankError && rankData) {
          const rankMap = new Map();
          rankData.forEach(rank => {
            rankMap.set(rank.playlist_id, {
              calculated_rank: rank.user_rank,
              total_players: rank.total_players
            });
          });

          scoresWithCalculatedRanks = userScores.map(score => {
            const rankInfo = rankMap.get(score.playlist_id);
            return {
              ...score,
              calculated_rank: rankInfo?.calculated_rank || score.rank_position,
              total_players: rankInfo?.total_players || null
            };
          });
        } else {
          scoresWithCalculatedRanks = userScores.map(score => ({
            ...score,
            calculated_rank: score.rank_position
          }));
        }
      } catch (batchError) {
        console.error('Error in batch rank calculation:', batchError);
        scoresWithCalculatedRanks = userScores.map(score => ({
          ...score,
          calculated_rank: score.rank_position
        }));
      }
    }

    // Apply score limiting based on request
    let finalScores;
    let bestPerformances = null;
    
    if (tab === 'best') {
      // For best tab, filter for top 10 finishes
      const allUserScores = await challengeQueries.getUserScores(targetUserId);
      
      let allScoresWithRanks = allUserScores;
      if (allUserScores && allUserScores.length > 0) {
        try {
          const allPlaylistIds = allUserScores.map(score => score.playlist_id);
          const { data: allRankData, error: allRankError } = await supabase
            .rpc('get_user_ranks_batch', {
              p_user_id: targetUserId,
              p_playlist_ids: allPlaylistIds
            });

          if (!allRankError && allRankData) {
            const rankMap = new Map();
            allRankData.forEach(rank => {
              rankMap.set(rank.playlist_id, {
                calculated_rank: rank.user_rank,
                total_players: rank.total_players
              });
            });

            allScoresWithRanks = allUserScores.map(score => {
              const rankInfo = rankMap.get(score.playlist_id);
              return {
                ...score,
                calculated_rank: rankInfo?.calculated_rank || score.rank_position,
                total_players: rankInfo?.total_players || null
              };
            });
          }
        } catch (error) {
          console.error('Error calculating ranks for best tab:', error);
        }
      }
      
      // Filter and sort by top ranks (top 10 finishes)
      bestPerformances = allScoresWithRanks
        .filter(score => {
          const rank = score.calculated_rank || score.rank_position;
          return rank && rank <= 10;
        })
        .sort((a, b) => {
          const rankA = a.calculated_rank || a.rank_position;
          const rankB = b.calculated_rank || b.rank_position;
          return rankA - rankB;
        });

      finalScores = bestPerformances;
    } else {
      // For other tabs, apply limit if specified
      finalScores = scoreLimit ? scoresWithCalculatedRanks.slice(0, scoreLimit) : scoresWithCalculatedRanks;
    }

    // PREPARE RESPONSE DATA
    const responseData = {
      user: profileUser,
      scores: finalScores,
      totalScores: scoresWithCalculatedRanks.length,
      bestPerformances: bestPerformances,
      stats: enhancedUserStats,
      streaks: userStreaks,
      isPublicProfile: true,
      pagination: {
        limit: scoreLimit,
        total: scoresWithCalculatedRanks.length,
        hasMore: scoreLimit ? scoresWithCalculatedRanks.length > scoreLimit : false,
        tab: tab || 'recent'
      }
    };

    // CACHE THE RESULT
    memoryCache.set(cacheKey, responseData, CACHE_DURATIONS.USER_PROFILE);

    // Return successful response
    return handleAPIResponse(res, responseData, { 
      cache: true, 
      cacheTime: 600,
      enableETag: true,
      req 
    });

  } catch (error) {
    console.error('Error loading user profile:', error);
    return handleAPIError(res, error);
  }
}

async function getEnhancedUserStats(userId) {
  try {
    const allUserScores = await challengeQueries.getUserScores(userId);
    
    if (!allUserScores || allUserScores.length === 0) {
      return getDefaultStats();
    }

    const playlistIds = allUserScores.map(score => score.playlist_id);
    const { data: rankData, error: rankError } = await supabase
      .rpc('get_user_ranks_batch', {
        p_user_id: userId,
        p_playlist_ids: playlistIds
      });

    let scoresWithRanks = allUserScores;
    let ranksArray = [];

    if (!rankError && rankData) {
      const rankMap = new Map();
      rankData.forEach(rank => {
        rankMap.set(rank.playlist_id, {
          calculated_rank: rank.user_rank,
          total_players: rank.total_players
        });
      });

      scoresWithRanks = allUserScores.map(score => {
        const rankInfo = rankMap.get(score.playlist_id);
        return {
          ...score,
          calculated_rank: rankInfo?.calculated_rank || score.rank_position,
          total_players: rankInfo?.total_players || null
        };
      });

      ranksArray = rankData;
    }

    const stats = calculateStatsFromSameData(scoresWithRanks, ranksArray);
    
    return stats;

  } catch (error) {
    console.error('Error fetching enhanced user stats:', error);
    return getDefaultStats();
  }
}

function calculateStatsFromSameData(scoresWithRanks, ranksArray) {
  const totalScores = scoresWithRanks.length;
  
  if (totalScores === 0) {
    return getDefaultStats();
  }

  // For medal/achievement calculations, only count ENDED challenges
  const now = new Date();
  const completedPlaylistIds = new Set(
    scoresWithRanks
      .filter(score => {
        const endDate = score.playlists?.challenges?.end_date;
        // Only include if challenge has an end_date and it's in the past
        return endDate && new Date(endDate) < now;
      })
      .map(s => s.playlist_id)
  );

  // Filter ranks to only completed challenges (for medal/achievement stats)
  const completedRanks = ranksArray.filter(rank => completedPlaylistIds.has(rank.playlist_id));
  const validCompletedRanks = completedRanks.filter(rank => rank.user_rank > 0);

  // All ranks (for general display stats like avgRank)
  const validRanks = ranksArray.filter(rank => rank.user_rank > 0);

  // Medal-triggering stats: use COMPLETED challenges only
  const firstPlaceCount = validCompletedRanks.filter(rank => rank.user_rank === 1).length;
  const podiumCount = validCompletedRanks.filter(rank => rank.user_rank <= 3).length;
  const top10Count = validCompletedRanks.filter(rank => rank.user_rank <= 10).length;

  // Rank distribution (completed challenges only)
  const rankDistribution = {
    first: firstPlaceCount,
    topThree: validCompletedRanks.filter(rank => rank.user_rank >= 2 && rank.user_rank <= 3).length,
    topTen: validCompletedRanks.filter(rank => rank.user_rank >= 4 && rank.user_rank <= 10).length,
    other: validCompletedRanks.filter(rank => rank.user_rank > 10).length
  };

  // =================================================================
  // General stats: can use all data (including active challenges)
  // =================================================================
  
  // Basic aggregations
  const totalScorePoints = scoresWithRanks.reduce((sum, score) => sum + parseInt(score.score || 0), 0);
  const avgScore = Math.round(totalScorePoints / totalScores);
  const avgAccuracy = (scoresWithRanks.reduce((sum, score) => sum + (score.accuracy || 0), 0) / totalScores).toFixed(2);
  
  // Rank-based stats (all challenges for general display)
  const avgRank = validRanks.length > 0 ? Math.round(validRanks.reduce((sum, rank) => sum + rank.user_rank, 0) / validRanks.length) : null;

  // Score-based stats
  const perfectScoreCount = scoresWithRanks.filter(score => score.accuracy === 100.0).length;
  const highAccuracyCount = scoresWithRanks.filter(score => score.accuracy >= 98.0).length;
  
  // Monthly activity
  const monthlyActivity = {};
  scoresWithRanks.forEach(score => {
    if (score.submitted_at) {
      const date = new Date(score.submitted_at);
      const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
      monthlyActivity[monthKey] = (monthlyActivity[monthKey] || 0) + 1;
    }
  });

  // Best/worst values (all challenges)
  const bestRank = validRanks.length > 0 ? Math.min(...validRanks.map(r => r.user_rank)) : null;
  const worstRank = validRanks.length > 0 ? Math.max(...validRanks.map(r => r.user_rank)) : null;
  const bestAccuracy = Math.max(...scoresWithRanks.map(s => s.accuracy || 0)).toFixed(2);
  const highestScore = Math.max(...scoresWithRanks.map(s => s.score || 0));
  
  const lastSubmission = scoresWithRanks
    .filter(s => s.submitted_at)
    .sort((a, b) => new Date(b.submitted_at) - new Date(a.submitted_at))[0]?.submitted_at || null;

  return {
    totalChallenges: 0,
    totalScores,
    avgAccuracy,
    avgScore,
    avgRank,
    bestRank,
    worstRank,
    bestAccuracy,
    highestScore,
    participationRate: 0,
    improvementTrend: 'stable',
    lastSubmission,
    firstPlaceCount,
    perfectScoreCount,
    rankDistribution,
    totalScorePoints,
    monthlyActivity,
    podiumCount,
    top10Count,
    highAccuracyCount
  };
}

function getDefaultStats() {
  return {
    totalChallenges: 0,
    totalScores: 0,
    avgAccuracy: "0.00",
    avgScore: 0,
    avgRank: null,
    bestRank: null,
    worstRank: null,
    bestAccuracy: null,
    highestScore: null,
    participationRate: 0,
    improvementTrend: 'stable',
    lastSubmission: null,
    firstPlaceCount: 0,
    perfectScoreCount: 0,
    rankDistribution: { first: 0, topThree: 0, topTen: 0, other: 0 },
    totalScorePoints: 0,
    monthlyActivity: {},
    podiumCount: 0,
    top10Count: 0,
    highAccuracyCount: 0
  };
}

export default withOptionalAuth(handler);


================================================
FILE: frontend/pages/api/webhook/stripe.js
================================================
import Stripe from 'stripe';
import { buffer } from 'micro';
import { supabaseAdmin } from '../../../lib/supabase-admin';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);

export const config = {
  api: {
    bodyParser: false,
  },
};

function parseUserId(userIdString) {
  if (!userIdString || userIdString === 'guest') {
    return null;
  }
  
  const parsed = parseInt(userIdString, 10);
  
  if (isNaN(parsed) || parsed < 1 || parsed > 2147483647) {
    console.error('Invalid userId in webhook metadata:', userIdString);
    return null;
  }
  
  return parsed;
}

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const buf = await buffer(req);
  const sig = req.headers['stripe-signature'];

  let event;

  try {
    event = stripe.webhooks.constructEvent(
      buf,
      sig,
      process.env.STRIPE_WEBHOOK_SECRET
    );
  } catch (err) {
    console.error('Webhook signature verification failed:', err.message);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  // Check for duplicate webhook events
  const { data: existingEvent, error: checkError } = await supabaseAdmin
    .from('processed_webhook_events')
    .select('id')
    .eq('stripe_event_id', event.id)
    .single();

  if (existingEvent) {
    console.log('Duplicate webhook event received (already processed):', event.id);
    return res.status(200).json({ 
      received: true, 
      duplicate: true,
      message: 'Event already processed'
    });
  }

  if (checkError && checkError.code !== 'PGRST116') {
    console.error('Error checking webhook event:', checkError);
  }

  // Handle the event
  try {
    switch (event.type) {
      case 'checkout.session.completed':
        const fullSession = await stripe.checkout.sessions.retrieve(
          event.data.object.id,
          { expand: ['subscription'] }
        );
        await handleCheckoutSessionCompleted(fullSession);
        break;
        
      case 'payment_intent.succeeded':
        await handlePaymentIntentSucceeded(event.data.object);
        break;
        
      case 'customer.subscription.created':
        await handleSubscriptionCreated(event.data.object);
        break;
        
      case 'customer.subscription.deleted':
        await handleSubscriptionDeleted(event.data.object);
        break;
        
      case 'customer.subscription.updated':
        await handleSubscriptionUpdated(event.data.object);
        break;
        
      case 'invoice.payment_succeeded':
        await handleInvoicePaymentSucceeded(event.data.object);
        break;
        
      default:
        console.log(`Unhandled event type ${event.type}`);
    }

    // Record that we processed this event
    const { error: insertError } = await supabaseAdmin
      .from('processed_webhook_events')
      .insert({
        stripe_event_id: event.id,
        event_type: event.type,
        processed_at: new Date().toISOString()
      });

    if (insertError && insertError.code !== '23505') {
      console.error('Error recording processed webhook event:', insertError);
    }

    res.status(200).json({ received: true });
  } catch (error) {
    console.error('Webhook handler error:', error);
    res.status(500).json({ error: 'Webhook handler failed' });
  }
}

async function handleCheckoutSessionCompleted(session) {
  console.log('Checkout session completed:', session.id);
  console.log('Session mode:', session.mode);
  
  if (!supabaseAdmin) {
    console.error('Supabase admin client not available');
    return;
  }

  let subscriptionId = session.subscription;
  
  if (subscriptionId && typeof subscriptionId === 'object' && subscriptionId.id) {
    subscriptionId = subscriptionId.id;
  }
  
  if (session.mode === 'subscription' && !subscriptionId) {
    console.log('Subscription ID not found, retrieving full session...');
    try {
      const fullSession = await stripe.checkout.sessions.retrieve(session.id, {
        expand: ['subscription', 'payment_intent']
      });
      subscriptionId = fullSession.subscription?.id || fullSession.subscription;
      console.log('Retrieved subscription ID:', subscriptionId);
    } catch (error) {
      console.error('Error retrieving full session:', error);
    }
  }

  const donationData = {
    user_id: parseUserId(session.metadata?.userId),
    amount: session.amount_total / 100,
    currency: session.currency,
    status: 'completed',
    stripe_payment_intent_id: session.mode === 'payment' ? session.payment_intent : null,
    stripe_subscription_id: session.mode === 'subscription' ? subscriptionId : null,
    is_recurring: session.mode === 'subscription',
    anonymous: session.metadata?.isAnonymous === 'true',
    message: session.metadata?.message || null
  };

  console.log('Creating donation record:', donationData);

  const { error } = await supabaseAdmin
    .from('donations')
    .insert(donationData);

  if (error) {
    console.error('Error creating donation record:', error);
  } else {
    console.log('Successfully created donation record');
  }
}

async function handlePaymentIntentSucceeded(paymentIntent) {
  console.log('Payment intent succeeded:', paymentIntent.id);
}

async function handleSubscriptionCreated(subscription) {
  console.log('Subscription created:', subscription.id);
  // Skip - we record the subscription in checkout.session.completed
}

async function handleSubscriptionDeleted(subscription) {
  console.log('Subscription cancelled/deleted:', subscription.id);
  
  if (!supabaseAdmin) return;

  // Update subscription status to cancelled
  const { error } = await supabaseAdmin
    .from('donations')
    .update({
      status: 'cancelled',
      updated_at: new Date().toISOString()
    })
    .eq('stripe_subscription_id', subscription.id);

  if (error) {
    console.error('Error updating subscription status:', error);
  } else {
    console.log('Successfully updated subscription to cancelled');
  }
}

async function handleSubscriptionUpdated(subscription) {
  console.log('Subscription updated:', subscription.id);
  
  if (!supabaseAdmin) return;

  // Handle cancel_at_period_end flag
  if (subscription.cancel_at_period_end) {
    console.log('Subscription set to cancel at period end:', subscription.id);
    
    const { error } = await supabaseAdmin
      .from('donations')
      .update({
        status: 'cancelling',
        updated_at: new Date().toISOString()
      })
      .eq('stripe_subscription_id', subscription.id);

    if (error) {
      console.error('Error updating subscription to cancelling:', error);
    }
  } else if (subscription.status === 'active') {
    // Subscription was reactivated or cancel was undone
    const { error } = await supabaseAdmin
      .from('donations')
      .update({
        status: 'completed',
        updated_at: new Date().toISOString()
      })
      .eq('stripe_subscription_id', subscription.id);

    if (error) {
      console.error('Error updating subscription to active:', error);
    }
  }
}

async function handleInvoicePaymentSucceeded(invoice) {
  console.log('Invoice payment succeeded:', invoice.id);
  
  if (!invoice.subscription || !supabaseAdmin) return;
  
  // Skip initial subscription invoice (already recorded in checkout.session.completed)
  if (invoice.billing_reason === 'subscription_create') {
    console.log('Skipping initial subscription invoice - already recorded');
    return;
  }
  
  // This is a recurring payment - record it
  const { error } = await supabaseAdmin
    .from('donations')
    .insert({
      user_id: parseUserId(invoice.metadata?.userId),
      amount: invoice.amount_paid / 100,
      currency: invoice.currency,
      status: 'completed',
      stripe_subscription_id: invoice.subscription,
      is_recurring: true,
      anonymous: invoice.metadata?.isAnonymous === 'true',
      message: 'Recurring monthly donation'
    });

  if (error) {
    console.error('Error recording recurring payment:', error);
  } else {
    console.log('Successfully recorded recurring payment');
  }
}


================================================
FILE: frontend/pages/challenges/[roomId].js
================================================
import { useState, useEffect, useRef } from 'react';
import { useRouter } from 'next/router';
import Link from 'next/link';
import useSWR from 'swr';
import Layout from '../../components/Layout';
import ScoreTable from '../../components/ScoreTable';
import CombinedLeaderboard from '../../components/CombinedLeaderboard';
import { challengeQueries } from '../../lib/supabase';
import { 
  ArrowLeft, Loader2, Users, Calendar, Music, Star, Trophy, 
  Clock, AlertCircle, Search, Filter, ChevronRight, Target 
} from 'lucide-react';
import { generateRulesetName, generateRulesetDescription } from '../../lib/ruleset-name-generator';

const fetcher = async (url) => {
  const res = await fetch(url);
  if (!res.ok) {
    throw new Error('API request failed');
  }
  const data = await res.json();
  return data.data || data;
};

const formatUTCDateTime = (utcDateString) => {
  if (!utcDateString) return 'N/A';
  const utcString = utcDateString.endsWith('Z') ? utcDateString : `${utcDateString}Z`;
  const date = new Date(utcString);
  return date.toLocaleString(undefined, {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  });
};

const getDifficultyColor = (difficulty) => {
  if (difficulty < 1.25) return 'text-blue-300 bg-blue-500';
  if (difficulty < 2.0) return 'text-cyan-300 bg-cyan-500';
  if (difficulty < 2.5) return 'text-green-300 bg-green-500';
  if (difficulty < 3.3) return 'text-lime-300 bg-lime-500';
  if (difficulty < 4.2) return 'text-yellow-300 bg-yellow-500';
  if (difficulty < 4.9) return 'text-orange-300 bg-orange-500';
  if (difficulty < 5.8) return 'text-red-300 bg-red-500';
  if (difficulty < 6.7) return 'text-pink-300 bg-pink-500';
  if (difficulty < 7.7) return 'text-purple-300 bg-purple-500';
  return 'text-indigo-300 bg-indigo-600';
};

export default function ChallengeDetail() {
  const router = useRouter();
  const { roomId } = router.query;
  
  const { data: challengeData, error, mutate: refresh, isValidating } = useSWR(
    roomId ? `/api/challenges/${roomId}` : null,
    fetcher,
    {
      revalidateOnFocus: false,
      revalidateOnReconnect: true,
      refreshInterval: 300000, // Auto-refresh every 5 minutes
    }
  );

  const challenge = challengeData?.challenge;
  const rulesetInfo = challengeData?.ruleset_info;
  const rulesetWinner = challengeData?.ruleset_winner;
  const dataInfo = challengeData?.data_info;
  const loading = !challengeData && !error;

  // Calculate real-time data age on client side
  const [dataAgeMinutes, setDataAgeMinutes] = useState(null);
  const [isFresh, setIsFresh] = useState(true);

  const ensureUTC = (dateString) => {
    if (!dateString) return null;
    // If it already has timezone info, use as-is
    if (dateString.includes('Z') || dateString.includes('+') || dateString.includes('-', 10)) {
      return new Date(dateString);
    }
    // Otherwise, treat as UTC by appending 'Z'
    return new Date(dateString + 'Z');
  };

  useEffect(() => {
    if (!challenge?.updated_at) {
      setDataAgeMinutes(null);
      setIsFresh(true);
      return;
    }
    
    const calculateAge = () => {
      // FIX: Use ensureUTC to properly interpret the timestamp
      const updatedAt = ensureUTC(challenge.updated_at);
      const age = Math.floor((Date.now() - updatedAt.getTime()) / 60000);
      setDataAgeMinutes(age);
      setIsFresh(age < 5); // Fresh if updated within last 5 minutes
    };

    // Calculate immediately
    calculateAge();
    
    // Update every minute
    const interval = setInterval(calculateAge, 60000);

    return () => clearInterval(interval);
  }, [challenge?.updated_at]);

  const [selectedPlaylistId, setSelectedPlaylistId] = useState(null);
  const [sortBy, setSortBy] = useState('difficulty');
  const [searchQuery, setSearchQuery] = useState('');

  useEffect(() => {
    if (challenge?.playlists?.length > 0 && !selectedPlaylistId) {
      setSelectedPlaylistId(challenge.playlists[0].id);
    }
  }, [challenge?.playlists, selectedPlaylistId]);

  const shouldShowCombinedLeaderboard = challenge?.playlists?.filter(
    p => p.scores?.length > 0
  ).length >= 2;

  const { data: combinedLeaderboard, isLoading: leaderboardLoading } = useSWR(
    shouldShowCombinedLeaderboard ? ['leaderboard', challenge.id] : null,
    () => challengeQueries.getChallengeLeaderboard(challenge.id),
    { revalidateOnFocus: false }
  );

  const getSortedAndFilteredPlaylists = () => {
    if (!challenge?.playlists) return [];
    
    let playlists = [...challenge.playlists];
    
    if (searchQuery) {
      playlists = playlists.filter(p => 
        p.beatmap_title?.toLowerCase().includes(searchQuery.toLowerCase()) ||
        p.beatmap_artist?.toLowerCase().includes(searchQuery.toLowerCase()) ||
        p.beatmap_version?.toLowerCase().includes(searchQuery.toLowerCase())
      );
    }
    
    switch (sortBy) {
      case 'difficulty':
        return playlists.sort((a, b) => (a.beatmap_difficulty || 0) - (b.beatmap_difficulty || 0));
      case 'participants':
        return playlists.sort((a, b) => (b.scores?.length || 0) - (a.scores?.length || 0));
      case 'alphabetical':
        return playlists.sort((a, b) => (a.beatmap_title || '').localeCompare(b.beatmap_title || ''));
      default:
        return playlists;
    }
  };

  const selectedPlaylist = challenge?.playlists?.find(p => p.id === selectedPlaylistId);
  const isSinglePlaylist = challenge?.playlists?.length === 1;

  const RulesetNote = ({ challenge, rulesetInfo }) => {
    if (!challenge?.has_ruleset || !rulesetInfo?.required_mods) {
      return null;
    }

    const getRulesetName = () => {
      try {
        return generateRulesetName(rulesetInfo.required_mods, rulesetInfo.ruleset_match_type || 'exact');
      } catch (error) {
        console.warn('Error generating ruleset name:', error);
        return 'Custom Ruleset';
      }
    };

    const getRulesetDescription = () => {
      try {
        return generateRulesetDescription(rulesetInfo.required_mods, rulesetInfo.ruleset_match_type || 'exact');
      } catch (error) {
        console.warn('Error generating ruleset description:', error);
        return 'Custom ruleset is active';
      }
    };

    return (
      <div className="glass-1 rounded-xl sm:rounded-2xl p-3 sm:p-4 mb-4 sm:mb-6 performance-card-orange">
        <div className="flex items-center gap-2 text-xs sm:text-sm">
          <Target className="w-4 h-4 text-orange-400 flex-shrink-0 icon-shadow-adaptive-sm" />
          <span className="text-white/90 text-shadow-adaptive-sm">
            <strong>Ruleset Active:</strong> <code className="glass-2 text-white px-1.5 py-0.5 rounded font-mono text-xs ml-1">{getRulesetName()}</code> - {getRulesetDescription()}
          </span>
        </div>
      </div>
    );
  };

  if (!roomId) return null;

  return (
    <Layout>
      <div className="min-h-screen py-4 sm:py-6 lg:py-8">
        <div className="max-w-7xl mx-auto px-3 sm:px-4 lg:px-6">
          
          {/* Back button */}
          <div className="mb-4 sm:mb-6">
            <Link 
              href="/challenges"
              className="group flex items-center gap-2 text-white/70 hover:text-white/90 font-medium text-shadow-adaptive-sm transition-all text-sm sm:text-base"
            >
              <ArrowLeft className="w-4 h-4 group-hover:-translate-x-1 transition-transform icon-shadow-adaptive-sm" />
              Back to challenges
            </Link>
          </div>

          {loading ? (
            <div className="glass-1 rounded-2xl sm:rounded-3xl p-8 sm:p-16 text-center">
              <Loader2 className="w-6 h-6 sm:w-8 sm:h-8 animate-spin text-white/70 mx-auto mb-3 sm:mb-4 icon-shadow-adaptive" />
              <p className="text-white/70 text-shadow-adaptive-sm text-sm sm:text-base">Loading challenge...</p>
            </div>
          ) : error || !challenge ? (
            <div className="glass-1 rounded-2xl sm:rounded-3xl p-6 sm:p-12 text-center">
              <div className="w-12 h-12 sm:w-16 sm:h-16 bg-red-500/20 rounded-full flex items-center justify-center mx-auto mb-3 sm:mb-4 glass-2">
                <AlertCircle className="w-6 h-6 sm:w-8 sm:h-8 text-red-400 icon-shadow-adaptive" />
              </div>
              <h3 className="text-xl sm:text-2xl font-bold text-white/90 mb-3 sm:mb-4 text-shadow-adaptive">
                Failed to load challenge
              </h3>
              <p className="text-white/70 mb-4 sm:mb-6 text-shadow-adaptive-sm text-sm sm:text-base">
                There was an error loading this challenge.
              </p>
              <div className="flex flex-col sm:flex-row gap-3 sm:gap-4 justify-center">
                <button
                  onClick={refresh}
                  disabled={isValidating}
                  className="px-4 py-2 sm:px-6 sm:py-3 bg-gradient-to-b from-red-500 to-pink-500 text-white font-semibold rounded-full hover:shadow-lg transform hover:scale-105 transition-all disabled:opacity-50 text-sm sm:text-base"
                >
                  {isValidating ? 'Retrying...' : 'Try Again'}
                </button>
                <Link 
                  href="/challenges"
                  className="px-4 py-2 sm:px-6 sm:py-3 glass-2 hover:glass-3 text-white font-semibold rounded-full transition-all text-sm sm:text-base"
                >
                  Back to challenges
                </Link>
              </div>
            </div>
          ) : (
            <>
              {/* Challenge Header */}
              <div className="glass-1 rounded-xl sm:rounded-2xl mb-4 sm:mb-6 shadow-xl">
                <div className="p-4 sm:p-6 lg:p-8">
                  <div className="flex justify-between items-start mb-3 sm:mb-4">
                    <h1 className="text-2xl sm:text-3xl lg:text-4xl font-black text-white text-shadow-adaptive">
                      {challenge.custom_name || challenge.name}
                    </h1>
                  </div>
                  
                  <div className="flex flex-wrap items-center gap-3 sm:gap-4 lg:gap-6 text-white/80 mb-3 sm:mb-4 text-xs sm:text-sm">
                    <span className="flex items-center gap-1.5 sm:gap-2">
                      <Users className="w-4 h-4 sm:w-5 sm:h-5 text-blue-300 icon-shadow-adaptive-sm" />
                      <span className="text-shadow-adaptive-sm">Hosted by <span className="font-medium text-white">{challenge.host}</span></span>
                    </span>
                    <span className="flex items-center gap-1.5 sm:gap-2">
                      <Users className="w-4 h-4 sm:w-5 sm:h-5 text-purple-300 icon-shadow-adaptive-sm" />
                      <span className="font-medium text-white text-shadow-adaptive-sm">{challenge.participant_count}</span> participants
                    </span>
                    <span className="flex items-center gap-1.5 sm:gap-2">
                      <Music className="w-4 h-4 sm:w-5 sm:h-5 text-orange-300 icon-shadow-adaptive-sm" />
                      <span className="font-medium text-white text-shadow-adaptive-sm">{challenge.playlists?.length || 0}</span> {challenge.playlists?.length === 1 ? 'map' : 'maps'}
                    </span>
                    {challenge.start_date && challenge.end_date && (
                      <span className="flex items-center gap-1.5 sm:gap-2">
                        <Calendar className="w-4 h-4 sm:w-5 sm:h-5 text-green-300 icon-shadow-adaptive-sm" />
                        <span className="font-medium text-white text-shadow-adaptive-sm">
                          {new Date(challenge.start_date).toLocaleDateString(undefined, {
                            day: '2-digit',
                            month: '2-digit',
                            year: 'numeric'
                          })} - {new Date(challenge.end_date).toLocaleDateString(undefined, {
                            day: '2-digit',
                            month: '2-digit',
                            year: 'numeric'
                          })}
                        </span>
                      </span>
                    )}
                  </div>

                  <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2">
                    <div className="flex items-center gap-2">
                      <span className={`inline-block w-2.5 h-2.5 sm:w-3 sm:h-3 rounded-full ${
                        challenge.is_active ? 'bg-green-400' : 'bg-gray-400'
                      }`}></span>
                      <span className="text-xs sm:text-sm text-white/90 text-shadow-adaptive-sm">
                        {challenge.is_active ? 'Active Challenge' : 'Inactive Challenge'}
                      </span>
                    </div>
                    
                    {challenge.is_active && (
                      <div className="flex items-center gap-2 text-xs text-white/70 text-shadow-adaptive-sm">
                        <Clock className="w-3 h-3 icon-shadow-adaptive-sm" />
                        <span>
                          Last updated: {dataAgeMinutes !== null ? `${dataAgeMinutes}min ago` : 'just now'}
                        </span>
                        {!isFresh && (
                          <span className="text-yellow-300 font-medium ml-2">
                            (updating soon)
                          </span>
                        )}
                      </div>
                    )}
                  </div>
                </div>
              </div>

              <RulesetNote challenge={challenge} rulesetInfo={rulesetInfo} />

              {/* Combined Leaderboard */}
              {shouldShowCombinedLeaderboard && (
                <div className="mb-6 sm:mb-8">
                  <div className="glass-2 rounded-xl sm:rounded-2xl overflow-hidden shadow-xl border border-purple-400/30">
                    <div className="p-4 sm:p-6 border-b border-white/10" style={{
                      background: 'linear-gradient(to bottom, rgba(168, 85, 247, 0.2), rgba(236, 72, 153, 0.1))'
                    }}>
                      <div className="flex items-center gap-2 sm:gap-3">
                        <div className="p-2 sm:p-3 icon-gradient-purple rounded-lg sm:rounded-xl icon-container-purple">
                          <Trophy className="w-5 h-5 sm:w-6 sm:h-6 text-white icon-shadow-adaptive" />
                        </div>
                        <div>
                          <h2 className="text-lg sm:text-xl lg:text-2xl font-bold text-white text-shadow-adaptive">
                            Combined Leaderboard
                          </h2>
                          <p className="text-white/80 text-xs sm:text-sm mt-0.5 text-shadow-adaptive-sm">
                            Total scores across all {challenge.playlists.length} maps
                          </p>
                        </div>
                      </div>
                    </div>
                    <div className="p-4 sm:p-6">
                      <CombinedLeaderboard 
                        leaderboard={combinedLeaderboard || []} 
                        loading={leaderboardLoading}
                        totalMaps={challenge.playlists.length}
                      />
                    </div>
                  </div>
                </div>
              )}

              {/* Individual Maps Section */}
              {isSinglePlaylist ? (
                <div className="glass-1 rounded-xl sm:rounded-2xl overflow-hidden shadow-xl">
                  {challenge.playlists[0] && (
                    <>
                      <div className="p-4 sm:p-6 border-b border-white/10">
                        <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
                          <div>
                            <h2 className="text-xl sm:text-2xl font-bold text-white text-shadow-adaptive mb-1">
                              {challenge.playlists[0].beatmap_title}
                            </h2>
                            <p className="text-white/80 text-sm sm:text-base text-shadow-adaptive-sm">
                              by {challenge.playlists[0].beatmap_artist} [{challenge.playlists[0].beatmap_version}]
                            </p>
                          </div>
                          {challenge.playlists[0].beatmap_difficulty && (
                            <div className={`inline-flex items-center gap-1.5 px-3 py-1.5 rounded-full text-sm font-bold ${getDifficultyColor(challenge.playlists[0].beatmap_difficulty)} shadow-md`}>
                              <Star className="w-4 h-4 fill-current" />
                              <span>{challenge.playlists[0].beatmap_difficulty.toFixed(2)}</span>
                            </div>
                          )}
                        </div>
                      </div>
                      <div className="p-4 sm:p-6">
                        {challenge.playlists[0].scores?.length > 0 ? (
                          <ScoreTable scores={challenge.playlists[0].scores} challenge={challenge} />
                        ) : (
                          <div className="text-center py-8 sm:py-12">
                            <Music className="w-10 h-10 sm:w-12 sm:h-12 mx-auto mb-3 text-white/30 icon-shadow-adaptive" />
                            <p className="text-white/70 text-shadow-adaptive-sm text-sm sm:text-base">No scores submitted yet</p>
                            <p className="text-xs sm:text-sm text-white/60 mt-1 text-shadow-adaptive-sm">Be the first to set a score!</p>
                          </div>
                        )}
                      </div>
                    </>
                  )}
                </div>
              ) : (
                <div className="glass-1 rounded-xl sm:rounded-2xl p-4 sm:p-6 lg:p-8 shadow-xl">
                  <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3 sm:gap-4 mb-4 sm:mb-6">
                    <h2 className="text-xl sm:text-2xl font-bold text-white text-shadow-adaptive flex items-center gap-2 sm:gap-3">
                      <Music className="w-5 h-5 sm:w-7 sm:h-7 text-purple-400 icon-shadow-adaptive" />
                      Individual Maps
                    </h2>
                    
                    <div className="flex flex-col sm:flex-row gap-2 sm:gap-3">
                      <div className="relative">
                        <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-white/50 icon-shadow-adaptive-sm" />
                        <input
                          type="text"
                          placeholder="Search maps..."
                          value={searchQuery}
                          onChange={(e) => setSearchQuery(e.target.value)}
                          className="glass-2 text-white text-sm pl-10 pr-4 py-2 rounded-full border-none focus:outline-none focus:ring-2 focus:ring-purple-400 text-shadow-adaptive-sm placeholder-white/50 w-full sm:w-auto"
                        />
                      </div>
                      
                      <div className="flex items-center gap-2">
                        <Filter className="w-4 h-4 text-white/70 icon-shadow-adaptive-sm" />
                        <select
                          value={sortBy}
                          onChange={(e) => setSortBy(e.target.value)}
                          className="glass-2 text-white text-sm px-3 py-2 rounded-full border-none focus:outline-none focus:ring-2 focus:ring-purple-400 text-shadow-adaptive-sm bg-transparent"
                        >
                          <option value="difficulty" className="bg-gray-800 text-white">Sort by Difficulty</option>
                          <option value="participants" className="bg-gray-800 text-white">Sort by Participants</option>
                          <option value="alphabetical" className="bg-gray-800 text-white">Sort Alphabetically</option>
                        </select>
                      </div>
                    </div>
                  </div>

                  <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 mb-6 max-h-[400px] overflow-y-auto scrollbar-glass">
                    {getSortedAndFilteredPlaylists().map((playlist) => {
                      const participantCount = playlist.scores?.length || 0;
                      const isSelected = playlist.id === selectedPlaylistId;
                      
                      return (
                        <button
                          key={playlist.id}
                          onClick={() => setSelectedPlaylistId(playlist.id)}
                          className={`group relative flex items-center gap-3 p-3 rounded-lg transition-all ${
                            isSelected 
                              ? 'glass-2 ring-2 ring-purple-400/60 transform scale-[1.02]' 
                              : 'glass-1 hover:glass-2'
                          }`}
                        >
                          <div className="relative w-16 h-16 rounded-lg overflow-hidden flex-shrink-0">
                            {playlist.beatmap_cover_url ? (
                              <>
                                <img
                                  src={playlist.beatmap_cover_url}
                                  alt=""
                                  className="absolute inset-0 w-full h-full object-cover"
                                  loading="lazy"
                                  onError={(e) => {
                                    e.target.style.display = 'none';
                                    e.target.nextSibling.style.display = 'flex';
                                  }}
                                />
                                <div className="absolute inset-0 bg-gradient-to-b from-purple-600/40 to-pink-600/40 hidden items-center justify-center">
                                  <Music className="w-6 h-6 text-white/50 icon-shadow-adaptive-sm" />
                                </div>
                              </>
                            ) : (
                              <div className="w-full h-full bg-gradient-to-b from-purple-600/40 to-pink-600/40 flex items-center justify-center">
                                <Music className="w-6 h-6 text-white/50 icon-shadow-adaptive-sm" />
                              </div>
                            )}
                          </div>
                          
                          <div className="flex-1 min-w-0 text-left">
                            <h3 className="font-semibold text-white text-sm line-clamp-1 text-shadow-adaptive mb-0.5">
                              {playlist.beatmap_title}
                            </h3>
                            <p className="text-xs text-white/70 line-clamp-1 text-shadow-adaptive-sm">
                              {playlist.beatmap_artist} [{playlist.beatmap_version}]
                            </p>
                            <div className="flex items-center gap-3 mt-1">
                              {playlist.beatmap_difficulty && (
                                <div className={`inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-xs font-bold ${getDifficultyColor(playlist.beatmap_difficulty)}`}>
                                  <Star className="w-3 h-3 fill-current" />
                                  {playlist.beatmap_difficulty.toFixed(1)}
                                </div>
                              )}
                              <span className="text-xs text-white/60 flex items-center gap-1 text-shadow-adaptive-sm">
                                <Users className="w-3 h-3 icon-shadow-adaptive-sm" />
                                {participantCount}
                              </span>
                            </div>
                          </div>
                          
                          {isSelected && (
                            <ChevronRight className="w-5 h-5 text-purple-400 icon-shadow-adaptive" />
                          )}
                        </button>
                      );
                    })}
                  </div>

                  <div className="border-t border-white/10 pt-6">
                    {selectedPlaylist ? (
                      <>
                        <div className="mb-4">
                          <h3 className="text-lg font-semibold text-white mb-1 text-shadow-adaptive">
                            {selectedPlaylist.beatmap_title}
                          </h3>
                          <p className="text-sm text-white/80 text-shadow-adaptive-sm">
                            by {selectedPlaylist.beatmap_artist} [{selectedPlaylist.beatmap_version}]
                          </p>
                        </div>
                        {selectedPlaylist.scores?.length > 0 ? (
                          <ScoreTable scores={selectedPlaylist.scores} challenge={challenge} />
                        ) : (
                          <div className="text-center py-8">
                            <Music className="w-10 h-10 mx-auto mb-3 text-white/30 icon-shadow-adaptive" />
                            <p className="text-white/70 text-shadow-adaptive-sm">No scores submitted yet</p>
                            <p className="text-xs text-white/60 mt-1 text-shadow-adaptive-sm">Be the first to set a score!</p>
                          </div>
                        )}
                      </>
                    ) : (
                      <div className="text-center py-8">
                        <Music className="w-10 h-10 mx-auto mb-3 text-white/30 icon-shadow-adaptive" />
                        <p className="text-white/70 text-shadow-adaptive-sm">Select a map to view scores</p>
                      </div>
                    )}
                  </div>
                </div>
              )}

              {/* Footer */}
              <div className="mt-8 sm:mt-12 text-center pb-4 sm:pb-8">
                {challenge.is_active && (
                  <div className="inline-flex items-center gap-3 px-4 sm:px-6 py-2 sm:py-3 glass-1 rounded-full shadow-md">
                    <div className={`w-2 h-2 rounded-full ${
                      isFresh ? 'bg-green-500' : 'bg-yellow-500'
                    }`}></div>
                    <p className="text-xs sm:text-sm text-white/90 font-medium text-shadow-adaptive-sm">
                      {isFresh 
                        ? 'Data is up to date' 
                        : `Will update in ~${Math.max(0, 5 - (dataAgeMinutes || 0))} minutes`
                      }
                    </p>
                  </div>
                )}
              </div>
            </>
          )}
        </div>
      </div>
    </Layout>
  );
}


================================================
FILE: frontend/pages/profile/[userId].js
================================================
import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import Link from 'next/link';
import Layout from '../../components/Layout';
import Loading from '../../components/Loading'; 
import { useAuth } from '../../lib/AuthContext';
import MedalsDisplay from '../../components/MedalsDisplay';
import { 
  Trophy, Target, Calendar, User, Award, BarChart3, 
  Sparkles, Flame, Zap, ArrowLeft, ExternalLink, TrendingUp,
  Star, Clock, MapPin, Music, ChevronRight, Activity,
  Crown, Medal, Loader2, Download, Image
} from 'lucide-react';

export default function UserProfile() {
  const { user: currentUser, loading: authLoading } = useAuth();
  const [profileUser, setProfileUser] = useState(null);
  const [allScores, setAllScores] = useState([]);
  const [allBestPerformances, setAllBestPerformances] = useState([]);
  const [stats, setStats] = useState(null);
  const [streaks, setStreaks] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [activeTab, setActiveTab] = useState('recent');
  const [tabLoading, setTabLoading] = useState(false);
  const [downloadingCard, setDownloadingCard] = useState(null);
  const router = useRouter();
  const { userId } = router.query;

  const STAFF_MEMBERS = {
    35: { type: 'designer', label: 'o!C Staff - Graphic Designer' },
    268: { type: 'developer', label: 'o!C Staff - Developer' },
    671: { type: 'lead', label: 'o!C Staff - Project Lead' },
    3: { type: 'qa', label: 'o!C Staff - QA Tester' },
    20186: { type: 'developer', label: 'o!C Staff - Developer' },
    1: { type: 'developer', label: 'o!C Staff - Developer' },
  };

  useEffect(() => {
    if (!userId) return;
    loadUserData('recent'); // Always load with 'recent' initially
  }, [userId]);

  const loadUserData = async (tab = 'recent') => {
    try {
      setLoading(true);
      setError(null);
      
      // Pass the tab parameter to the API
      const profileResponse = await fetch(`/api/user/profile/${userId}?tab=${tab}`);
      
      if (!profileResponse.ok) {
        if (profileResponse.status === 404) {
          setError('User not found');
        } else {
          setError('Failed to load user profile');
        }
        return;
      }

      const profileData = await profileResponse.json();
      
      if (!profileData.success) {
        setError(profileData.error?.message || 'Failed to load profile');
        return;
      }

      const responseData = profileData.data || profileData;
      setProfileUser(responseData.user);
      setAllScores(responseData.scores || []);
      setAllBestPerformances(responseData.bestPerformances || []);
      setStats(responseData.stats || null);
      setStreaks(responseData.streaks || null);

    } catch (error) {
      console.error('Error loading user data:', error);
      setError('Failed to load user profile');
    } finally {
      setLoading(false);
    }
  };

  const handleDownloadCard = async (variant = 'main') => {
    if (!profileUser?.osu_id) {
      alert('Unable to generate card: User osu! ID not found');
      return;
    }

    try {
      setDownloadingCard(variant);
      
      // Fetch the SVG from the card API
      const response = await fetch(`/api/card?id=${profileUser.osu_id}&option=${variant}`);
      
      if (!response.ok) {
        throw new Error('Failed to generate card');
      }

      const svgContent = await response.text();
      
      // Create a blob from the SVG content
      const blob = new Blob([svgContent], { type: 'image/svg+xml' });
      
      // Create download link
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `${profileUser.username}_card_${variant}.svg`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
    } catch (error) {
      console.error('Error downloading card:', error);
      alert('Failed to download card. Please try again.');
    } finally {
      setDownloadingCard(null);
    }
  };

  const handleTabChange = async (newTab) => {
    if (newTab === activeTab) return;
    
    // Set tab loading state (not full page loading)
    setTabLoading(true);
    setActiveTab(newTab);
    
    try {
      // Fetch data for new tab
      const profileResponse = await fetch(`/api/user/profile/${userId}?tab=${newTab}`);
      
      if (profileResponse.ok) {
        const profileData = await profileResponse.json();
        
        if (profileData.success) {
          const responseData = profileData.data || profileData;
          // Only update scores and bestPerformances, keep other data
          setAllScores(responseData.scores || []);
          setAllBestPerformances(responseData.bestPerformances || []);
        }
      }
    } catch (error) {
      console.error('Error loading tab data:', error);
    } finally {
      setTabLoading(false);
    }
  };

  // Helper functions
  const getCountryFlagUrl = (countryCode) => {
    if (!countryCode || countryCode.length !== 2) return null;
    return `https://flagcdn.com/w40/${countryCode.toLowerCase()}.png`;
  };

  const getAccuracyColor = (accuracy) => {
    if (accuracy >= 98) return 'text-purple-400';
    if (accuracy >= 95) return 'text-green-400';
    if (accuracy >= 90) return 'text-blue-400';
    if (accuracy >= 80) return 'text-yellow-400';
    return 'text-red-400';
  };

  const getAccuracyBorder = (accuracy) => {
    if (accuracy >= 98) return 'acc-badge-purple';
    if (accuracy >= 95) return 'acc-badge-green';
    if (accuracy >= 90) return 'acc-badge-blue';
    if (accuracy >= 85) return 'acc-badge-yellow';
    return 'acc-badge-red';
  };

  const getAccuracyGradient = (accuracy) => {
    if (accuracy >= 98) return 'from-purple-500 to-pink-500';
    if (accuracy >= 95) return 'from-emerald-500 to-green-500';
    if (accuracy >= 90) return 'from-blue-500 to-cyan-500';
    if (accuracy >= 85) return 'from-yellow-500 to-orange-500';
    return 'from-red-500 to-pink-500';
  };

  const getRankGradient = (rank) => {
    if (rank === 1) return 'from-yellow-400 to-amber-600';
    if (rank <= 3) return 'from-gray-300 to-gray-500';
    if (rank <= 10) return 'from-orange-400 to-red-500';
    return 'from-blue-400 to-indigo-500';
  };

  const getStreakEmoji = (streak) => {
    if (streak >= 30) return 'üî•';
    if (streak >= 14) return '‚ö°';
    if (streak >= 7) return '‚ú®';
    if (streak >= 3) return '‚≠ê';
    return 'üí´';
  };

  const formatNumber = (num) => {
    if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
    if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
    return num?.toLocaleString() || '0';
  };

  const getNextMilestone = (totalScores) => {
    const milestones = [10, 25, 50, 100, 250, 500, 1000];
    const nextMilestone = milestones.find(m => totalScores < m);
    
    if (!nextMilestone) {
      return { 
        title: 'üéâ Legend!', 
        remaining: 0,
        isLegend: true 
      };
    }
    
    return { 
      title: `${nextMilestone} Plays`, 
      remaining: nextMilestone - totalScores,
      isLegend: false
    };
  };

  const getScoresForTab = () => {
    if (activeTab === 'recent') {
      return allScores.slice(0, 5); // Show only 10 recent scores
    } else if (activeTab === 'best') {
      // Show top 50 best performances, or fallback to filtering from allScores
      if (allBestPerformances && allBestPerformances.length > 0) {
        return allBestPerformances.slice(0, 5); // Limit to 50 best scores
      }
      
      // Fallback: filter from allScores
      return allScores
        .filter(score => (score.calculated_rank || score.rank_position) <= 10)
        .sort((a, b) => {
          const rankA = a.calculated_rank || a.rank_position;
          const rankB = b.calculated_rank || b.rank_position;
          return rankA - rankB;
        })
        .slice(0, 50); // Limit to 50
    }
    return [];
  };

  const StaffBadge = ({ user }) => {
    const staffRole = STAFF_MEMBERS[user.id];
    
    if (!staffRole) return null;
    
    return (
      <div className={`staff-badge staff-badge-${staffRole.type}`}>
        {staffRole.label}
      </div>
    );
  };

  const isOwnProfile = currentUser && profileUser && currentUser.id === profileUser.id;

  if (authLoading || loading) {
    return (
      <Layout>
        <div className="min-h-screen py-4 sm:py-8">
          <div className="max-w-7xl mx-auto px-3 sm:px-4">
            <div className="space-y-4 sm:space-y-6">
              <div className="glass-1 rounded-2xl sm:rounded-3xl p-4 sm:p-8 animate-pulse">
                <div className="flex flex-col sm:flex-row items-center gap-4 sm:gap-6">
                  <div className="w-20 h-20 sm:w-32 sm:h-32 bg-white/20 rounded-xl sm:rounded-2xl"></div>
                  <div className="flex-1 space-y-3 sm:space-y-4 text-center sm:text-left">
                    <div className="h-6 sm:h-8 bg-white/20 rounded w-32 sm:w-1/3 mx-auto sm:mx-0"></div>
                    <div className="h-3 sm:h-4 bg-white/20 rounded w-24 sm:w-1/2 mx-auto sm:mx-0"></div>
                    <div className="flex gap-2 sm:gap-3 justify-center sm:justify-start">
                      <div className="h-4 sm:h-6 bg-white/20 rounded w-16 sm:w-20"></div>
                      <div className="h-4 sm:h-6 bg-white/20 rounded w-20 sm:w-24"></div>
                    </div>
                  </div>
                </div>
              </div>
              
              <div className="grid grid-cols-2 sm:grid-cols-4 gap-2 sm:gap-4">
                {[...Array(4)].map((_, i) => (
                  <div key={i} className="glass-1 rounded-lg sm:rounded-2xl p-3 sm:p-6 animate-pulse">
                    <div className="h-4 sm:h-8 bg-white/20 rounded mb-2 sm:mb-3"></div>
                    <div className="h-3 sm:h-6 bg-white/20 rounded w-2/3"></div>
                  </div>
                ))}
              </div>

              <div className="glass-1 rounded-xl sm:rounded-2xl p-4 sm:p-8 animate-pulse">
                <div className="space-y-3 sm:space-y-4">
                  {[...Array(5)].map((_, i) => (
                    <div key={i} className="h-12 sm:h-20 bg-white/20 rounded-lg sm:rounded-xl"></div>
                  ))}
                </div>
              </div>
            </div>
          </div>
        </div>
      </Layout>
    );
  }

  if (error || !profileUser) {
    return (
      <Layout>
        <div className="min-h-screen flex items-center justify-center px-3 sm:px-4">
          <div className="text-center max-w-sm sm:max-w-md">
            <div className="w-24 h-24 sm:w-32 sm:h-32 bg-gradient-to-br from-gray-200/60 to-gray-300/60 rounded-full flex items-center justify-center mx-auto mb-6 sm:mb-8 glass-2">
              <User className="w-12 h-12 sm:w-16 sm:h-16 text-white/70 icon-shadow-adaptive" />
            </div>
            <h2 className="text-xl sm:text-3xl font-bold text-white/90 mb-3 sm:mb-4 text-shadow-adaptive">
              {error || 'User Not Found'}
            </h2>
            <p className="text-sm sm:text-base text-white/70 mb-6 sm:mb-8 text-shadow-adaptive-sm">
              The user profile you're looking for doesn't exist or has been removed.
            </p>
            <div className="flex flex-col sm:flex-row gap-3 sm:gap-4 justify-center">
              <button
                onClick={() => router.back()}
                className="px-4 py-2 sm:px-6 sm:py-3 glass-2 hover:glass-3 text-white font-semibold rounded-full transition-all flex items-center gap-2 text-shadow-adaptive-sm justify-center"
              >
                <ArrowLeft className="w-4 h-4 icon-shadow-adaptive-sm" />
                Go Back
              </button>
              <Link 
                href="/"
                className="px-4 py-2 sm:px-6 sm:py-3 bg-gradient-to-r from-purple-500 to-pink-500 text-white font-semibold rounded-full hover:shadow-lg transform hover:scale-105 transition-all text-center"
              >
                Browse Challenges
              </Link>
            </div>
          </div>
        </div>
      </Layout>
    );
  }

  const scores = getScoresForTab();
  const milestone = getNextMilestone(stats?.totalScores || 0);

  return (
    <Layout>
      <div className="min-h-screen py-4 sm:py-8">
        <div className="max-w-7xl mx-auto px-3 sm:px-4">
          
          {/* Compact Header */}
          <div className="mb-4 sm:mb-8 flex items-center justify-between">
            <button
              onClick={() => router.back()}
              className="group flex items-center gap-2 text-white/70 hover:text-white/90 font-medium text-shadow-adaptive-sm transition-all text-sm sm:text-base"
            >
              <ArrowLeft className="w-4 h-4 group-hover:-translate-x-1 transition-transform icon-shadow-adaptive-sm" />
              Back
            </button>

            {/* Download Card Button */}
            {profileUser?.osu_id && (
              <div className="flex items-center gap-2">
                <button
                  onClick={() => handleDownloadCard('main')}
                  disabled={downloadingCard === 'main'}
                  className="px-3 py-2 sm:px-4 sm:py-2 glass-2 hover:glass-3 text-white font-medium rounded-full transition-all flex items-center gap-2 text-shadow-adaptive-sm text-xs sm:text-sm disabled:opacity-50 disabled:cursor-not-allowed"
                  title="Download Main Card"
                >
                  {downloadingCard === 'main' ? (
                    <Loader2 className="w-4 h-4 animate-spin icon-shadow-adaptive-sm" />
                  ) : (
                    <Download className="w-4 h-4 icon-shadow-adaptive-sm" />
                  )}
                  <span className="hidden sm:inline">Main Card</span>
                  <span className="sm:hidden">Main</span>
                </button>
                
                <button
                  onClick={() => handleDownloadCard('mini')}
                  disabled={downloadingCard === 'mini'}
                  className="px-3 py-2 sm:px-4 sm:py-2 glass-2 hover:glass-3 text-white font-medium rounded-full transition-all flex items-center gap-2 text-shadow-adaptive-sm text-xs sm:text-sm disabled:opacity-50 disabled:cursor-not-allowed"
                  title="Download Mini Card"
                >
                  {downloadingCard === 'mini' ? (
                    <Loader2 className="w-4 h-4 animate-spin icon-shadow-adaptive-sm" />
                  ) : (
                    <Image className="w-4 h-4 icon-shadow-adaptive-sm" />
                  )}
                  <span className="hidden sm:inline">Mini Card</span>
                  <span className="sm:hidden">Mini</span>
                </button>
              </div>
            )}
          </div>

         {/* Profile Hero Section */}
          <div className="relative overflow-hidden glass-2 rounded-2xl sm:rounded-3xl mb-6 sm:mb-8 shadow-2xl">
            <div className="absolute inset-0 opacity-10">
              <div className="absolute -top-4 -right-4 sm:-top-8 sm:-right-8 w-48 h-48 sm:w-96 sm:h-96 bg-white rounded-full blur-3xl animate-pulse-soft"></div>
              <div className="absolute -bottom-4 -left-4 sm:-bottom-8 sm:-left-8 w-40 h-40 sm:w-80 sm:h-80 bg-white rounded-full blur-3xl animate-pulse-soft" style={{ animationDelay: '1s' }}></div>
            </div>

            <div className="relative z-10 p-4 sm:p-8 text-white">
              <div className="flex flex-col lg:flex-row items-center lg:items-start gap-4 sm:gap-8">
                {/* Avatar and Basic Info */}
                <div className="flex flex-col sm:flex-row items-center gap-4 sm:gap-6 flex-1 w-full">
                  <div className="relative group">
                    {profileUser.avatar_url ? (
                      <img 
                        src={profileUser.avatar_url} 
                        alt={profileUser.username}
                        className="profile-picture w-20 h-20 sm:w-32 sm:h-32 rounded-2xl sm:rounded-3xl border-2 sm:border-4 border-white/30 shadow-2xl group-hover:scale-105 transition-transform avatar-border"
                      />
                    ) : (
                      <div className="profile-picture w-20 h-20 sm:w-32 sm:h-32 glass-3 rounded-2xl sm:rounded-3xl flex items-center justify-center border-2 sm:border-4 border-white/30 shadow-2xl">
                        <span className="text-2xl sm:text-5xl font-bold text-white text-shadow-adaptive">{profileUser.username[0]}</span>
                      </div>
                    )}
                    <div className="absolute -bottom-1 -right-1 sm:-bottom-3 sm:-right-3 w-6 h-6 sm:w-10 sm:h-10 bg-green-400 rounded-full border-2 sm:border-4 border-white flex items-center justify-center shadow-lg">
                      <div className="w-2 h-2 sm:w-4 sm:h-4 bg-green-600 rounded-full animate-pulse"></div>
                    </div>
                  </div>
                  
                  <div className="flex-1 min-w-0 text-center sm:text-left">
                    <div className="flex flex-col sm:flex-row items-center sm:items-start gap-2 sm:gap-4 mb-3 sm:mb-4">
                      <h1 className="text-2xl sm:text-4xl lg:text-5xl font-black text-white text-shadow-adaptive">
                        {profileUser.osu_id ? (
                          <a
                            href={`https://osu.ppy.sh/users/${profileUser.osu_id}`}
                            target="_blank"
                            rel="noopener noreferrer"
                            className="hover:text-white/80 transition-colors flex items-center gap-2 sm:gap-3 group"
                          >
                            {profileUser.username}
                            <ExternalLink className="w-4 h-4 sm:w-7 sm:h-7 opacity-60 group-hover:opacity-100 transition-opacity icon-shadow-adaptive" />
                          </a>
                        ) : (
                          profileUser.username
                        )}
                      </h1>
                    </div>
                    
                    <div className="flex flex-wrap items-center justify-center sm:justify-start gap-2 sm:gap-3">
                      {profileUser.country && (
                        <div className="flex items-center gap-1.5 sm:gap-2 px-2 py-1 sm:px-4 sm:py-2 glass-1 rounded-full">
                          {getCountryFlagUrl(profileUser.country) && (
                            <img 
                              src={getCountryFlagUrl(profileUser.country)} 
                              alt={`${profileUser.country} flag`}
                              className="w-4 h-3 sm:w-6 sm:h-4 object-cover rounded shadow-sm"
                            />
                          )}
                          <span className="font-medium text-white text-shadow-adaptive-sm text-xs sm:text-sm">{profileUser.country.toUpperCase()}</span>
                        </div>
                      )}
                      
                      <div className="px-2 py-1 sm:px-4 sm:py-2 glass-1 rounded-full flex items-center gap-1.5 sm:gap-2">
                        <Calendar className="w-3 h-3 sm:w-4 sm:h-4 icon-shadow-adaptive-sm" />
                        <span className="font-medium text-white text-shadow-adaptive-sm text-xs sm:text-sm">
                          Joined {new Date(profileUser.created_at || Date.now()).toLocaleDateString('en-US', { month: 'short', year: 'numeric' })}
                        </span>
                      </div>

                      <StaffBadge user={profileUser} />
                      
                    </div>
                  </div>
                </div>

                {/* Streak Display */}
                {streaks && (
                  <div className="flex gap-2 sm:gap-4 w-full sm:w-auto">
                    <div className="streak-card-current rounded-xl sm:rounded-2xl p-3 sm:p-6 min-w-0 flex-1 sm:min-w-[180px]">
                      <div className="flex items-center gap-1.5 sm:gap-2 mb-1 sm:mb-2">
                        <Flame className="w-4 h-4 sm:w-5 sm:h-5 text-white/90 icon-shadow-adaptive-sm" />
                        <span className="text-xs sm:text-sm font-medium text-white/90 text-shadow-adaptive-sm">Current</span>
                      </div>
                      <div className="flex items-baseline gap-1 sm:gap-2">
                        <span className="text-2xl sm:text-4xl font-black text-white/70 text-shadow-adaptive">{streaks.currentStreak}</span>
                      </div>
                    </div>
                    
                    <div className="streak-card-best rounded-xl sm:rounded-2xl p-3 sm:p-6 min-w-0 flex-1 sm:min-w-[180px]">
                      <div className="flex items-center gap-1.5 sm:gap-2 mb-1 sm:mb-2">
                        <Crown className="w-4 h-4 sm:w-5 sm:h-5 text-white/90 icon-shadow-adaptive-sm" />
                        <span className="text-xs sm:text-sm font-medium text-white/90 text-shadow-adaptive-sm">Best</span>
                      </div>
                      <div className="flex items-baseline gap-1 sm:gap-2">
                        <span className="text-2xl sm:text-4xl font-black text-white/70 text-shadow-adaptive">{streaks.longestStreak}</span>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </div>
          </div>

          {/* Quick Stats Grid */}
          <div className="grid grid-cols-2 sm:grid-cols-4 gap-2 sm:gap-4 mb-6 sm:mb-8">
            <div className="glass-1 rounded-lg sm:rounded-2xl p-3 sm:p-6">
              <div className="flex flex-col sm:flex-row items-center sm:justify-between gap-2 sm:gap-0 mb-2 sm:mb-3">
                <div className="p-1.5 sm:p-3 icon-gradient-purple rounded-md sm:rounded-xl icon-container-purple">
                  <Target className="w-4 h-4 sm:w-6 sm:h-6 text-white" />
                </div>
                <span className="text-lg sm:text-3xl font-black text-white/80">
                  {stats?.avgAccuracy ? `${stats.avgAccuracy}%` : '--%'}
                </span>
              </div>
              <p className="text-xs sm:text-sm font-medium text-white text-shadow-adaptive-sm text-center sm:text-left">Avg Accuracy</p>
            </div>
            
            <div className="glass-1 rounded-lg sm:rounded-2xl p-3 sm:p-6">
              <div className="flex flex-col sm:flex-row items-center sm:justify-between gap-2 sm:gap-0 mb-2 sm:mb-3">
                <div className="p-1.5 sm:p-3 icon-gradient-green rounded-md sm:rounded-xl icon-container-green">
                  <Activity className="w-4 h-4 sm:w-6 sm:h-6 text-white" />
                </div>
                <span className="text-lg sm:text-3xl font-black text-white/80">
                  #{stats?.avgRank || '--'}
                </span>
              </div>
              <p className="text-xs sm:text-sm font-medium text-white text-shadow-adaptive-sm text-center sm:text-left">Avg Rank</p>
            </div>
            
            <div className="glass-1 rounded-lg sm:rounded-2xl p-3 sm:p-6">
              <div className="flex flex-col sm:flex-row items-center sm:justify-between gap-2 sm:gap-0 mb-2 sm:mb-3">
                <div className="p-1.5 sm:p-3 icon-gradient-blue rounded-md sm:rounded-xl icon-container-blue">
                  <BarChart3 className="w-4 h-4 sm:w-6 sm:h-6 text-white" />
                </div>
                <span className="text-lg sm:text-3xl font-black text-white/80">
                  {stats?.totalScores || 0}
                </span>
              </div>
              <p className="text-xs sm:text-sm font-medium text-white text-shadow-adaptive-sm text-center sm:text-left">Total Plays</p>
            </div>
            
            <div className="glass-1 rounded-lg sm:rounded-2xl p-3 sm:p-6">
              <div className="flex flex-col sm:flex-row items-center sm:justify-between gap-2 sm:gap-0 mb-2 sm:mb-3">
                <div className="p-1.5 sm:p-3 icon-gradient-orange rounded-md sm:rounded-xl icon-container-orange">
                  <Trophy className="w-4 h-4 sm:w-6 sm:h-6 text-white" />
                </div>
                <span className="text-lg sm:text-3xl font-black text-white/80">
                  {stats?.firstPlaceCount || 0}
                </span>
              </div>
              <p className="text-xs sm:text-sm font-medium text-white text-shadow-adaptive-sm text-center sm:text-left">First Places</p>
            </div>
          </div>
          {/* Tab System */}
          <div className="mb-4 sm:mb-6">
            <div className="view-mode-slider text-sm sm:text-base">
              <div className="slider-track">
                <div className={`slider-thumb ${
                  activeTab === 'best' ? 'slider-thumb-second' : 
                  activeTab === 'stats' ? 'slider-thumb-third' :
                  activeTab === 'achievements' ? 'slider-thumb-fourth' : ''
                }`} />
                <button
                  onClick={() => handleTabChange('recent')}
                  className={`slider-option ${activeTab === 'recent' ? 'slider-option-active' : ''}`}
                >
                  <span className="hidden sm:inline">Recent Scores</span>
                  <span className="sm:hidden">Recent</span>
                </button>
                <button
                  onClick={() => handleTabChange('best')}
                  className={`slider-option ${activeTab === 'best' ? 'slider-option-active' : ''}`}
                >
                  <span className="hidden sm:inline">Best Performances</span>
                  <span className="sm:hidden">Best</span>
                </button>
                <button
                  onClick={() => handleTabChange('stats')}
                  className={`slider-option ${activeTab === 'stats' ? 'slider-option-active' : ''}`}
                >
                  Statistics
                </button>
                <button
                  onClick={() => handleTabChange('achievements')}
                  className={`slider-option ${activeTab === 'achievements' ? 'slider-option-active' : ''}`}
                >
                  Medals
                </button>
              </div>
            </div>
          </div>

          {/* Tab Content */}
          {tabLoading ? (
            <div className="glass-1 rounded-2xl sm:rounded-3xl p-8 sm:p-12 text-center">
              <Loader2 className="w-6 h-6 sm:w-8 sm:h-8 animate-spin text-white/70 mx-auto mb-3 sm:mb-4 icon-shadow-adaptive" />
              <p className="text-white/70 text-shadow-adaptive-sm text-sm sm:text-base">Loading...</p>
            </div>
          ) : (
            <>
              {/* Recent/Best Scores Tabs */}
              {(activeTab === 'recent' || activeTab === 'best') && (
                <div>
                  {scores.length === 0 ? (
                    <div className="glass-1 rounded-2xl sm:rounded-3xl p-8 sm:p-16 text-center shadow-lg">
                      <div className="w-16 h-16 sm:w-24 sm:h-24 bg-gradient-to-br from-purple-500/30 to-pink-500/30 rounded-full flex items-center justify-center mx-auto mb-4 sm:mb-6 glass-3">
                        <Trophy className="w-8 h-8 sm:w-12 sm:h-12 text-purple-200 icon-shadow-adaptive" />
                      </div>
                      <h3 className="text-lg sm:text-2xl font-bold text-white/90 mb-3 sm:mb-4 text-shadow-adaptive">
                        {activeTab === 'recent' ? 'No Scores Yet' : 'No Top Performances Yet'}
                      </h3>
                      <p className="text-sm sm:text-base text-white/70 mb-6 sm:mb-8 max-w-sm sm:max-w-md mx-auto text-shadow-adaptive-sm">
                        {activeTab === 'recent' 
                          ? (isOwnProfile 
                              ? "Start participating in challenges to build your profile!" 
                              : `${profileUser.username} hasn't participated in any challenges yet.`)
                          : "Keep playing to earn your spot in the top rankings!"
                        }
                      </p>
                      {isOwnProfile && activeTab === 'recent' && (
                        <Link 
                          href="/"
                          className="inline-flex items-center gap-2 px-6 py-3 sm:px-8 sm:py-4 bg-gradient-to-r from-purple-500 to-pink-500 text-white font-semibold rounded-full hover:shadow-lg transform hover:scale-105 transition-all text-sm sm:text-base"
                        >
                          Browse Challenges
                          <ChevronRight className="w-4 h-4 sm:w-5 sm:h-5" />
                        </Link>
                      )}
                    </div>
                  ) : (
                    <div className="space-y-3 sm:space-y-4">
                      {scores.map((score) => (
                        <div 
                          key={score.id}
                          className="glass-1 rounded-xl sm:rounded-2xl p-4 sm:p-6 transition-all group hover:glass-2"
                        >
                          <div className="flex items-start justify-between gap-3 sm:gap-4">
                            <div className="flex-1 min-w-0">
                              <div className="flex items-start gap-3 sm:gap-4">
                                {/* Rank Badge */}
                                <div className={`w-10 h-10 sm:w-16 sm:h-16 rounded-lg sm:rounded-2xl bg-gradient-to-b ${getRankGradient(score.calculated_rank || 0)} flex items-center justify-center shadow-lg transition-transform`} style={{
                                  border: '3px solid rgba(255, 255, 255, 0.6)',
                                  boxShadow: '0 0 8px rgba(255, 255, 255, 0.3), 0 4px 8px rgba(0, 0, 0, 0.2)'
                                }}>
                                  <span className="text-white font-black text-sm sm:text-xl text-shadow-adaptive">
                                    #{score.calculated_rank || '?'}
                                  </span>
                                </div>
                                <div className="flex-1 min-w-0">
                                  <h4 className="text-sm sm:text-lg font-bold text-white mb-1 group-hover:text-purple-300 transition-colors text-shadow-adaptive truncate">
                                    {score.playlists?.beatmap_title || 'Unknown Beatmap'}
                                  </h4>
                                  <div className="flex items-center gap-2 sm:gap-3 text-xs sm:text-sm text-white/80 mb-2 sm:mb-3 text-shadow-adaptive-sm">
                                    <span className="flex items-center gap-1 truncate">
                                      <Music className="w-3 h-3 sm:w-4 sm:h-4 text-white/90 icon-shadow-adaptive-sm flex-shrink-0" />
                                      <span className="truncate">{score.playlists?.challenges?.name || 'Unknown Challenge'}</span>
                                    </span>
                                    <span className="hidden sm:inline">‚Ä¢</span>
                                    <span className="text-xs sm:text-sm whitespace-nowrap">
                                      {new Date(score.submitted_at).toLocaleDateString('en-US', { 
                                        month: 'short', 
                                        day: 'numeric'
                                      })}
                                    </span>
                                  </div>
                                  
                                  {/* Score Details */}
                                  <div className="flex flex-wrap items-center gap-3 sm:gap-6">
                                    <div className="flex items-center gap-1 sm:gap-2">
                                      <span className="text-xs sm:text-sm text-white/80 text-shadow-adaptive-sm">Score:</span>
                                      <span className="font-mono font-bold text-white text-shadow-adaptive text-sm sm:text-base">
                                        {formatNumber(score.score)}
                                      </span>
                                    </div>
                                    <div className="flex items-center gap-1 sm:gap-2">
                                      <span className="text-xs sm:text-sm text-white/80 text-shadow-adaptive-sm">Acc:</span>
                                      <span className="font-bold text-white text-shadow-adaptive text-sm sm:text-base">
                                        {score.accuracy.toFixed(1)}%
                                      </span>
                                    </div>
                                    <div className="flex items-center gap-1 sm:gap-2">
                                      <span className="text-xs sm:text-sm text-white/80 text-shadow-adaptive-sm">Combo:</span>
                                      <span className="font-bold text-white text-shadow-adaptive text-sm sm:text-base">{score.max_combo}x</span>
                                    </div>
                                  </div>
                                </div>
                              </div>
                            </div>
                            
                            {/* View Button */}
                            {score.playlists?.challenges?.room_id && (
                              <Link 
                                href={`/challenges/${score.playlists.challenges.room_id}`}
                                className="px-3 py-1.5 sm:px-4 sm:py-2 glass-1 hover:glass-2 text-white font-medium rounded-full transition-all flex items-center gap-1.5 sm:gap-2 group-hover:shadow-md text-shadow-adaptive-sm text-xs sm:text-sm whitespace-nowrap"
                              >
                                View
                                <ChevronRight className="w-3 h-3 sm:w-4 sm:h-4 icon-shadow-adaptive-sm" />
                              </Link>
                            )}
                          </div>
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              )}

              {/* Statistics Tab */}
              {activeTab === 'stats' && (
              <div className="space-y-6 sm:space-y-8">
                <div className="glass-1 rounded-2xl sm:rounded-3xl p-4 sm:p-8 shadow-lg">
                  <h3 className="text-lg sm:text-2xl font-bold text-white mb-4 sm:mb-6 flex items-center gap-2 sm:gap-3 text-shadow-adaptive">
                    <BarChart3 className="w-6 h-6 sm:w-8 sm:h-8 text-white/90 icon-shadow-adaptive" />
                    <span>Statistics</span>
                  </h3>
                  
                  <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 sm:gap-8">
                    {/* Performance Overview */}
                    <div>
                      <h4 className="text-base sm:text-lg font-semibold text-white mb-3 sm:mb-4 text-shadow-adaptive">Performance Overview</h4>
                      <div className="space-y-3 sm:space-y-4">
                        <div className="glass-1 rounded-lg sm:rounded-xl p-3 sm:p-4">
                          <div className="flex items-center justify-between">
                            <span className="font-medium text-white text-shadow-adaptive text-sm sm:text-base">Total Maps Played</span>
                            <span className="text-lg sm:text-xl font-bold text-white text-shadow-adaptive">{stats?.totalScores || 0}</span>
                          </div>
                        </div>
                        <div className="glass-1 rounded-lg sm:rounded-xl p-3 sm:p-4">
                          <div className="flex items-center justify-between">
                            <span className="font-medium text-white text-shadow-adaptive text-sm sm:text-base">Average Score</span>
                            <span className="text-lg sm:text-xl font-bold text-white text-shadow-adaptive">
                              {stats?.avgScore ? formatNumber(stats.avgScore) : '###.#K'}
                            </span>
                          </div>
                        </div>
                        <div className="glass-1 rounded-lg sm:rounded-xl p-3 sm:p-4">
                          <div className="flex items-center justify-between">
                            <span className="font-medium text-white text-shadow-adaptive text-sm sm:text-base">Perfect Scores (100%)</span>
                            <span className="text-lg sm:text-xl font-bold text-white text-shadow-adaptive">
                              {stats?.perfectScoreCount || 0}
                            </span>
                          </div>
                        </div>
                      </div>
                    </div>
                    {/* Rank Distribution */}
                    <div>
                      <h4 className="text-base sm:text-lg font-semibold text-white mb-3 sm:mb-4 text-shadow-adaptive">Rank Distribution</h4>
                      <div className="space-y-3">
                        {/* 2-3 ranks: Red gradient */}
                        <div className="flex items-center gap-2 sm:gap-3">
                          <div className="w-8 h-8 sm:w-12 sm:h-12 rounded-lg sm:rounded-xl flex items-center justify-center" style={{
                            background: 'linear-gradient(to bottom, #d35656, #a93838)',
                            border: '3px solid #e3716b'
                          }}>
                            <span className="text-white font-bold text-xs sm:text-sm text-shadow-adaptive-sm">2-3</span>
                          </div>
                          <div className="flex-1 glass-1 rounded-full h-6 sm:h-8 relative overflow-hidden" style={{ padding: '1px' }}>
                            <div 
                              className="absolute rounded-full"
                              style={{ 
                                top: '1px',
                                bottom: '1px',
                                left: '1px',
                                width: `${Math.min((stats?.rankDistribution?.topThree || 0) / (stats?.totalScores || 1) * 100, 100)}%`,
                                background: 'linear-gradient(to bottom, #d35656, #a93838)',
                                border: '3px solid #e3716b',
                                maxWidth: 'calc(100% - 2px)'
                              }}
                            >
                            </div>
                          </div>
                        </div>
                        
                        {/* 4-10 ranks: Gray gradient */}
                        <div className="flex items-center gap-2 sm:gap-3">
                          <div className="w-8 h-8 sm:w-12 sm:h-12 rounded-lg sm:rounded-xl flex items-center justify-center" style={{
                            background: 'linear-gradient(to bottom, #777778, #545455)',
                            border: '3px solid #959595'
                          }}>
                            <span className="text-white font-bold text-xs sm:text-sm text-shadow-adaptive-sm">4-10</span>
                          </div>
                          <div className="flex-1 glass-1 rounded-full h-6 sm:h-8 relative overflow-hidden" style={{ padding: '1px' }}>
                            <div 
                              className="absolute rounded-full"
                              style={{ 
                                top: '1px',
                                bottom: '1px',
                                left: '1px',
                                width: `${Math.min((stats?.rankDistribution?.topTen || 0) / (stats?.totalScores || 1) * 100, 100)}%`,
                                background: 'linear-gradient(to bottom, #777778, #545455)',
                                border: '3px solid #959595',
                                maxWidth: 'calc(100% - 2px)'
                              }}
                            >
                            </div>
                          </div>
                        </div>
                        
                        {/* 11+ ranks: Purple gradient */}
                        <div className="flex items-center gap-2 sm:gap-3">
                          <div className="w-8 h-8 sm:w-12 sm:h-12 rounded-lg sm:rounded-xl flex items-center justify-center" style={{
                            background: 'linear-gradient(to bottom, #9f5dbf, #6d3f87)',
                            border: '3px solid #a77bc3'
                          }}>
                            <span className="text-white font-bold text-xs sm:text-sm text-shadow-adaptive-sm">11+</span>
                          </div>
                          <div className="flex-1 glass-1 rounded-full h-6 sm:h-8 relative overflow-hidden" style={{ padding: '1px' }}>
                            <div 
                              className="absolute rounded-full"
                              style={{ 
                                top: '1px',
                                bottom: '1px',
                                left: '1px',
                                width: `${Math.min((stats?.rankDistribution?.other || 0) / (stats?.totalScores || 1) * 100, 100)}%`,
                                background: 'linear-gradient(to bottom, #9f5dbf, #6d3f87)',
                                border: '3px solid #a77bc3',
                                maxWidth: 'calc(100% - 2px)'
                              }}
                            >
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>

                  {/* Full-width separator that actually goes to the edges */}
                  <div className="my-6 sm:my-8 -mx-4 sm:-mx-8">
                    <div className="w-full h-px bg-white/30"></div>
                  </div>
                  
                  {/* Monthly Activity */}
                  <div>
                    <h4 className="text-base sm:text-lg font-semibold text-white mb-3 sm:mb-4 text-shadow-adaptive">Monthly Activity</h4>
                    <div className="grid grid-cols-2 sm:grid-cols-4 gap-3 sm:gap-4">
                      {stats?.monthlyActivity && Object.entries(stats.monthlyActivity).slice(-4).map(([month, count]) => (
                        <div key={month} className="text-center p-3 sm:p-4 glass-1 rounded-lg sm:rounded-xl">
                          <p className="text-xs sm:text-sm text-white/80 mb-1 text-shadow-adaptive-sm">{month}</p>
                          <p className="text-xl sm:text-2xl font-bold text-white text-shadow-adaptive">{count}</p>
                          <p className="text-xs text-white/70 mt-1 text-shadow-adaptive-sm">plays</p>
                        </div>
                      ))}
                      {(!stats?.monthlyActivity || Object.keys(stats.monthlyActivity).length === 0) && (
                        <div className="col-span-full text-center py-6 sm:py-8 text-white/70 text-shadow-adaptive-sm text-sm sm:text-base">
                          No activity data available
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              </div>
            )}
            {activeTab === 'achievements' && (
              <MedalsDisplay 
                stats={stats}
                streaks={streaks} 
                scores={allScores}
                userAchievements={[]} // This would come from existing user data if you store it
                seasonRank={null} // Can be calculated from existing season data
                seasonPercentile={null} // Can be calculated from existing season data
              />
            )}
            </>
          )}

          {/* Achievement Showcase */}
          {stats?.firstPlaceCount > 0 && (
            <div className="mt-6 sm:mt-8 relative overflow-hidden glass-1 rounded-2xl sm:rounded-3xl p-4 sm:p-8 shadow-lg">
              <div className="relative z-10">
                <h3 className="text-lg sm:text-2xl font-bold text-white mb-4 sm:mb-6 flex items-center gap-2 sm:gap-3 text-shadow-adaptive">
                  <Trophy className="w-6 h-6 sm:w-8 sm:h-8 text-white/90 icon-shadow-adaptive" />
                  Trophy Cabinet
                </h3>
                
                <div className="grid grid-cols-2 sm:grid-cols-4 gap-3 sm:gap-4">
                  <div className="rounded-lg sm:rounded-xl p-4 sm:p-6 text-center shadow-lg" style={{
                    background: 'linear-gradient(to bottom, rgba(66, 101, 196, 0.9), rgba(52, 87, 171, 0.9))',
                    border: '3px solid #5f94ec'
                  }}>
                    <Award className="w-8 h-8 sm:w-12 sm:h-12 text-white mx-auto mb-2 sm:mb-3 icon-shadow-adaptive" />
                    <p className="text-2xl sm:text-3xl font-black text-white/50 mb-1 text-shadow-adaptive">
                      {stats?.podiumCount || 0}
                    </p>
                    <p className="text-xs sm:text-sm font-medium text-white/80 text-shadow-adaptive-sm">Podium Finishes</p>
                  </div>
                  
                  <div className="rounded-lg sm:rounded-xl p-4 sm:p-6 text-center shadow-lg" style={{
                    background: 'linear-gradient(to bottom, rgba(181, 64, 67, 0.9), rgba(163, 48, 49, 0.9))',
                    border: '3px solid #dd615e'
                  }}>
                    <Star className="w-8 h-8 sm:w-12 sm:h-12 text-white mx-auto mb-2 sm:mb-3 icon-shadow-adaptive" />
                    <p className="text-2xl sm:text-3xl font-black text-white/50 mb-1 text-shadow-adaptive">
                      {stats?.top10Count || 0}
                    </p>
                    <p className="text-xs sm:text-sm font-medium text-white/80 text-shadow-adaptive-sm">Top 10 Finishes</p>
                  </div>
                  
                  <div className="rounded-lg sm:rounded-xl p-4 sm:p-6 text-center shadow-lg" style={{
                    background: 'linear-gradient(to bottom, rgba(94, 93, 94, 0.9), rgba(76, 75, 76, 0.9))',
                    border: '3px solid #a1a1a1'
                  }}>
                    <Zap className="w-8 h-8 sm:w-12 sm:h-12 text-white mx-auto mb-2 sm:mb-3 icon-shadow-adaptive" />
                    <p className="text-2xl sm:text-3xl font-black text-white/50 mb-1 text-shadow-adaptive">
                      {stats?.highAccuracyCount || 0}
                    </p>
                    <p className="text-xs sm:text-sm font-medium text-white/80 text-shadow-adaptive-sm">98%+ Accuracy</p>
                  </div>
                  
                  <div className="rounded-lg sm:rounded-xl p-4 sm:p-6 text-center shadow-lg" style={{
                    background: 'linear-gradient(to bottom, rgba(60, 166, 97, 0.9), rgba(45, 141, 99, 0.9))',
                    border: '3px solid #4ed484'
                  }}>
                    <Trophy className="w-8 h-8 sm:w-12 sm:h-12 text-white mx-auto mb-2 sm:mb-3 icon-shadow-adaptive" />
                    <p className="text-2xl sm:text-3xl font-black text-white/50 mb-1 text-shadow-adaptive">
                      {stats?.firstPlaceCount || 0}
                    </p>
                    <p className="text-xs sm:text-sm font-medium text-white/80 text-shadow-adaptive-sm">First Places</p>
                  </div>
                </div>
              </div>
            </div>
          )}
          {/* Progress & Milestones Section */}
          {allScores.length > 0 && (
            <div className="mt-6 sm:mt-8 relative overflow-hidden glass-1 rounded-2xl sm:rounded-3xl p-4 sm:p-8 shadow-lg">
              <div className="relative z-10">
                <h3 className="text-lg sm:text-2xl font-bold text-white mb-4 sm:mb-6 flex items-center gap-2 sm:gap-3 text-shadow-adaptive">
                  <TrendingUp className="w-6 h-6 sm:w-8 sm:h-8 text-white/90 icon-shadow-adaptive" />
                  Progress & Insights
                </h3>
                <div className="grid grid-cols-1 sm:grid-cols-3 gap-4 sm:gap-6">
                  <div className="glass-1 rounded-lg sm:rounded-xl p-4 sm:p-6">
                    <p className="text-xs sm:text-sm font-medium text-white/90 mb-2 text-shadow-adaptive-sm">Most Active Month</p>
                    <p className="text-base sm:text-lg font-bold text-white/90 text-shadow-adaptive">
                      {stats?.monthlyActivity && Object.keys(stats.monthlyActivity).length > 0 
                        ? Object.entries(stats.monthlyActivity).sort((a, b) => b[1] - a[1])[0]?.[0] || 'N/A'
                        : 'N/A'
                      }
                    </p>
                    <p className="text-xs sm:text-sm text-white mt-1 text-shadow-adaptive-sm">
                      {stats?.monthlyActivity && Object.keys(stats.monthlyActivity).length > 0
                        ? `${Object.entries(stats.monthlyActivity).sort((a, b) => b[1] - a[1])[0]?.[1] || 0} plays`
                        : '0 plays'
                      }
                    </p>
                  </div>
                  <div className="glass-1 rounded-lg sm:rounded-xl p-4 sm:p-6">
                    <p className="text-xs sm:text-sm font-medium text-white/90 mb-2 text-shadow-adaptive-sm">Total Score Points</p>
                    <p className="text-base sm:text-lg font-bold text-white/90 text-shadow-adaptive">
                      {formatNumber(stats?.totalScorePoints || 0)}
                    </p>
                    <p className="text-xs sm:text-sm text-white mt-1 text-shadow-adaptive-sm">Lifetime total</p>
                  </div>
                  <div className="glass-1 rounded-lg sm:rounded-xl p-4 sm:p-6">
                    <p className="text-xs sm:text-sm font-medium text-white/90 mb-2 text-shadow-adaptive-sm">Next Milestone</p>
                    <p className="text-base sm:text-lg font-bold text-white/90 text-shadow-adaptive">
                      {milestone.title}
                    </p>
                    <p className="text-xs sm:text-sm text-white mt-1 text-shadow-adaptive-sm">
                      {milestone.isLegend ? 'Achieved!' : `${milestone.remaining} to go`}
                    </p>
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>
    </Layout>
  );
}

export async function getServerSideProps() {
  return {
    props: {}
  };
}


================================================
FILE: frontend/public/site.webmanifest
================================================
{"name":"","short_name":"","icons":[{"src":"/android-chrome-192x192.png","sizes":"192x192","type":"image/png"},{"src":"/android-chrome-512x512.png","sizes":"512x512","type":"image/png"}],"theme_color":"#ffffff","background_color":"#ffffff","display":"standalone"}


================================================
FILE: frontend/public/fonts/Inter-Bold.ttf
================================================
[Binary file]


================================================
FILE: frontend/public/fonts/Inter-ExtraBold.ttf
================================================
[Binary file]


================================================
FILE: frontend/public/fonts/Inter.ttf
================================================
[Binary file]


================================================
FILE: frontend/styles/globals.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
    html {
      height: 100%;
      overflow-x: hidden;
    }

    body {
      @apply bg-neutral-900 text-neutral-800;
      position: relative;
      min-height: 100vh;
      min-height: -webkit-fill-available;
      overscroll-behavior-y: none;
    }
    
    * {
      @apply scroll-smooth;
    }
  }

  @layer utilities {
    .min-h-screen {
      min-height: 100vh; /* Fallback */
      min-height: 100svh;
    }
}

@layer components {
  
  /* ============================================
     GLASS EFFECTS
     ============================================ */
  
  .glass-1 {
    background: rgba(255, 255, 255, 0.20);
    border: 3px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.07), 0 0 10px rgba(255, 255, 255, 0.1);
  }
  
  .glass-2 {
    background: rgba(255, 255, 255, 0.25);
    border: 3px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.1), 0 0 10px rgba(255, 255, 255, 0.125);
  }
  
  .glass-3 {
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
    background: rgba(255, 255, 255, 0.30);
    border: 3px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15), 0 0 10px rgba(255, 255, 255, 0.15);
  }
  
  .glass-4 {
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    background: rgba(255, 255, 255, 0.35);
    border: 3px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.2), 0 0 10px rgba(255, 255, 255, 0.2);
  }

  /* Glass Hover Effects */
  .glass-hover:hover {
    background: rgba(255, 255, 255, 0.40);
    border-color: rgba(255, 255, 255, 0.30);
    box-shadow: 0 12px 40px 0 rgba(31, 38, 135, 0.15);
    transition: all 0.3s ease;
  }

  /* Special Glass Variants */
  .glass-dark {
    background: rgba(0, 0, 0, 0.20);
    border: 1px solid rgba(255, 255, 255, 0.10);
  }
  
  .glass-primary {
    background: rgba(236, 72, 153, 0.10);
    border: 1px solid rgba(236, 72, 153, 0.20);
  }

  /* ============================================
     NAVIGATION
     ============================================ */
  
  .nav-pill {
    @apply px-5 py-2.5 rounded-full font-medium transition-all duration-300;
  }
  
  .nav-pill-active {
    @apply nav-pill;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    background: rgba(255, 255, 255, 0.35);
    color: white;
    border: 3px solid rgba(255, 255, 255, 0.6);
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3);
  }
  
  .nav-pill-inactive {
    @apply nav-pill;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    background: rgba(255, 255, 255, 0.15);
    color: rgba(255, 255, 255, 0.9);
    border: 3px solid transparent;
  }
  
  .nav-pill-inactive:hover {
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    background: rgba(255, 255, 255, 0.35);
    color: white;
    border: 3px solid rgba(255, 255, 255, 0.8);
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2);
  }

  .nav-pill-more {
    @apply px-3 py-2 lg:px-4 lg:py-2.5 rounded-full font-medium transition-all duration-300 text-sm lg:text-base;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    background: rgba(255, 255, 255, 0.10);
    color: rgba(255, 255, 255, 0.85);
    border: 2px dashed rgba(255, 255, 255, 0.3);
  }

  .nav-pill-more:hover {
    background: rgba(255, 255, 255, 0.20);
    color: white;
    border: 2px dashed rgba(255, 255, 255, 0.5);
  }

  .nav-pill-more-active {
    background: rgba(255, 255, 255, 0.25);
    color: white;
    border: 2px dashed rgba(255, 255, 255, 0.6);
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2);
  }

  .nav-pill {
    @apply px-3 py-2 lg:px-5 lg:py-2.5 rounded-full font-medium transition-all duration-300 text-sm lg:text-base;
  }

  .nav-pill-active {
    @apply nav-pill;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    background: rgba(255, 255, 255, 0.35);
    color: white;
    border: 3px solid rgba(255, 255, 255, 0.6);
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3);
  }

  .nav-pill-inactive {
    @apply nav-pill;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    background: rgba(255, 255, 255, 0.15);
    color: rgba(255, 255, 255, 0.9);
    border: 3px solid transparent;
  }

  .nav-pill-inactive:hover {
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    background: rgba(255, 255, 255, 0.35);
    color: white;
    border: 3px solid rgba(255, 255, 255, 0.8);
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2);
  }

  /* ============================================
     BUTTONS
     ============================================ */
  
  .btn-primary {
    @apply px-6 py-3 rounded-full font-semibold transition-all duration-300;
    color: white;
    background: linear-gradient(to bottom, #b43b77, #8f2f5d);
    border: 3px solid rgba(244, 114, 182, 1);
  }

  .btn-primary:hover {
    background: linear-gradient(to bottom, #c44287, #9f3f6d);
    border: 3px solid rgba(244, 114, 182, 1);
    transform: translateY(-2px);
  }
  
  .btn-secondary {
    @apply px-6 py-3 rounded-full font-semibold transition-all duration-300;
    background: rgba(255, 255, 255, 0.30);
    color: white;
    border: 3px solid transparent;
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.15);
  }
  
  .btn-secondary:hover {
    background: rgba(255, 255, 255, 0.30);
    color: white;
    border: 3px solid rgba(255, 255, 255, 0.8);
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3);
    transform: translateY(-2px);
  }

  /* ============================================
     CARD COMPONENTS
     ============================================ */
  
  .challenge-card {
    background: rgba(255, 255, 255, 0.25);
    border: 3px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.1);
    border-radius: 1rem;
    padding: 1.5rem;
    transition: all 0.3s ease;
  }
  
  .challenge-card:hover {
    transform: scale(1.02);
    box-shadow: 0 12px 40px 0 rgba(31, 38, 135, 0.15);
  }
  
  .stat-card {
    background: rgba(255, 255, 255, 0.30);
    border: 3px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
    border-radius: 0.75rem;
    padding: 1rem;
    text-align: center;
  }
  
  .leaderboard-item {
    background: rgba(255, 255, 255, 0.20);
    border: 3px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.07);
    border-radius: 0.75rem;
    padding: 1rem 1.5rem;
    transition: all 0.2s ease;
  }
  
  .leaderboard-item:hover {
    background: rgba(255, 255, 255, 0.25);
    transform: scale(1.01);
  }

  /* ============================================
     INFO CARDS
     ============================================ */
  
  .info-card {
    background: rgba(255, 255, 255, 0.30);
    border: 3px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
    border-radius: 1rem;
    padding: 1.5rem;
    transition: all 0.3s ease;
  }
  
  .info-card:hover {
    box-shadow: 0 12px 40px 0 rgba(31, 38, 135, 0.2);
    transform: scale(1.02);
  }
  
  .icon-wrapper {
    @apply p-3 rounded-xl inline-flex;
  }
  
  .icon-gradient-orange {
    background: linear-gradient(to bottom, #f6b026, #d9703f);
  }
  
  .icon-gradient-blue {
    background: linear-gradient(to bottom, #16adda, #2f89ef);
  }
  
  .icon-gradient-green {
    background: linear-gradient(to bottom, #22c065, #16a66d);
  }
  
  .icon-gradient-purple {
    background: linear-gradient(to bottom, #b666d2, #9d6bb3);
  }
  
  .icon-gradient-red {
    background: linear-gradient(to bottom, #ef4444, #dc2626);
  }
  
  .icon-gradient-dark-purple {
    background: linear-gradient(to bottom, #9f5dbf, #6d3f87);
  }

  /* ============================================
     PODIUM CARDS
     ============================================ */
  
  .podium-card {
    background: rgba(255, 255, 255, 0.30);
    border: 3px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
    border-radius: 1rem;
    padding: 1.5rem;
    text-align: center;
    transform-origin: center;
    transition: all 0.3s ease;
  }
  
  .podium-card:hover {
    transform: scale(1.05);
    box-shadow: 0 16px 48px 0 rgba(31, 38, 135, 0.2);
  }
  
  .podium-1st {
    background: linear-gradient(to bottom right, rgba(191, 219, 254, 0.6), rgba(147, 197, 253, 0.6));
    border-color: rgba(147, 197, 253, 0.5);
  }
  
  .podium-2nd {
    background: linear-gradient(to bottom right, rgba(233, 213, 255, 0.6), rgba(196, 181, 253, 0.6));
    border-color: rgba(196, 181, 253, 0.5);
  }
  
  .podium-3rd {
    background: linear-gradient(to bottom right, rgba(254, 202, 202, 0.6), rgba(252, 165, 165, 0.6));
    border-color: rgba(252, 165, 165, 0.5);
  }

  /* ============================================
     DIFFICULTY BADGES
     ============================================ */
  
  .difficulty-badge {
    @apply px-3 py-1 rounded-full text-xs font-semibold border;
  }
  
  .difficulty-easy {
    background: rgba(187, 247, 208, 0.8);
    color: #166534;
    border-color: rgba(134, 239, 172, 0.5);
  }
  
  .difficulty-normal {
    background: rgba(191, 219, 254, 0.8);
    color: #1e3a8a;
    border-color: rgba(147, 197, 253, 0.5);
  }
  
  .difficulty-hard {
    background: rgba(254, 240, 138, 0.8);
    color: #713f12;
    border-color: rgba(253, 224, 71, 0.5);
  }
  
  .difficulty-insane {
    background: rgba(254, 215, 170, 0.8);
    color: #7c2d12;
    border-color: rgba(251, 146, 60, 0.5);
  }
  
  .difficulty-expert {
    background: rgba(254, 202, 202, 0.8);
    color: #7f1d1d;
    border-color: rgba(252, 165, 165, 0.5);
  }
  
  .difficulty-extreme {
    background: rgba(233, 213, 255, 0.8);
    color: #581c87;
    border-color: rgba(196, 181, 253, 0.5);
  }

  /* ============================================
     DROPDOWN/SELECT
     ============================================ */
  
  .select-glass {
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    background: rgba(255, 255, 255, 0.30);
    border: 3px solid rgba(255, 255, 255, 0.2);
    border-radius: 9999px;
    padding: 0.5rem 2.5rem 0.5rem 1rem;
    font-weight: 500;
  }
  
  .select-glass:focus {
    outline: none;
    box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.5);
  }

  /* ============================================
     LOADING STATES
     ============================================ */
  
  .skeleton {
    animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    background: rgba(255, 255, 255, 0.20);
    border-radius: 0.25rem;
  }
  
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }
  
  .skeleton-text {
    height: 1rem;
    @apply skeleton mb-2 last:mb-0;
  }
  
  .skeleton-box {
    @apply skeleton;
    border-radius: 0.75rem;
  }

  /* ============================================
     CHALLENGE TYPE BADGES
     ============================================ */
  
  .challenge-badge-weekly {
    padding: 0.375rem 0.75rem;
    border-radius: 9999px;
    font-weight: 600;
    font-size: 0.75rem;
    background: linear-gradient(to bottom, #16adda, #2f89ef);
    color: white;
    border: 3px solid #4dd4f0;
    box-shadow: 
      0 0 10px rgba(77, 212, 240, 0.5),
      0 0 20px rgba(77, 212, 240, 0.3),
      0 4px 8px rgba(0, 0, 0, 0.2);
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
  }

  @media (min-width: 640px) {
    .challenge-badge-weekly {
      font-size: 0.875rem;
    }
  }

  .challenge-badge-monthly {
    padding: 0.375rem 0.75rem;
    border-radius: 9999px;
    font-weight: 600;
    font-size: 0.75rem;
    background: linear-gradient(to bottom, #b666d2, #9d6bb3);
    color: white;
    border: 3px solid #ea82d5;
    box-shadow: 
      0 0 10px rgba(234, 130, 213, 0.5),
      0 0 20px rgba(234, 130, 213, 0.3),
      0 4px 8px rgba(0, 0, 0, 0.2);
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
  }

  @media (min-width: 640px) {
    .challenge-badge-monthly {
      font-size: 0.875rem;
    }
  }

  .challenge-badge-custom {
    padding: 0.375rem 0.75rem;
    border-radius: 9999px;
    font-weight: 600;
    font-size: 0.75rem;
    background: linear-gradient(to bottom, #f6b026, #d9703f);
    color: white;
    border: 3px solid #ffd75a;
    box-shadow: 
      0 0 10px rgba(255, 215, 90, 0.5),
      0 0 20px rgba(255, 215, 90, 0.3),
      0 4px 8px rgba(0, 0, 0, 0.2);
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
  }

  @media (min-width: 640px) {
    .challenge-badge-custom {
      font-size: 0.875rem;
    }
  }

  /* Range slider styles */
  .slider {
    -webkit-appearance: none;
    appearance: none;
    height: 12px;
    border-radius: 6px;
    outline: none;
  }

  .slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #3b82f6;
    cursor: pointer;
    border: 2px solid white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }

  .slider::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #3b82f6;
    cursor: pointer;
    border: 2px solid white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }
}

@layer utilities {

  .bg-fixed-mobile {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    height: 100lvh;
    min-height: -webkit-fill-available;
  }

  /* Icon-style badge classes */
  .badge-icon-green {
    background: linear-gradient(to bottom, #22c065, #16a66d);
    border: 3px solid rgba(134, 239, 172, 1);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    color: white;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    font-weight: 600;
  }
  
  .badge-icon-orange {
    background: linear-gradient(to bottom, #f6b026, #d9703f);
    border: 3px solid #ffd75a;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    color: white;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    font-weight: 600;
  }

  /* Adaptive Text Shadows for Readability */
  .text-shadow-adaptive-sm {
    text-shadow: 
      0 1px 2px rgba(0, 0, 0, 0.3),
      0 1px 3px rgba(0, 0, 0, 0.2);
  }
  
  .text-shadow-adaptive {
    text-shadow: 
      0 2px 4px rgba(0, 0, 0, 0.3),
      0 2px 8px rgba(0, 0, 0, 0.2),
      0 0 1px rgba(255, 255, 255, 0.1);
  }
  
  .text-shadow-adaptive-lg {
    text-shadow: 
      0 2px 4px rgba(0, 0, 0, 0.4),
      0 4px 8px rgba(0, 0, 0, 0.2),
      0 8px 16px rgba(0, 0, 0, 0.15);
  }

  /* Icon Shadows */
  .icon-shadow-adaptive-sm {
    filter: 
      drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3))
      drop-shadow(0 1px 3px rgba(0, 0, 0, 0.2));
  }

  .icon-shadow-adaptive {
    filter: 
      drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3))
      drop-shadow(0 2px 8px rgba(0, 0, 0, 0.2))
      drop-shadow(0 0 1px rgba(255, 255, 255, 0.1));
  }

  .icon-shadow-adaptive-lg {
    filter: 
      drop-shadow(0 2px 4px rgba(0, 0, 0, 0.4))
      drop-shadow(0 4px 8px rgba(0, 0, 0, 0.2))
      drop-shadow(0 8px 16px rgba(0, 0, 0, 0.15));
  }

  /* Gradient Text */
  .text-gradient-primary {
    background: linear-gradient(to right, #ec4899, #f472b6);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
  }
  
  .text-gradient-blue {
    background: linear-gradient(to right, #3b82f6, #06b6d4);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
  }
  
  .text-gradient-purple {
    background: linear-gradient(to right, #a855f7, #ec4899);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
  }
  
  .text-gradient-green {
    background: linear-gradient(to right, #10b981, #059669);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
  }

  /* Gradient Backgrounds */
  .bg-gradient-primary {
    background: linear-gradient(to right, #ec4899, #f472b6);
  }
  
  .bg-gradient-info {
    background: linear-gradient(to bottom right, #3b82f6, #06b6d4);
  }
  
  .bg-gradient-success {
    background: linear-gradient(to bottom right, #10b981, #059669);
  }

  /* Custom Scrollbar */
  .scrollbar-glass {
    scrollbar-width: thin;
    scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
  }
  
  .scrollbar-glass::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }
  
  .scrollbar-glass::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
  }
  
  .scrollbar-glass::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.3);
    border-radius: 4px;
  }
  
  .scrollbar-glass::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.5);
  }

  /* Green glow effect for current season indicator */
  .box-shadow-green {
    box-shadow: 
      0 0 15px rgba(34, 197, 94, 0.4),
      0 0 30px rgba(34, 197, 94, 0.2);
  }

  /* Icon outlines */
  .orange-outline {
    stroke: rgba(251, 191, 36, 1);
    stroke-width: 3px;
    fill: white;
  }
  
  .blue-outline {
    stroke: rgba(96, 165, 250, 1);
    stroke-width: 3px;
    fill: white;
  }
  
  .green-outline {
    stroke: rgba(74, 222, 128, 1);
    stroke-width: 3px;
    fill: white;
  }

  /* Icon container borders */
  .icon-container-orange {
    border: 3px solid #ffd75a;  
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }
  
  .icon-container-blue {
    border: 3px solid #4dd4f0;  
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }
  
  .icon-container-green {
    border: 3px solid rgba(134, 239, 172, 1);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }

  .icon-container-purple {
    border: 3px solid #ea82d5;  
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }
  
  .icon-container-red {
    border: 3px solid #f87171;  
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }
  
  .icon-container-dark-purple {
    border: 3px solid #a77bc3;  
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }

  /* Podium card borders */
  .podium-border-blue {
    border: 3px solid rgba(147, 197, 253, 1);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }
  
  .podium-border-purple {
    border: 3px solid rgba(196, 181, 253, 1);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }
  
  .podium-border-red {
    border: 3px solid rgba(252, 165, 165, 1);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }

  /* Podium section backgrounds */
  .podium-glass-2-bg {
    background: rgba(255, 255, 255, 0.1);
  }
  
  .podium-bg-blue {
    background: linear-gradient(to bottom, rgba(59, 130, 246, 0.8), rgba(29, 78, 216, 0.8));
  }
  
  .podium-bg-purple {
    background: linear-gradient(to bottom, rgba(168, 85, 247, 0.8), rgba(126, 34, 206, 0.8));
  }
  
  .podium-bg-red {
    background: linear-gradient(to bottom, rgba(239, 68, 68, 0.8), rgba(185, 28, 28, 0.8));
  }

  /* Accuracy badge borders */
  .acc-badge-purple {
    border: 3px solid #ea82d5;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }
  
  .acc-badge-green {
    border: 3px solid rgba(134, 239, 172, 0.8);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }
  
  .acc-badge-blue {
    border: 3px solid rgba(147, 197, 253, 0.8);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }
  
  .acc-badge-yellow {
    border: 3px solid rgba(254, 240, 138, 0.8);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }
  
  .acc-badge-red {
    border: 3px solid rgba(252, 165, 165, 0.8);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }

  /* Difficulty star rating badges */
  .difficulty-star-easy {
    background: linear-gradient(to bottom, #3b82f6, #2563eb);
    border: 3px solid #60a5fa;
    box-shadow: 0 0 8px rgba(96, 165, 250, 0.4), 0 4px 6px rgba(0, 0, 0, 0.2);
  }
  
  .difficulty-star-easy-normal {
    background: linear-gradient(to bottom, #06b6d4, #0891b2);
    border: 3px solid #67e8f9;
    box-shadow: 0 0 8px rgba(103, 232, 249, 0.4), 0 4px 6px rgba(0, 0, 0, 0.2);
  }
  
  .difficulty-star-normal {
    background: linear-gradient(to bottom, #10b981, #059669);
    border: 3px solid #6ee7b7;
    box-shadow: 0 0 8px rgba(110, 231, 183, 0.4), 0 4px 6px rgba(0, 0, 0, 0.2);
  }
  
  .difficulty-star-normal-hard {
    background: linear-gradient(to bottom, #84cc16, #65a30d);
    border: 3px solid #bef264;
    box-shadow: 0 0 8px rgba(190, 242, 100, 0.4), 0 4px 6px rgba(0, 0, 0, 0.2);
  }
  
  .difficulty-star-hard {
    background: linear-gradient(to bottom, #eab308, #ca8a04);
    border: 3px solid #fde047;
    box-shadow: 0 0 8px rgba(253, 224, 71, 0.4), 0 4px 6px rgba(0, 0, 0, 0.2);
  }
  
  .difficulty-star-hard-insane {
    background: linear-gradient(to bottom, #f97316, #ea580c);
    border: 3px solid #fb923c;
    box-shadow: 0 0 8px rgba(251, 146, 60, 0.4), 0 4px 6px rgba(0, 0, 0, 0.2);
  }
  
  .difficulty-star-insane {
    background: linear-gradient(to bottom, #ef4444, #dc2626);
    border: 3px solid #f87171;
    box-shadow: 0 0 8px rgba(248, 113, 113, 0.4), 0 4px 6px rgba(0, 0, 0, 0.2);
  }
  
  .difficulty-star-insane-expert {
    background: linear-gradient(to bottom, #ec4899, #be185d);
    border: 3px solid #f9a8d4;
    box-shadow: 0 0 8px rgba(249, 168, 212, 0.4), 0 4px 6px rgba(0, 0, 0, 0.2);
  }
  
  .difficulty-star-expert {
    background: linear-gradient(to bottom, #a855f7, #9333ea);
    border: 3px solid #c084fc;
    box-shadow: 0 0 8px rgba(192, 132, 252, 0.4), 0 4px 6px rgba(0, 0, 0, 0.2);
  }
  
  .difficulty-star-expert-plus {
    background: linear-gradient(to bottom, #6366f1, #4f46e5);
    border: 3px solid #a5b4fc;
    box-shadow: 0 0 8px rgba(165, 180, 252, 0.4), 0 4px 6px rgba(0, 0, 0, 0.2);
  }

  /* Avatar border with glow */
  .avatar-border {
    border: 3px solid rgba(255, 255, 255, 0.7);
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.5), 0 4px 8px rgba(0, 0, 0, 0.2);
  }

  /* Season dropdown */
  .season-dropdown {
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    background-color: rgba(255, 255, 255, 0.22);
    border: 3px solid rgba(255, 255, 255, 0.15);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }

  /* Season selector button styling */
  .season-selector-btn {
    border: 3px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 0 8px rgba(255, 255, 255, 0.2);
  }
  
  .season-selector-btn:hover {
    border: 3px solid rgba(255, 255, 255, 0.6);
    box-shadow: 0 0 12px rgba(255, 255, 255, 0.4);
  }

  /* View Mode Slider Toggle */
  .view-mode-slider {
    position: relative;
  }

  .slider-track {
    background: rgba(255, 255, 255, 0.25);
    border: 3px solid rgba(255, 255, 255, 0.2);
    border-radius: 9999px;
    padding: 0.25rem;
    display: flex;
    position: relative;
    min-width: 300px;
    box-shadow: 
      0 4px 6px -1px rgba(0, 0, 0, 0.1),
      0 2px 4px -1px rgba(0, 0, 0, 0.06),
      inset 0 1px 0 rgba(255, 255, 255, 0.1),
      inset 0 -1px 0 rgba(0, 0, 0, 0.1);
  }

  .slider-thumb {
    position: absolute;
    top: 4px;
    bottom: 4px;
    left: 4px;
    width: calc(25% - 8px);
    background: linear-gradient(to bottom, #e19d2c, #d1653a);
    border: 3px solid rgba(252, 211, 77, 1);
    border-radius: 9999px;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 
      0 0 8px rgba(252, 211, 77, 0.5),
      0 4px 8px rgba(0, 0, 0, 0.2),
      0 2px 4px rgba(0, 0, 0, 0.1),
      inset 0 1px 0 rgba(255, 255, 255, 0.2);
  }

  .slider-thumb-second {
    left: calc(25% + 4px);
  }

  .slider-thumb-third {
    left: calc(50% + 4px);
  }

  .slider-thumb-fourth {
    left: calc(75% + 4px);
  }

  .slider-option {
    position: relative;
    z-index: 10;
    padding: 0.5rem 0.75rem;
    border-radius: 9999px;
    font-weight: 500;
    transition: all 0.3s ease;
    flex: 1;
    text-align: center;
    font-size: 0.75rem;
    line-height: 1.25rem;
    color: rgba(255, 255, 255, 1);
    text-shadow: 
      0 1px 2px rgba(0, 0, 0, 0.4),
      0 2px 4px rgba(0, 0, 0, 0.3),
      0 4px 8px rgba(0, 0, 0, 0.2);
  }

  .slider-option:hover {
    color: rgba(255, 255, 255, 1);
    text-shadow: 
      0 1px 2px rgba(0, 0, 0, 0.5),
      0 2px 4px rgba(0, 0, 0, 0.4),
      0 4px 8px rgba(0, 0, 0, 0.3);
  }

  .slider-option-active {
    color: rgba(255, 255, 255, 1);
    text-shadow: 
      0 1px 2px rgba(0, 0, 0, 0.6),
      0 2px 4px rgba(0, 0, 0, 0.5),
      0 4px 8px rgba(0, 0, 0, 0.4),
      0 0 8px rgba(255, 255, 255, 0.3);
  }

  @media (max-width: 640px) {
    .slider-track {
      min-width: 280px;
    }
    
    .slider-option {
      font-size: 0.7rem;
      padding: 0.375rem 0.5rem;
    }
  }

  .slider-thumb-two-option {
    position: absolute;
    top: 4px;
    bottom: 4px;
    left: 4px;
    width: calc(50% - 8px);
    background: linear-gradient(to bottom, #e19d2c, #d1653a);
    border: 3px solid rgba(252, 211, 77, 1);
    border-radius: 9999px;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 
      0 0 8px rgba(252, 211, 77, 0.5),
      0 4px 8px rgba(0, 0, 0, 0.2),
      0 2px 4px rgba(0, 0, 0, 0.1),
      inset 0 1px 0 rgba(255, 255, 255, 0.2);
  }

  .slider-thumb-two-option-right {
    left: calc(50% + 4px);
  }

  /* Staff badges */
  .staff-badge {
    padding: 0.5rem 1rem !important;
    border-radius: 9999px !important;
    color: white !important;
    font-weight: 800 !important;
    font-size: 0.875rem !important;
    font-family: 'Inter', sans-serif !important;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3) !important;
    margin: 0.5rem 0 !important;
    display: inline-block !important;
    background: none !important;
    background-image: none !important;
    background-color: transparent !important;
  }

  div.staff-badge.staff-badge-designer,
  .staff-badge-designer.staff-badge {
    background: linear-gradient(to bottom, #15abdc, #2d86dd) !important;
    background-color: #15abdc !important;
    background-image: linear-gradient(to bottom, #15abdc, #2d86dd) !important;
    border: 3px solid #7ad6ff !important;
    box-shadow: 0 0 15px rgba(122, 214, 255, 0.4), 0 4px 6px -1px rgba(0, 0, 0, 0.1) !important;
  }

  div.staff-badge.staff-badge-developer,
  .staff-badge-developer.staff-badge {
    background: linear-gradient(to bottom, #1ebc65, #15a86c) !important;
    background-color: #1ebc65 !important;
    background-image: linear-gradient(to bottom, #1ebc65, #15a86c) !important;
    border: 3px solid #5efa97 !important;
    box-shadow: 0 0 15px rgba(94, 250, 151, 0.4), 0 4px 6px -1px rgba(0, 0, 0, 0.1) !important;
  }

  div.staff-badge.staff-badge-lead,
  .staff-badge-lead.staff-badge {
    background: linear-gradient(to bottom, #eeb345, #c35e2e) !important;
    background-color: #eeb345 !important;
    background-image: linear-gradient(to bottom, #eeb345, #c35e2e) !important;
    border: 3px solid #ffd782 !important;
    box-shadow: 0 0 15px rgba(255, 215, 130, 0.4), 0 4px 6px -1px rgba(0, 0, 0, 0.1) !important;
  }

  div.staff-badge.staff-badge-mapper,
  .staff-badge-mapper.staff-badge {
    background: linear-gradient(to bottom, #e63e3e, #be2625) !important;
    background-color: #e63e3e !important;
    background-image: linear-gradient(to bottom, #e63e3e, #be2625) !important;
    border: 3px solid #ff8074 !important;
    box-shadow: 0 0 15px rgba(255, 128, 116, 0.4), 0 4px 6px -1px rgba(0, 0, 0, 0.1) !important;
  }

  div.staff-badge.staff-badge-strategist,
  .staff-badge-strategist.staff-badge {
    background: linear-gradient(to bottom, #3982fa, #2056c3) !important;
    background-color: #3982fa !important;
    background-image: linear-gradient(to bottom, #3982fa, #2056c3) !important;
    border: 3px solid #72aeff !important;
    box-shadow: 0 0 15px rgba(114, 174, 255, 0.4), 0 4px 6px -1px rgba(0, 0, 0, 0.1) !important;
  }

  div.staff-badge.staff-badge-qa,
  .staff-badge-qa.staff-badge {
    background: linear-gradient(to bottom, #ff6d00, #9b3401) !important;
    background-color: #ff6d00 !important;
    background-image: linear-gradient(to bottom, #ff6d00, #9b3401) !important;
    border: 3px solid #ffa453 !important;
    box-shadow: 0 0 15px rgba(255, 164, 83, 0.4), 0 4px 6px -1px rgba(0, 0, 0, 0.1) !important;
  }

  div.staff-badge.staff-badge-artist,
  .staff-badge-artist.staff-badge {
    background: linear-gradient(to bottom, #8a34e3, #682ec1) !important;
    background-color: #8a34e3 !important;
    background-image: linear-gradient(to bottom, #8a34e3, #682ec1) !important;
    border: 3px solid #c086ff !important;
    box-shadow: 0 0 15px rgba(192, 134, 255, 0.4), 0 4px 6px -1px rgba(0, 0, 0, 0.1) !important;
  }

  .profile-picture {
    filter: drop-shadow(0 8px 16px rgba(0, 0, 0, 0.4)) drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
  }

  .streak-card-current {
    background: linear-gradient(to bottom, #e87114, #823314);
    border: 3px solid #ffa650;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }

  .streak-card-best {
    background: linear-gradient(to bottom, #9cbada, #5d6979);
    border: 3px solid #dcf1ff;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }

  /* Animations */
  .animate-float {
    animation: float 3s ease-in-out infinite;
  }
  
  @keyframes float {
    0%, 100% { transform: translateY(0px); }
    50% { transform: translateY(-10px); }
  }
  
  .animate-pulse-soft {
    animation: pulse-soft 2s ease-in-out infinite;
  }
  
  @keyframes pulse-soft {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.8; }
  }
  
  .animate-slide-up {
    animation: slide-up 0.3s ease-out;
  }
  
  @keyframes slide-up {
    from {
      transform: translateY(10px);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }

  /* Focus States */
  .focus-ring-white {
    outline: none;
  }
  
  .focus-ring-white:focus {
    box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.5);
  }
  
  .focus-ring-primary {
    outline: none;
  }
  
  .focus-ring-primary:focus {
    box-shadow: 0 0 0 2px rgba(236, 72, 153, 0.5);
  }

  /* Utility Classes */
  .center-absolute {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }
  
  .gradient-border {
    background-clip: padding-box;
    border: 2px solid transparent;
    background-image: linear-gradient(white, white), linear-gradient(to right, #ec4899, #db2777);
    background-origin: border-box;
    background-clip: padding-box, border-box;
  }

  /* Line Clamp */
  .line-clamp-2 {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
  
  .line-clamp-3 {
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  /* Text outlines */
  .text-outline-purple {
    color: white;
    -webkit-text-stroke: 2px rgba(196, 181, 253, 1);
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  }

  .text-outline-green {
    color: white;
    -webkit-text-stroke: 2px rgba(134, 239, 172, 1);
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  }

  .text-outline-orange {
    color: white;
    -webkit-text-stroke: 2px rgba(252, 211, 77, 1);
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  }

  .text-outline-blue {
    color: white;
    -webkit-text-stroke: 2px rgba(147, 197, 253, 1);
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  }

  /* Performance card glow effects */
  .performance-card-purple {
    border: 3px solid rgba(196, 181, 253, 0.4);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }

  .performance-card-purple:hover {
    border: 3px solid rgba(196, 181, 253, 0.6);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25);
  }

  .performance-card-green {
    border: 3px solid rgba(134, 239, 172, 0.3);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }

  .performance-card-green:hover {
    border: 3px solid rgba(134, 239, 172, 0.5);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25);
  }

  .performance-card-orange {
    border: 3px solid rgba(252, 211, 77, 0.3);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }

  .performance-card-blue {
    border: 3px solid rgba(147, 197, 253, 0.4);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }

  .performance-card-blue:hover {
    border: 3px solid rgba(147, 197, 253, 0.6);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25);
  }

  /* Text glow effects */
  .text-glow-purple {
    filter: 
      drop-shadow(0 0 4px rgba(196, 181, 253, 0.4))
      drop-shadow(0 0 8px rgba(196, 181, 253, 0.2))
      drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
  }

  .text-glow-green {
    filter: 
      drop-shadow(0 0 4px rgba(134, 239, 172, 0.4))
      drop-shadow(0 0 8px rgba(134, 239, 172, 0.2))
      drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
  }

  .text-glow-orange {
    filter: 
      drop-shadow(0 0 4px rgba(252, 211, 77, 0.4))
      drop-shadow(0 0 8px rgba(252, 211, 77, 0.2))
      drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
  }

  .text-glow-blue {
    filter: 
      drop-shadow(0 0 4px rgba(147, 197, 253, 0.4))
      drop-shadow(0 0 8px rgba(147, 197, 253, 0.2))
      drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
  }

  /* Settings specific glass effects */
  .settings-glass {
    background: rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  .settings-glass-hover:hover {
    background: rgba(255, 255, 255, 0.08);
    border-color: rgba(255, 255, 255, 0.15);
  }
}


================================================
FILE: frontend/supabase/config.toml
================================================
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "frontend"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 15

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

# [db.vault]
# secret_key = "env(SECRET_VALUE)"

[db.migrations]
# Specifies an ordered list of schema files that describe your database.
# Supports glob patterns relative to supabase directory: "./schemas/*.sql"
schema_paths = []

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.rate_limit]
# Number of emails that can be sent per hour. Requires auth.email.smtp to be enabled.
email_sent = 2
# Number of SMS messages that can be sent per hour. Requires auth.sms to be enabled.
sms_sent = 30
# Number of anonymous sign-ins that can be made per hour per IP address. Requires enable_anonymous_sign_ins = true.
anonymous_users = 30
# Number of sessions that can be refreshed in a 5 minute interval per IP address.
token_refresh = 150
# Number of sign up and sign-in requests that can be made in a 5 minute interval per IP address (excludes anonymous users).
sign_in_sign_ups = 30
# Number of OTP / Magic link verifications that can be made in a 5 minute interval per IP address.
token_verifications = 30

# Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.
# [auth.captcha]
# enabled = true
# provider = "hcaptcha"
# secret = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

# Use Clerk as a third-party provider alongside Supabase Auth.
[auth.third_party.clerk]
enabled = false
# Obtain from https://clerk.com/setup/supabase
# domain = "example.clerk.accounts.dev"

[edge_runtime]
enabled = true
# Configure one of the supported request policies: `oneshot`, `per_worker`.
# Use `oneshot` for hot reload, or `per_worker` for load testing.
policy = "oneshot"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083
# The Deno major version to use.
deno_version = 1

# [edge_runtime.secrets]
# secret_key = "env(SECRET_VALUE)"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"



================================================
FILE: .github/workflows/deploy.yml
================================================
name: Deploy osu! Challenge Tracker

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  # Test job
  test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Install frontend dependencies
        working-directory: ./frontend
        run: npm ci
      
      - name: Run frontend tests
        working-directory: ./frontend
        run: npm test -- --passWithNoTests
      
      - name: Run linter
        working-directory: ./frontend
        run: npm run lint
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install backend dependencies
        working-directory: ./backend-worker
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-asyncio
      
      - name: Run backend tests
        working-directory: ./backend-worker
        run: pytest tests/ || echo "No tests yet"

  # Deploy frontend to Vercel
  deploy-frontend:
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          working-directory: ./frontend
          vercel-args: '--prod'

  # Deploy backend to Railway
  deploy-backend:
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Install Railway CLI
        run: npm i -g @railway/cli
      
      - name: Deploy to Railway
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
        working-directory: ./backend-worker
        run: railway up

  # Run database migrations
  migrate-database:
    needs: [deploy-frontend, deploy-backend]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Run Supabase migrations
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          # Install Supabase CLI
          curl -sSL https://github.com/supabase/cli/releases/latest/download/supabase_linux_amd64.tar.gz | tar -xz
          
          # Run any pending migrations
          # ./supabase db push --db-url $SUPABASE_URL

